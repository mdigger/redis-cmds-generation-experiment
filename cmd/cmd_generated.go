// Code generated DO NOT EDIT

package cmd

import "strconv"

// List the ACL categories or the commands inside a category.
//
// Time complexity: O(1) since the categories and commands are a fixed set.
type AclCat Base

// List the ACL categories or the commands inside a category
//
// Command: ACL CAT.
//
// Time complexity: O(1) since the categories and commands are a fixed set.
func (b Builder) AclCat() AclCat {
	c := AclCat{command: emptyCommand(), cslot: b.slot}
	c.command.append("ACL", "CAT")
	return c
}

func (c AclCat) Categoryname(categoryname string) AclCatCategoryname {
	c.command.append(categoryname)
	return AclCatCategoryname(c)
}

// Return Completed Redis command.
func (c AclCat) Build() Completed {
	return completed(c)
}

type AclCatCategoryname Base

// Return Completed Redis command.
func (c AclCatCategoryname) Build() Completed {
	return completed(c)
}

// Remove the specified ACL users and the associated rules.
//
// Time complexity: O(1) amortized time considering the typical user.
type AclDeluser Base

// Remove the specified ACL users and the associated rules
//
// Command: ACL DELUSER.
//
// Time complexity: O(1) amortized time considering the typical user.
func (b Builder) AclDeluser() AclDeluser {
	c := AclDeluser{command: emptyCommand(), cslot: b.slot}
	c.command.append("ACL", "DELUSER")
	return c
}

func (c AclDeluser) Username(username ...string) AclDeluserUsername {
	c.command.append(username...)
	return AclDeluserUsername(c)
}

type AclDeluserUsername Base

func (c AclDeluserUsername) Username(username ...string) AclDeluserUsername {
	c.command.append(username...)
	return c
}

// Return Completed Redis command.
func (c AclDeluserUsername) Build() Completed {
	return completed(c)
}

type AclDryrun Base

// Command: ACL DRYRUN.
func (b Builder) AclDryrun() AclDryrun {
	c := AclDryrun{command: emptyCommand(), cslot: b.slot}
	c.command.append("ACL", "DRYRUN")
	return c
}

func (c AclDryrun) Username(username string) AclDryrunUsername {
	c.command.append(username)
	return AclDryrunUsername(c)
}

type AclDryrunArg Base

func (c AclDryrunArg) Arg(arg ...string) AclDryrunArg {
	c.command.append(arg...)
	return c
}

// Return Completed Redis command.
func (c AclDryrunArg) Build() Completed {
	return completed(c)
}

type AclDryrunCommand Base

func (c AclDryrunCommand) Arg(arg ...string) AclDryrunArg {
	c.command.append(arg...)
	return AclDryrunArg(c)
}

// Return Completed Redis command.
func (c AclDryrunCommand) Build() Completed {
	return completed(c)
}

type AclDryrunUsername Base

func (c AclDryrunUsername) Command(command string) AclDryrunCommand {
	c.command.append(command)
	return AclDryrunCommand(c)
}

// Generate a pseudorandom secure password to use for ACL users.
//
// Time complexity: O(1)
type AclGenpass Base

// Generate a pseudorandom secure password to use for ACL users
//
// Command: ACL GENPASS.
//
// Time complexity: O(1)
func (b Builder) AclGenpass() AclGenpass {
	c := AclGenpass{command: emptyCommand(), cslot: b.slot}
	c.command.append("ACL", "GENPASS")
	return c
}

func (c AclGenpass) Bits(bits int64) AclGenpassBits {
	c.command.append(strconv.FormatInt(bits, 10))
	return AclGenpassBits(c)
}

// Return Completed Redis command.
func (c AclGenpass) Build() Completed {
	return completed(c)
}

type AclGenpassBits Base

// Return Completed Redis command.
func (c AclGenpassBits) Build() Completed {
	return completed(c)
}

// Get the rules for a specific ACL user.
//
// Time complexity: O(N). Where N is the number of password, command and pattern rules that the user has.
type AclGetuser Base

// Get the rules for a specific ACL user
//
// Command: ACL GETUSER.
//
// Time complexity: O(N). Where N is the number of password, command and pattern rules that the user has.
func (b Builder) AclGetuser() AclGetuser {
	c := AclGetuser{command: emptyCommand(), cslot: b.slot}
	c.command.append("ACL", "GETUSER")
	return c
}

func (c AclGetuser) Username(username string) AclGetuserUsername {
	c.command.append(username)
	return AclGetuserUsername(c)
}

type AclGetuserUsername Base

// Return Completed Redis command.
func (c AclGetuserUsername) Build() Completed {
	return completed(c)
}

// Show helpful text about the different subcommands.
//
// Time complexity: O(1)
type AclHelp Base

// Show helpful text about the different subcommands
//
// Command: ACL HELP.
//
// Time complexity: O(1)
func (b Builder) AclHelp() AclHelp {
	c := AclHelp{command: emptyCommand(), cslot: b.slot}
	c.command.append("ACL", "HELP")
	return c
}

// Return Completed Redis command.
func (c AclHelp) Build() Completed {
	return completed(c)
}

// List the current ACL rules in ACL config file format.
//
// Time complexity: O(N). Where N is the number of configured users.
type AclList Base

// List the current ACL rules in ACL config file format
//
// Command: ACL LIST.
//
// Time complexity: O(N). Where N is the number of configured users.
func (b Builder) AclList() AclList {
	c := AclList{command: emptyCommand(), cslot: b.slot}
	c.command.append("ACL", "LIST")
	return c
}

// Return Completed Redis command.
func (c AclList) Build() Completed {
	return completed(c)
}

// Reload the ACLs from the configured ACL file.
//
// Time complexity: O(N). Where N is the number of configured users.
type AclLoad Base

// Reload the ACLs from the configured ACL file
//
// Command: ACL LOAD.
//
// Time complexity: O(N). Where N is the number of configured users.
func (b Builder) AclLoad() AclLoad {
	c := AclLoad{command: emptyCommand(), cslot: b.slot}
	c.command.append("ACL", "LOAD")
	return c
}

// Return Completed Redis command.
func (c AclLoad) Build() Completed {
	return completed(c)
}

// List latest events denied because of ACLs in place.
//
// Time complexity: O(N) with N being the number of entries shown.
type AclLog Base

// List latest events denied because of ACLs in place
//
// Command: ACL LOG.
//
// Time complexity: O(N) with N being the number of entries shown.
func (b Builder) AclLog() AclLog {
	c := AclLog{command: emptyCommand(), cslot: b.slot}
	c.command.append("ACL", "LOG")
	return c
}

func (c AclLog) Count(count int64) AclLogCountCount {
	c.command.append(strconv.FormatInt(count, 10))
	return AclLogCountCount(c)
}

func (c AclLog) Reset() AclLogCountReset {
	c.command.append("RESET")
	return AclLogCountReset(c)
}

type AclLogCountCount Base

func (c AclLogCountCount) Reset() AclLogCountReset {
	c.command.append("RESET")
	return AclLogCountReset(c)
}

// Return Completed Redis command.
func (c AclLogCountCount) Build() Completed {
	return completed(c)
}

type AclLogCountReset Base

// Return Completed Redis command.
func (c AclLogCountReset) Build() Completed {
	return completed(c)
}

// Save the current ACL rules in the configured ACL file.
//
// Time complexity: O(N). Where N is the number of configured users.
type AclSave Base

// Save the current ACL rules in the configured ACL file
//
// Command: ACL SAVE.
//
// Time complexity: O(N). Where N is the number of configured users.
func (b Builder) AclSave() AclSave {
	c := AclSave{command: emptyCommand(), cslot: b.slot}
	c.command.append("ACL", "SAVE")
	return c
}

// Return Completed Redis command.
func (c AclSave) Build() Completed {
	return completed(c)
}

// Modify or create the rules for a specific ACL user.
//
// Time complexity: O(N). Where N is the number of rules provided.
type AclSetuser Base

// Modify or create the rules for a specific ACL user
//
// Command: ACL SETUSER.
//
// Time complexity: O(N). Where N is the number of rules provided.
func (b Builder) AclSetuser() AclSetuser {
	c := AclSetuser{command: emptyCommand(), cslot: b.slot}
	c.command.append("ACL", "SETUSER")
	return c
}

func (c AclSetuser) Username(username string) AclSetuserUsername {
	c.command.append(username)
	return AclSetuserUsername(c)
}

type AclSetuserRule Base

func (c AclSetuserRule) Rule(rule ...string) AclSetuserRule {
	c.command.append(rule...)
	return c
}

// Return Completed Redis command.
func (c AclSetuserRule) Build() Completed {
	return completed(c)
}

type AclSetuserUsername Base

func (c AclSetuserUsername) Rule(rule ...string) AclSetuserRule {
	c.command.append(rule...)
	return AclSetuserRule(c)
}

// Return Completed Redis command.
func (c AclSetuserUsername) Build() Completed {
	return completed(c)
}

// List the username of all the configured ACL rules.
//
// Time complexity: O(N). Where N is the number of configured users.
type AclUsers Base

// List the username of all the configured ACL rules
//
// Command: ACL USERS.
//
// Time complexity: O(N). Where N is the number of configured users.
func (b Builder) AclUsers() AclUsers {
	c := AclUsers{command: emptyCommand(), cslot: b.slot}
	c.command.append("ACL", "USERS")
	return c
}

// Return Completed Redis command.
func (c AclUsers) Build() Completed {
	return completed(c)
}

// Return the name of the user associated to the current connection.
//
// Time complexity: O(1)
type AclWhoami Base

// Return the name of the user associated to the current connection
//
// Command: ACL WHOAMI.
//
// Time complexity: O(1)
func (b Builder) AclWhoami() AclWhoami {
	c := AclWhoami{command: emptyCommand(), cslot: b.slot}
	c.command.append("ACL", "WHOAMI")
	return c
}

// Return Completed Redis command.
func (c AclWhoami) Build() Completed {
	return completed(c)
}

// deletes a model stored as a key's value..
//
// Time complexity: O(1)
type AiModeldel Base

// deletes a model stored as a key's value.
//
// Command: AI.MODELDEL.
//
// Time complexity: O(1)
func (b Builder) AiModeldel() AiModeldel {
	c := AiModeldel{command: emptyCommand(), cslot: b.slot}
	c.command.append("AI.MODELDEL")
	return c
}

func (c AiModeldel) Key(key string) AiModeldelKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return AiModeldelKey(c)
}

type AiModeldelKey Base

// Return Completed Redis command.
func (c AiModeldelKey) Build() Completed {
	return completed(c)
}

// runs a model stored as a key's value using its specified backend and device. It accepts one or more input tensors and store output tensors..
//
// Time complexity: O(1)
type AiModelexecute Base

// runs a model stored as a key's value using its specified backend and device. It accepts one or more input tensors and store output tensors.
//
// Command: AI.MODELEXECUTE.
//
// Time complexity: O(1)
func (b Builder) AiModelexecute() AiModelexecute {
	c := AiModelexecute{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("AI.MODELEXECUTE")
	return c
}

func (c AiModelexecute) Key(key string) AiModelexecuteKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return AiModelexecuteKey(c)
}

type AiModelexecuteInputsInput Base

func (c AiModelexecuteInputsInput) Input(input ...string) AiModelexecuteInputsInput {
	c.command.append(input...)
	return c
}

func (c AiModelexecuteInputsInput) Outputs(outputCount int64) AiModelexecuteOutputsOutputs {
	c.command.append("OUTPUTS", strconv.FormatInt(outputCount, 10))
	return AiModelexecuteOutputsOutputs(c)
}

type AiModelexecuteInputsInputs Base

func (c AiModelexecuteInputsInputs) Input(input ...string) AiModelexecuteInputsInput {
	c.command.append(input...)
	return AiModelexecuteInputsInput(c)
}

type AiModelexecuteKey Base

func (c AiModelexecuteKey) Inputs(inputCount int64) AiModelexecuteInputsInputs {
	c.command.append("INPUTS", strconv.FormatInt(inputCount, 10))
	return AiModelexecuteInputsInputs(c)
}

type AiModelexecuteOutputsOutput Base

func (c AiModelexecuteOutputsOutput) Output(output ...string) AiModelexecuteOutputsOutput {
	c.command.append(output...)
	return c
}

func (c AiModelexecuteOutputsOutput) Timeout(timeout int64) AiModelexecuteTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return AiModelexecuteTimeout(c)
}

// Return Completed Redis command.
func (c AiModelexecuteOutputsOutput) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c AiModelexecuteOutputsOutput) Cache() Cacheable {
	return cacheable(c)
}

type AiModelexecuteOutputsOutputs Base

func (c AiModelexecuteOutputsOutputs) Output(output ...string) AiModelexecuteOutputsOutput {
	c.command.append(output...)
	return AiModelexecuteOutputsOutput(c)
}

type AiModelexecuteTimeout Base

// Return Completed Redis command.
func (c AiModelexecuteTimeout) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c AiModelexecuteTimeout) Cache() Cacheable {
	return cacheable(c)
}

// returns a model's metadata and blob stored as a key's value..
//
// Time complexity: O(1)
type AiModelget Base

// returns a model's metadata and blob stored as a key's value.
//
// Command: AI.MODELGET.
//
// Time complexity: O(1)
func (b Builder) AiModelget() AiModelget {
	c := AiModelget{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("AI.MODELGET")
	return c
}

func (c AiModelget) Key(key string) AiModelgetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return AiModelgetKey(c)
}

type AiModelgetBlob Base

// Return Completed Redis command.
func (c AiModelgetBlob) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c AiModelgetBlob) Cache() Cacheable {
	return cacheable(c)
}

type AiModelgetKey Base

func (c AiModelgetKey) Meta() AiModelgetMeta {
	c.command.append("META")
	return AiModelgetMeta(c)
}

func (c AiModelgetKey) Blob() AiModelgetBlob {
	c.command.append("BLOB")
	return AiModelgetBlob(c)
}

// Return Completed Redis command.
func (c AiModelgetKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c AiModelgetKey) Cache() Cacheable {
	return cacheable(c)
}

type AiModelgetMeta Base

func (c AiModelgetMeta) Blob() AiModelgetBlob {
	c.command.append("BLOB")
	return AiModelgetBlob(c)
}

// Return Completed Redis command.
func (c AiModelgetMeta) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c AiModelgetMeta) Cache() Cacheable {
	return cacheable(c)
}

// stores a model as the value of a key.
//
// Time complexity: O(1)
type AiModelstore Base

// stores a model as the value of a key
//
// Command: AI.MODELSTORE.
//
// Time complexity: O(1)
func (b Builder) AiModelstore() AiModelstore {
	c := AiModelstore{command: emptyCommand(), cslot: b.slot}
	c.command.append("AI.MODELSTORE")
	return c
}

func (c AiModelstore) Key(key string) AiModelstoreKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return AiModelstoreKey(c)
}

type AiModelstoreBackendOnnx Base

func (c AiModelstoreBackendOnnx) Cpu() AiModelstoreDeviceCpu {
	c.command.append("CPU")
	return AiModelstoreDeviceCpu(c)
}

func (c AiModelstoreBackendOnnx) Gpu() AiModelstoreDeviceGpu {
	c.command.append("GPU")
	return AiModelstoreDeviceGpu(c)
}

type AiModelstoreBackendTf Base

func (c AiModelstoreBackendTf) Cpu() AiModelstoreDeviceCpu {
	c.command.append("CPU")
	return AiModelstoreDeviceCpu(c)
}

func (c AiModelstoreBackendTf) Gpu() AiModelstoreDeviceGpu {
	c.command.append("GPU")
	return AiModelstoreDeviceGpu(c)
}

type AiModelstoreBackendTorch Base

func (c AiModelstoreBackendTorch) Cpu() AiModelstoreDeviceCpu {
	c.command.append("CPU")
	return AiModelstoreDeviceCpu(c)
}

func (c AiModelstoreBackendTorch) Gpu() AiModelstoreDeviceGpu {
	c.command.append("GPU")
	return AiModelstoreDeviceGpu(c)
}

type AiModelstoreBatchsize Base

func (c AiModelstoreBatchsize) Minbatchsize(minbatchsize int64) AiModelstoreMinbatchsize {
	c.command.append("MINBATCHSIZE", strconv.FormatInt(minbatchsize, 10))
	return AiModelstoreMinbatchsize(c)
}

func (c AiModelstoreBatchsize) Minbatchtimeout(minbatchtimeout int64) AiModelstoreMinbatchtimeout {
	c.command.append("MINBATCHTIMEOUT", strconv.FormatInt(minbatchtimeout, 10))
	return AiModelstoreMinbatchtimeout(c)
}

func (c AiModelstoreBatchsize) Inputs(inputCount int64) AiModelstoreInputsInputs {
	c.command.append("INPUTS", strconv.FormatInt(inputCount, 10))
	return AiModelstoreInputsInputs(c)
}

func (c AiModelstoreBatchsize) Outputs(outputCount int64) AiModelstoreOutputsOutputs {
	c.command.append("OUTPUTS", strconv.FormatInt(outputCount, 10))
	return AiModelstoreOutputsOutputs(c)
}

func (c AiModelstoreBatchsize) Blob(blob string) AiModelstoreBlob {
	c.command.append("BLOB", blob)
	return AiModelstoreBlob(c)
}

// Return Completed Redis command.
func (c AiModelstoreBatchsize) Build() Completed {
	return completed(c)
}

type AiModelstoreBlob Base

// Return Completed Redis command.
func (c AiModelstoreBlob) Build() Completed {
	return completed(c)
}

type AiModelstoreDeviceCpu Base

func (c AiModelstoreDeviceCpu) Tag(tag string) AiModelstoreTag {
	c.command.append("TAG", tag)
	return AiModelstoreTag(c)
}

func (c AiModelstoreDeviceCpu) Batchsize(batchsize int64) AiModelstoreBatchsize {
	c.command.append("BATCHSIZE", strconv.FormatInt(batchsize, 10))
	return AiModelstoreBatchsize(c)
}

func (c AiModelstoreDeviceCpu) Minbatchsize(minbatchsize int64) AiModelstoreMinbatchsize {
	c.command.append("MINBATCHSIZE", strconv.FormatInt(minbatchsize, 10))
	return AiModelstoreMinbatchsize(c)
}

func (c AiModelstoreDeviceCpu) Minbatchtimeout(minbatchtimeout int64) AiModelstoreMinbatchtimeout {
	c.command.append("MINBATCHTIMEOUT", strconv.FormatInt(minbatchtimeout, 10))
	return AiModelstoreMinbatchtimeout(c)
}

func (c AiModelstoreDeviceCpu) Inputs(inputCount int64) AiModelstoreInputsInputs {
	c.command.append("INPUTS", strconv.FormatInt(inputCount, 10))
	return AiModelstoreInputsInputs(c)
}

func (c AiModelstoreDeviceCpu) Outputs(outputCount int64) AiModelstoreOutputsOutputs {
	c.command.append("OUTPUTS", strconv.FormatInt(outputCount, 10))
	return AiModelstoreOutputsOutputs(c)
}

func (c AiModelstoreDeviceCpu) Blob(blob string) AiModelstoreBlob {
	c.command.append("BLOB", blob)
	return AiModelstoreBlob(c)
}

// Return Completed Redis command.
func (c AiModelstoreDeviceCpu) Build() Completed {
	return completed(c)
}

type AiModelstoreDeviceGpu Base

func (c AiModelstoreDeviceGpu) Tag(tag string) AiModelstoreTag {
	c.command.append("TAG", tag)
	return AiModelstoreTag(c)
}

func (c AiModelstoreDeviceGpu) Batchsize(batchsize int64) AiModelstoreBatchsize {
	c.command.append("BATCHSIZE", strconv.FormatInt(batchsize, 10))
	return AiModelstoreBatchsize(c)
}

func (c AiModelstoreDeviceGpu) Minbatchsize(minbatchsize int64) AiModelstoreMinbatchsize {
	c.command.append("MINBATCHSIZE", strconv.FormatInt(minbatchsize, 10))
	return AiModelstoreMinbatchsize(c)
}

func (c AiModelstoreDeviceGpu) Minbatchtimeout(minbatchtimeout int64) AiModelstoreMinbatchtimeout {
	c.command.append("MINBATCHTIMEOUT", strconv.FormatInt(minbatchtimeout, 10))
	return AiModelstoreMinbatchtimeout(c)
}

func (c AiModelstoreDeviceGpu) Inputs(inputCount int64) AiModelstoreInputsInputs {
	c.command.append("INPUTS", strconv.FormatInt(inputCount, 10))
	return AiModelstoreInputsInputs(c)
}

func (c AiModelstoreDeviceGpu) Outputs(outputCount int64) AiModelstoreOutputsOutputs {
	c.command.append("OUTPUTS", strconv.FormatInt(outputCount, 10))
	return AiModelstoreOutputsOutputs(c)
}

func (c AiModelstoreDeviceGpu) Blob(blob string) AiModelstoreBlob {
	c.command.append("BLOB", blob)
	return AiModelstoreBlob(c)
}

// Return Completed Redis command.
func (c AiModelstoreDeviceGpu) Build() Completed {
	return completed(c)
}

type AiModelstoreInputsInput Base

func (c AiModelstoreInputsInput) Input(input ...string) AiModelstoreInputsInput {
	c.command.append(input...)
	return c
}

func (c AiModelstoreInputsInput) Outputs(outputCount int64) AiModelstoreOutputsOutputs {
	c.command.append("OUTPUTS", strconv.FormatInt(outputCount, 10))
	return AiModelstoreOutputsOutputs(c)
}

func (c AiModelstoreInputsInput) Blob(blob string) AiModelstoreBlob {
	c.command.append("BLOB", blob)
	return AiModelstoreBlob(c)
}

// Return Completed Redis command.
func (c AiModelstoreInputsInput) Build() Completed {
	return completed(c)
}

type AiModelstoreInputsInputs Base

func (c AiModelstoreInputsInputs) Input(input ...string) AiModelstoreInputsInput {
	c.command.append(input...)
	return AiModelstoreInputsInput(c)
}

type AiModelstoreKey Base

func (c AiModelstoreKey) Tf() AiModelstoreBackendTf {
	c.command.append("TF")
	return AiModelstoreBackendTf(c)
}

func (c AiModelstoreKey) Torch() AiModelstoreBackendTorch {
	c.command.append("TORCH")
	return AiModelstoreBackendTorch(c)
}

func (c AiModelstoreKey) Onnx() AiModelstoreBackendOnnx {
	c.command.append("ONNX")
	return AiModelstoreBackendOnnx(c)
}

type AiModelstoreMinbatchsize Base

func (c AiModelstoreMinbatchsize) Minbatchtimeout(minbatchtimeout int64) AiModelstoreMinbatchtimeout {
	c.command.append("MINBATCHTIMEOUT", strconv.FormatInt(minbatchtimeout, 10))
	return AiModelstoreMinbatchtimeout(c)
}

func (c AiModelstoreMinbatchsize) Inputs(inputCount int64) AiModelstoreInputsInputs {
	c.command.append("INPUTS", strconv.FormatInt(inputCount, 10))
	return AiModelstoreInputsInputs(c)
}

func (c AiModelstoreMinbatchsize) Outputs(outputCount int64) AiModelstoreOutputsOutputs {
	c.command.append("OUTPUTS", strconv.FormatInt(outputCount, 10))
	return AiModelstoreOutputsOutputs(c)
}

func (c AiModelstoreMinbatchsize) Blob(blob string) AiModelstoreBlob {
	c.command.append("BLOB", blob)
	return AiModelstoreBlob(c)
}

// Return Completed Redis command.
func (c AiModelstoreMinbatchsize) Build() Completed {
	return completed(c)
}

type AiModelstoreMinbatchtimeout Base

func (c AiModelstoreMinbatchtimeout) Inputs(inputCount int64) AiModelstoreInputsInputs {
	c.command.append("INPUTS", strconv.FormatInt(inputCount, 10))
	return AiModelstoreInputsInputs(c)
}

func (c AiModelstoreMinbatchtimeout) Outputs(outputCount int64) AiModelstoreOutputsOutputs {
	c.command.append("OUTPUTS", strconv.FormatInt(outputCount, 10))
	return AiModelstoreOutputsOutputs(c)
}

func (c AiModelstoreMinbatchtimeout) Blob(blob string) AiModelstoreBlob {
	c.command.append("BLOB", blob)
	return AiModelstoreBlob(c)
}

// Return Completed Redis command.
func (c AiModelstoreMinbatchtimeout) Build() Completed {
	return completed(c)
}

type AiModelstoreOutputsOutput Base

func (c AiModelstoreOutputsOutput) Output(output ...string) AiModelstoreOutputsOutput {
	c.command.append(output...)
	return c
}

func (c AiModelstoreOutputsOutput) Blob(blob string) AiModelstoreBlob {
	c.command.append("BLOB", blob)
	return AiModelstoreBlob(c)
}

// Return Completed Redis command.
func (c AiModelstoreOutputsOutput) Build() Completed {
	return completed(c)
}

type AiModelstoreOutputsOutputs Base

func (c AiModelstoreOutputsOutputs) Output(output ...string) AiModelstoreOutputsOutput {
	c.command.append(output...)
	return AiModelstoreOutputsOutput(c)
}

type AiModelstoreTag Base

func (c AiModelstoreTag) Batchsize(batchsize int64) AiModelstoreBatchsize {
	c.command.append("BATCHSIZE", strconv.FormatInt(batchsize, 10))
	return AiModelstoreBatchsize(c)
}

func (c AiModelstoreTag) Minbatchsize(minbatchsize int64) AiModelstoreMinbatchsize {
	c.command.append("MINBATCHSIZE", strconv.FormatInt(minbatchsize, 10))
	return AiModelstoreMinbatchsize(c)
}

func (c AiModelstoreTag) Minbatchtimeout(minbatchtimeout int64) AiModelstoreMinbatchtimeout {
	c.command.append("MINBATCHTIMEOUT", strconv.FormatInt(minbatchtimeout, 10))
	return AiModelstoreMinbatchtimeout(c)
}

func (c AiModelstoreTag) Inputs(inputCount int64) AiModelstoreInputsInputs {
	c.command.append("INPUTS", strconv.FormatInt(inputCount, 10))
	return AiModelstoreInputsInputs(c)
}

func (c AiModelstoreTag) Outputs(outputCount int64) AiModelstoreOutputsOutputs {
	c.command.append("OUTPUTS", strconv.FormatInt(outputCount, 10))
	return AiModelstoreOutputsOutputs(c)
}

func (c AiModelstoreTag) Blob(blob string) AiModelstoreBlob {
	c.command.append("BLOB", blob)
	return AiModelstoreBlob(c)
}

// Return Completed Redis command.
func (c AiModelstoreTag) Build() Completed {
	return completed(c)
}

// deletes a script stored as a key's value..
//
// Time complexity: O(1)
type AiScriptdel Base

// deletes a script stored as a key's value.
//
// Command: AI.SCRIPTDEL.
//
// Time complexity: O(1)
func (b Builder) AiScriptdel() AiScriptdel {
	c := AiScriptdel{command: emptyCommand(), cslot: b.slot}
	c.command.append("AI.SCRIPTDEL")
	return c
}

func (c AiScriptdel) Key(key string) AiScriptdelKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return AiScriptdelKey(c)
}

type AiScriptdelKey Base

// Return Completed Redis command.
func (c AiScriptdelKey) Build() Completed {
	return completed(c)
}

// command runs a script stored as a key's value on its specified device..
//
// Time complexity: O(1)
type AiScriptexecute Base

// command runs a script stored as a key's value on its specified device.
//
// Command: AI.SCRIPTEXECUTE.
//
// Time complexity: O(1)
func (b Builder) AiScriptexecute() AiScriptexecute {
	c := AiScriptexecute{command: emptyCommand(), cslot: b.slot}
	c.command.append("AI.SCRIPTEXECUTE")
	return c
}

func (c AiScriptexecute) Key(key string) AiScriptexecuteKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return AiScriptexecuteKey(c)
}

type AiScriptexecuteArgsArg Base

func (c AiScriptexecuteArgsArg) Arg(arg ...string) AiScriptexecuteArgsArg {
	c.command.append(arg...)
	return c
}

func (c AiScriptexecuteArgsArg) Outputs(outputCount int64) AiScriptexecuteOutputsOutputs {
	c.command.append("OUTPUTS", strconv.FormatInt(outputCount, 10))
	return AiScriptexecuteOutputsOutputs(c)
}

func (c AiScriptexecuteArgsArg) Timeout(timeout int64) AiScriptexecuteTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return AiScriptexecuteTimeout(c)
}

// Return Completed Redis command.
func (c AiScriptexecuteArgsArg) Build() Completed {
	return completed(c)
}

type AiScriptexecuteArgsArgs Base

func (c AiScriptexecuteArgsArgs) Arg(arg ...string) AiScriptexecuteArgsArg {
	c.command.append(arg...)
	return AiScriptexecuteArgsArg(c)
}

type AiScriptexecuteFunction Base

func (c AiScriptexecuteFunction) Keys(keyCount int64) AiScriptexecuteKeysKeys {
	c.command.append("KEYS", strconv.FormatInt(keyCount, 10))
	return AiScriptexecuteKeysKeys(c)
}

func (c AiScriptexecuteFunction) Inputs(inputCount int64) AiScriptexecuteInputsInputs {
	c.command.append("INPUTS", strconv.FormatInt(inputCount, 10))
	return AiScriptexecuteInputsInputs(c)
}

func (c AiScriptexecuteFunction) Args(argCount int64) AiScriptexecuteArgsArgs {
	c.command.append("ARGS", strconv.FormatInt(argCount, 10))
	return AiScriptexecuteArgsArgs(c)
}

func (c AiScriptexecuteFunction) Outputs(outputCount int64) AiScriptexecuteOutputsOutputs {
	c.command.append("OUTPUTS", strconv.FormatInt(outputCount, 10))
	return AiScriptexecuteOutputsOutputs(c)
}

func (c AiScriptexecuteFunction) Timeout(timeout int64) AiScriptexecuteTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return AiScriptexecuteTimeout(c)
}

// Return Completed Redis command.
func (c AiScriptexecuteFunction) Build() Completed {
	return completed(c)
}

type AiScriptexecuteInputsInput Base

func (c AiScriptexecuteInputsInput) Input(input ...string) AiScriptexecuteInputsInput {
	c.command.append(input...)
	return c
}

func (c AiScriptexecuteInputsInput) Args(argCount int64) AiScriptexecuteArgsArgs {
	c.command.append("ARGS", strconv.FormatInt(argCount, 10))
	return AiScriptexecuteArgsArgs(c)
}

func (c AiScriptexecuteInputsInput) Outputs(outputCount int64) AiScriptexecuteOutputsOutputs {
	c.command.append("OUTPUTS", strconv.FormatInt(outputCount, 10))
	return AiScriptexecuteOutputsOutputs(c)
}

func (c AiScriptexecuteInputsInput) Timeout(timeout int64) AiScriptexecuteTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return AiScriptexecuteTimeout(c)
}

// Return Completed Redis command.
func (c AiScriptexecuteInputsInput) Build() Completed {
	return completed(c)
}

type AiScriptexecuteInputsInputs Base

func (c AiScriptexecuteInputsInputs) Input(input ...string) AiScriptexecuteInputsInput {
	c.command.append(input...)
	return AiScriptexecuteInputsInput(c)
}

type AiScriptexecuteKey Base

func (c AiScriptexecuteKey) Function(function string) AiScriptexecuteFunction {
	c.command.append(function)
	return AiScriptexecuteFunction(c)
}

type AiScriptexecuteKeysKey Base

func (c AiScriptexecuteKeysKey) Key(key ...string) AiScriptexecuteKeysKey {
	c.command.append(key...)
	return c
}

func (c AiScriptexecuteKeysKey) Inputs(inputCount int64) AiScriptexecuteInputsInputs {
	c.command.append("INPUTS", strconv.FormatInt(inputCount, 10))
	return AiScriptexecuteInputsInputs(c)
}

func (c AiScriptexecuteKeysKey) Args(argCount int64) AiScriptexecuteArgsArgs {
	c.command.append("ARGS", strconv.FormatInt(argCount, 10))
	return AiScriptexecuteArgsArgs(c)
}

func (c AiScriptexecuteKeysKey) Outputs(outputCount int64) AiScriptexecuteOutputsOutputs {
	c.command.append("OUTPUTS", strconv.FormatInt(outputCount, 10))
	return AiScriptexecuteOutputsOutputs(c)
}

func (c AiScriptexecuteKeysKey) Timeout(timeout int64) AiScriptexecuteTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return AiScriptexecuteTimeout(c)
}

// Return Completed Redis command.
func (c AiScriptexecuteKeysKey) Build() Completed {
	return completed(c)
}

type AiScriptexecuteKeysKeys Base

func (c AiScriptexecuteKeysKeys) Key(key ...string) AiScriptexecuteKeysKey {
	c.command.append(key...)
	return AiScriptexecuteKeysKey(c)
}

type AiScriptexecuteOutputsOutput Base

func (c AiScriptexecuteOutputsOutput) Output(output ...string) AiScriptexecuteOutputsOutput {
	c.command.append(output...)
	return c
}

func (c AiScriptexecuteOutputsOutput) Timeout(timeout int64) AiScriptexecuteTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return AiScriptexecuteTimeout(c)
}

// Return Completed Redis command.
func (c AiScriptexecuteOutputsOutput) Build() Completed {
	return completed(c)
}

type AiScriptexecuteOutputsOutputs Base

func (c AiScriptexecuteOutputsOutputs) Output(output ...string) AiScriptexecuteOutputsOutput {
	c.command.append(output...)
	return AiScriptexecuteOutputsOutput(c)
}

type AiScriptexecuteTimeout Base

// Return Completed Redis command.
func (c AiScriptexecuteTimeout) Build() Completed {
	return completed(c)
}

// returns the TorchScript stored as a key's value..
//
// Time complexity: O(1)
type AiScriptget Base

// returns the TorchScript stored as a key's value.
//
// Command: AI.SCRIPTGET.
//
// Time complexity: O(1)
func (b Builder) AiScriptget() AiScriptget {
	c := AiScriptget{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("AI.SCRIPTGET")
	return c
}

func (c AiScriptget) Key(key string) AiScriptgetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return AiScriptgetKey(c)
}

type AiScriptgetKey Base

func (c AiScriptgetKey) Meta() AiScriptgetMeta {
	c.command.append("META")
	return AiScriptgetMeta(c)
}

func (c AiScriptgetKey) Source() AiScriptgetSource {
	c.command.append("SOURCE")
	return AiScriptgetSource(c)
}

// Return Completed Redis command.
func (c AiScriptgetKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c AiScriptgetKey) Cache() Cacheable {
	return cacheable(c)
}

type AiScriptgetMeta Base

func (c AiScriptgetMeta) Source() AiScriptgetSource {
	c.command.append("SOURCE")
	return AiScriptgetSource(c)
}

// Return Completed Redis command.
func (c AiScriptgetMeta) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c AiScriptgetMeta) Cache() Cacheable {
	return cacheable(c)
}

type AiScriptgetSource Base

// Return Completed Redis command.
func (c AiScriptgetSource) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c AiScriptgetSource) Cache() Cacheable {
	return cacheable(c)
}

// stores a TorchScript as the value of a key..
//
// Time complexity: O(1)
type AiScriptstore Base

// stores a TorchScript as the value of a key.
//
// Command: AI.SCRIPTSTORE.
//
// Time complexity: O(1)
func (b Builder) AiScriptstore() AiScriptstore {
	c := AiScriptstore{command: emptyCommand(), cslot: b.slot}
	c.command.append("AI.SCRIPTSTORE")
	return c
}

func (c AiScriptstore) Key(key string) AiScriptstoreKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return AiScriptstoreKey(c)
}

type AiScriptstoreDeviceCpu Base

func (c AiScriptstoreDeviceCpu) Tag(tag string) AiScriptstoreTag {
	c.command.append("TAG", tag)
	return AiScriptstoreTag(c)
}

func (c AiScriptstoreDeviceCpu) EntryPoints(entryPointCount int64) AiScriptstoreEntryPointsEntryPoints {
	c.command.append("ENTRY_POINTS", strconv.FormatInt(entryPointCount, 10))
	return AiScriptstoreEntryPointsEntryPoints(c)
}

type AiScriptstoreDeviceGpu Base

func (c AiScriptstoreDeviceGpu) Tag(tag string) AiScriptstoreTag {
	c.command.append("TAG", tag)
	return AiScriptstoreTag(c)
}

func (c AiScriptstoreDeviceGpu) EntryPoints(entryPointCount int64) AiScriptstoreEntryPointsEntryPoints {
	c.command.append("ENTRY_POINTS", strconv.FormatInt(entryPointCount, 10))
	return AiScriptstoreEntryPointsEntryPoints(c)
}

type AiScriptstoreEntryPointsEntryPoint Base

func (c AiScriptstoreEntryPointsEntryPoint) EntryPoint(entryPoint ...string) AiScriptstoreEntryPointsEntryPoint {
	c.command.append(entryPoint...)
	return c
}

// Return Completed Redis command.
func (c AiScriptstoreEntryPointsEntryPoint) Build() Completed {
	return completed(c)
}

type AiScriptstoreEntryPointsEntryPoints Base

func (c AiScriptstoreEntryPointsEntryPoints) EntryPoint(entryPoint ...string) AiScriptstoreEntryPointsEntryPoint {
	c.command.append(entryPoint...)
	return AiScriptstoreEntryPointsEntryPoint(c)
}

type AiScriptstoreKey Base

func (c AiScriptstoreKey) Cpu() AiScriptstoreDeviceCpu {
	c.command.append("CPU")
	return AiScriptstoreDeviceCpu(c)
}

func (c AiScriptstoreKey) Gpu() AiScriptstoreDeviceGpu {
	c.command.append("GPU")
	return AiScriptstoreDeviceGpu(c)
}

type AiScriptstoreTag Base

func (c AiScriptstoreTag) EntryPoints(entryPointCount int64) AiScriptstoreEntryPointsEntryPoints {
	c.command.append("ENTRY_POINTS", strconv.FormatInt(entryPointCount, 10))
	return AiScriptstoreEntryPointsEntryPoints(c)
}

// returns a tensor stored as key's value..
//
// Time complexity: O(1)
type AiTensorget Base

// returns a tensor stored as key's value.
//
// Command: AI.TENSORGET.
//
// Time complexity: O(1)
func (b Builder) AiTensorget() AiTensorget {
	c := AiTensorget{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("AI.TENSORGET")
	return c
}

func (c AiTensorget) Key(key string) AiTensorgetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return AiTensorgetKey(c)
}

type AiTensorgetFormatBlob Base

// Return Completed Redis command.
func (c AiTensorgetFormatBlob) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c AiTensorgetFormatBlob) Cache() Cacheable {
	return cacheable(c)
}

type AiTensorgetFormatValues Base

// Return Completed Redis command.
func (c AiTensorgetFormatValues) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c AiTensorgetFormatValues) Cache() Cacheable {
	return cacheable(c)
}

type AiTensorgetKey Base

func (c AiTensorgetKey) Meta() AiTensorgetMeta {
	c.command.append("META")
	return AiTensorgetMeta(c)
}

type AiTensorgetMeta Base

func (c AiTensorgetMeta) Blob() AiTensorgetFormatBlob {
	c.command.append("BLOB")
	return AiTensorgetFormatBlob(c)
}

func (c AiTensorgetMeta) Values() AiTensorgetFormatValues {
	c.command.append("VALUES")
	return AiTensorgetFormatValues(c)
}

// Return Completed Redis command.
func (c AiTensorgetMeta) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c AiTensorgetMeta) Cache() Cacheable {
	return cacheable(c)
}

// stores a tensor as the value of a key..
//
// Time complexity: O(1)
type AiTensorset Base

// stores a tensor as the value of a key.
//
// Command: AI.TENSORSET.
//
// Time complexity: O(1)
func (b Builder) AiTensorset() AiTensorset {
	c := AiTensorset{command: emptyCommand(), cslot: b.slot}
	c.command.append("AI.TENSORSET")
	return c
}

func (c AiTensorset) Key(key string) AiTensorsetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return AiTensorsetKey(c)
}

type AiTensorsetBlob Base

func (c AiTensorsetBlob) Values(value ...string) AiTensorsetValues {
	c.command.append("VALUES")
	c.command.append(value...)
	return AiTensorsetValues(c)
}

// Return Completed Redis command.
func (c AiTensorsetBlob) Build() Completed {
	return completed(c)
}

type AiTensorsetKey Base

func (c AiTensorsetKey) Float() AiTensorsetTypeFloat {
	c.command.append("FLOAT")
	return AiTensorsetTypeFloat(c)
}

func (c AiTensorsetKey) Double() AiTensorsetTypeDouble {
	c.command.append("DOUBLE")
	return AiTensorsetTypeDouble(c)
}

func (c AiTensorsetKey) Int8() AiTensorsetTypeInt8 {
	c.command.append("INT8")
	return AiTensorsetTypeInt8(c)
}

func (c AiTensorsetKey) Int16() AiTensorsetTypeInt16 {
	c.command.append("INT16")
	return AiTensorsetTypeInt16(c)
}

func (c AiTensorsetKey) Int32() AiTensorsetTypeInt32 {
	c.command.append("INT32")
	return AiTensorsetTypeInt32(c)
}

func (c AiTensorsetKey) Int64() AiTensorsetTypeInt64 {
	c.command.append("INT64")
	return AiTensorsetTypeInt64(c)
}

func (c AiTensorsetKey) Uint8() AiTensorsetTypeUint8 {
	c.command.append("UINT8")
	return AiTensorsetTypeUint8(c)
}

func (c AiTensorsetKey) Uint16() AiTensorsetTypeUint16 {
	c.command.append("UINT16")
	return AiTensorsetTypeUint16(c)
}

func (c AiTensorsetKey) String() AiTensorsetTypeString {
	c.command.append("STRING")
	return AiTensorsetTypeString(c)
}

func (c AiTensorsetKey) Bool() AiTensorsetTypeBool {
	c.command.append("BOOL")
	return AiTensorsetTypeBool(c)
}

type AiTensorsetShape Base

func (c AiTensorsetShape) Shape(shape ...int64) AiTensorsetShape {
	for _, n := range shape {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return c
}

func (c AiTensorsetShape) Blob(blob string) AiTensorsetBlob {
	c.command.append("BLOB", blob)
	return AiTensorsetBlob(c)
}

func (c AiTensorsetShape) Values(value ...string) AiTensorsetValues {
	c.command.append("VALUES")
	c.command.append(value...)
	return AiTensorsetValues(c)
}

// Return Completed Redis command.
func (c AiTensorsetShape) Build() Completed {
	return completed(c)
}

type AiTensorsetTypeBool Base

func (c AiTensorsetTypeBool) Shape(shape ...int64) AiTensorsetShape {
	for _, n := range shape {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return AiTensorsetShape(c)
}

type AiTensorsetTypeDouble Base

func (c AiTensorsetTypeDouble) Shape(shape ...int64) AiTensorsetShape {
	for _, n := range shape {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return AiTensorsetShape(c)
}

type AiTensorsetTypeFloat Base

func (c AiTensorsetTypeFloat) Shape(shape ...int64) AiTensorsetShape {
	for _, n := range shape {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return AiTensorsetShape(c)
}

type AiTensorsetTypeInt16 Base

func (c AiTensorsetTypeInt16) Shape(shape ...int64) AiTensorsetShape {
	for _, n := range shape {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return AiTensorsetShape(c)
}

type AiTensorsetTypeInt32 Base

func (c AiTensorsetTypeInt32) Shape(shape ...int64) AiTensorsetShape {
	for _, n := range shape {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return AiTensorsetShape(c)
}

type AiTensorsetTypeInt64 Base

func (c AiTensorsetTypeInt64) Shape(shape ...int64) AiTensorsetShape {
	for _, n := range shape {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return AiTensorsetShape(c)
}

type AiTensorsetTypeInt8 Base

func (c AiTensorsetTypeInt8) Shape(shape ...int64) AiTensorsetShape {
	for _, n := range shape {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return AiTensorsetShape(c)
}

type AiTensorsetTypeString Base

func (c AiTensorsetTypeString) Shape(shape ...int64) AiTensorsetShape {
	for _, n := range shape {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return AiTensorsetShape(c)
}

type AiTensorsetTypeUint16 Base

func (c AiTensorsetTypeUint16) Shape(shape ...int64) AiTensorsetShape {
	for _, n := range shape {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return AiTensorsetShape(c)
}

type AiTensorsetTypeUint8 Base

func (c AiTensorsetTypeUint8) Shape(shape ...int64) AiTensorsetShape {
	for _, n := range shape {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return AiTensorsetShape(c)
}

type AiTensorsetValues Base

func (c AiTensorsetValues) Values(value ...string) AiTensorsetValues {
	c.command.append("VALUES")
	c.command.append(value...)
	return c
}

// Return Completed Redis command.
func (c AiTensorsetValues) Build() Completed {
	return completed(c)
}

// Append a value to a key.
//
// Time complexity: O(1). The amortized time complexity is O(1) assuming the appended value is small and the already present value is of any size, since the dynamic string library used by Redis will double the free space available on every reallocation.
type Append Base

// Append a value to a key
//
// Command: APPEND.
//
// Time complexity: O(1). The amortized time complexity is O(1) assuming the appended value is small and the already present value is of any size, since the dynamic string library used by Redis will double the free space available on every reallocation.
func (b Builder) Append() Append {
	c := Append{command: emptyCommand(), cslot: b.slot}
	c.command.append("APPEND")
	return c
}

func (c Append) Key(key string) AppendKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return AppendKey(c)
}

type AppendKey Base

func (c AppendKey) Value(value string) AppendValue {
	c.command.append(value)
	return AppendValue(c)
}

type AppendValue Base

// Return Completed Redis command.
func (c AppendValue) Build() Completed {
	return completed(c)
}

// Sent by cluster clients after an -ASK redirect.
//
// Time complexity: O(1)
type Asking Base

// Sent by cluster clients after an -ASK redirect
//
// Command: ASKING.
//
// Time complexity: O(1)
func (b Builder) Asking() Asking {
	c := Asking{command: emptyCommand(), cslot: b.slot}
	c.command.append("ASKING")
	return c
}

// Return Completed Redis command.
func (c Asking) Build() Completed {
	return completed(c)
}

// Authenticate to the server.
type Auth Base

// Authenticate to the server
//
// Command: AUTH.
func (b Builder) Auth() Auth {
	c := Auth{command: emptyCommand(), cslot: b.slot}
	c.command.append("AUTH")
	return c
}

func (c Auth) Username(username string) AuthUsername {
	c.command.append(username)
	return AuthUsername(c)
}

func (c Auth) Password(password string) AuthPassword {
	c.command.append(password)
	return AuthPassword(c)
}

type AuthPassword Base

// Return Completed Redis command.
func (c AuthPassword) Build() Completed {
	return completed(c)
}

type AuthUsername Base

func (c AuthUsername) Password(password string) AuthPassword {
	c.command.append(password)
	return AuthPassword(c)
}

// Adds an item to a Bloom Filter.
//
// Time complexity: O(k), where k is the number of hash functions used by the last sub-filter
type BfAdd Base

// Adds an item to a Bloom Filter
//
// Command: BF.ADD.
//
// Time complexity: O(k), where k is the number of hash functions used by the last sub-filter
func (b Builder) BfAdd() BfAdd {
	c := BfAdd{command: emptyCommand(), cslot: b.slot}
	c.command.append("BF.ADD")
	return c
}

func (c BfAdd) Key(key string) BfAddKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return BfAddKey(c)
}

type BfAddItem Base

// Return Completed Redis command.
func (c BfAddItem) Build() Completed {
	return completed(c)
}

type BfAddKey Base

func (c BfAddKey) Item(item string) BfAddItem {
	c.command.append(item)
	return BfAddItem(c)
}

// Checks whether an item exists in a Bloom Filter.
//
// Time complexity: O(k), where k is the number of hash functions used by the last sub-filter
type BfExists Base

// Checks whether an item exists in a Bloom Filter
//
// Command: BF.EXISTS.
//
// Time complexity: O(k), where k is the number of hash functions used by the last sub-filter
func (b Builder) BfExists() BfExists {
	c := BfExists{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("BF.EXISTS")
	return c
}

func (c BfExists) Key(key string) BfExistsKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return BfExistsKey(c)
}

type BfExistsItem Base

// Return Completed Redis command.
func (c BfExistsItem) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BfExistsItem) Cache() Cacheable {
	return cacheable(c)
}

type BfExistsKey Base

func (c BfExistsKey) Item(item string) BfExistsItem {
	c.command.append(item)
	return BfExistsItem(c)
}

// Returns information about a Bloom Filter.
//
// Time complexity: O(1)
type BfInfo Base

// Returns information about a Bloom Filter
//
// Command: BF.INFO.
//
// Time complexity: O(1)
func (b Builder) BfInfo() BfInfo {
	c := BfInfo{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("BF.INFO")
	return c
}

func (c BfInfo) Key(key string) BfInfoKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return BfInfoKey(c)
}

type BfInfoKey Base

func (c BfInfoKey) Capacity() BfInfoSingleValueCapacity {
	c.command.append("CAPACITY")
	return BfInfoSingleValueCapacity(c)
}

func (c BfInfoKey) Size() BfInfoSingleValueSize {
	c.command.append("SIZE")
	return BfInfoSingleValueSize(c)
}

func (c BfInfoKey) Filters() BfInfoSingleValueFilters {
	c.command.append("FILTERS")
	return BfInfoSingleValueFilters(c)
}

func (c BfInfoKey) Items() BfInfoSingleValueItems {
	c.command.append("ITEMS")
	return BfInfoSingleValueItems(c)
}

func (c BfInfoKey) Expansion() BfInfoSingleValueExpansion {
	c.command.append("EXPANSION")
	return BfInfoSingleValueExpansion(c)
}

// Return Completed Redis command.
func (c BfInfoKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BfInfoKey) Cache() Cacheable {
	return cacheable(c)
}

type BfInfoSingleValueCapacity Base

// Return Completed Redis command.
func (c BfInfoSingleValueCapacity) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BfInfoSingleValueCapacity) Cache() Cacheable {
	return cacheable(c)
}

type BfInfoSingleValueExpansion Base

// Return Completed Redis command.
func (c BfInfoSingleValueExpansion) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BfInfoSingleValueExpansion) Cache() Cacheable {
	return cacheable(c)
}

type BfInfoSingleValueFilters Base

// Return Completed Redis command.
func (c BfInfoSingleValueFilters) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BfInfoSingleValueFilters) Cache() Cacheable {
	return cacheable(c)
}

type BfInfoSingleValueItems Base

// Return Completed Redis command.
func (c BfInfoSingleValueItems) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BfInfoSingleValueItems) Cache() Cacheable {
	return cacheable(c)
}

type BfInfoSingleValueSize Base

// Return Completed Redis command.
func (c BfInfoSingleValueSize) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BfInfoSingleValueSize) Cache() Cacheable {
	return cacheable(c)
}

// Adds one or more items to a Bloom Filter. A filter will be created if it does not exist.
//
// Time complexity: O(k * n), where k is the number of hash functions and n is the number of items
type BfInsert Base

// Adds one or more items to a Bloom Filter. A filter will be created if it does not exist
//
// Command: BF.INSERT.
//
// Time complexity: O(k * n), where k is the number of hash functions and n is the number of items
func (b Builder) BfInsert() BfInsert {
	c := BfInsert{command: emptyCommand(), cslot: b.slot}
	c.command.append("BF.INSERT")
	return c
}

func (c BfInsert) Key(key string) BfInsertKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return BfInsertKey(c)
}

type BfInsertCapacity Base

func (c BfInsertCapacity) Error(error float64) BfInsertError {
	c.command.append("ERROR", strconv.FormatFloat(error, 'f', -1, 64))
	return BfInsertError(c)
}

func (c BfInsertCapacity) Expansion(expansion int64) BfInsertExpansion {
	c.command.append("EXPANSION", strconv.FormatInt(expansion, 10))
	return BfInsertExpansion(c)
}

func (c BfInsertCapacity) Nocreate() BfInsertNocreate {
	c.command.append("NOCREATE")
	return BfInsertNocreate(c)
}

func (c BfInsertCapacity) Nonscaling() BfInsertNonscaling {
	c.command.append("NONSCALING")
	return BfInsertNonscaling(c)
}

func (c BfInsertCapacity) Items() BfInsertItems {
	c.command.append("ITEMS")
	return BfInsertItems(c)
}

type BfInsertError Base

func (c BfInsertError) Expansion(expansion int64) BfInsertExpansion {
	c.command.append("EXPANSION", strconv.FormatInt(expansion, 10))
	return BfInsertExpansion(c)
}

func (c BfInsertError) Nocreate() BfInsertNocreate {
	c.command.append("NOCREATE")
	return BfInsertNocreate(c)
}

func (c BfInsertError) Nonscaling() BfInsertNonscaling {
	c.command.append("NONSCALING")
	return BfInsertNonscaling(c)
}

func (c BfInsertError) Items() BfInsertItems {
	c.command.append("ITEMS")
	return BfInsertItems(c)
}

type BfInsertExpansion Base

func (c BfInsertExpansion) Nocreate() BfInsertNocreate {
	c.command.append("NOCREATE")
	return BfInsertNocreate(c)
}

func (c BfInsertExpansion) Nonscaling() BfInsertNonscaling {
	c.command.append("NONSCALING")
	return BfInsertNonscaling(c)
}

func (c BfInsertExpansion) Items() BfInsertItems {
	c.command.append("ITEMS")
	return BfInsertItems(c)
}

type BfInsertItem Base

func (c BfInsertItem) Item(item ...string) BfInsertItem {
	c.command.append(item...)
	return c
}

// Return Completed Redis command.
func (c BfInsertItem) Build() Completed {
	return completed(c)
}

type BfInsertItems Base

func (c BfInsertItems) Item(item ...string) BfInsertItem {
	c.command.append(item...)
	return BfInsertItem(c)
}

type BfInsertKey Base

func (c BfInsertKey) Capacity(capacity int64) BfInsertCapacity {
	c.command.append("CAPACITY", strconv.FormatInt(capacity, 10))
	return BfInsertCapacity(c)
}

func (c BfInsertKey) Error(error float64) BfInsertError {
	c.command.append("ERROR", strconv.FormatFloat(error, 'f', -1, 64))
	return BfInsertError(c)
}

func (c BfInsertKey) Expansion(expansion int64) BfInsertExpansion {
	c.command.append("EXPANSION", strconv.FormatInt(expansion, 10))
	return BfInsertExpansion(c)
}

func (c BfInsertKey) Nocreate() BfInsertNocreate {
	c.command.append("NOCREATE")
	return BfInsertNocreate(c)
}

func (c BfInsertKey) Nonscaling() BfInsertNonscaling {
	c.command.append("NONSCALING")
	return BfInsertNonscaling(c)
}

func (c BfInsertKey) Items() BfInsertItems {
	c.command.append("ITEMS")
	return BfInsertItems(c)
}

type BfInsertNocreate Base

func (c BfInsertNocreate) Nonscaling() BfInsertNonscaling {
	c.command.append("NONSCALING")
	return BfInsertNonscaling(c)
}

func (c BfInsertNocreate) Items() BfInsertItems {
	c.command.append("ITEMS")
	return BfInsertItems(c)
}

type BfInsertNonscaling Base

func (c BfInsertNonscaling) Items() BfInsertItems {
	c.command.append("ITEMS")
	return BfInsertItems(c)
}

// Restores a filter previously saved using SCANDUMP.
//
// Time complexity: O(n), where n is the capacity
type BfLoadchunk Base

// Restores a filter previously saved using SCANDUMP
//
// Command: BF.LOADCHUNK.
//
// Time complexity: O(n), where n is the capacity
func (b Builder) BfLoadchunk() BfLoadchunk {
	c := BfLoadchunk{command: emptyCommand(), cslot: b.slot}
	c.command.append("BF.LOADCHUNK")
	return c
}

func (c BfLoadchunk) Key(key string) BfLoadchunkKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return BfLoadchunkKey(c)
}

type BfLoadchunkData Base

// Return Completed Redis command.
func (c BfLoadchunkData) Build() Completed {
	return completed(c)
}

type BfLoadchunkIterator Base

func (c BfLoadchunkIterator) Data(data string) BfLoadchunkData {
	c.command.append(data)
	return BfLoadchunkData(c)
}

type BfLoadchunkKey Base

func (c BfLoadchunkKey) Iterator(iterator int64) BfLoadchunkIterator {
	c.command.append(strconv.FormatInt(iterator, 10))
	return BfLoadchunkIterator(c)
}

// Adds one or more items to a Bloom Filter. A filter will be created if it does not exist.
//
// Time complexity: O(k * n), where k is the number of hash functions and n is the number of items
type BfMadd Base

// Adds one or more items to a Bloom Filter. A filter will be created if it does not exist
//
// Command: BF.MADD.
//
// Time complexity: O(k * n), where k is the number of hash functions and n is the number of items
func (b Builder) BfMadd() BfMadd {
	c := BfMadd{command: emptyCommand(), cslot: b.slot}
	c.command.append("BF.MADD")
	return c
}

func (c BfMadd) Key(key string) BfMaddKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return BfMaddKey(c)
}

type BfMaddItem Base

func (c BfMaddItem) Item(item ...string) BfMaddItem {
	c.command.append(item...)
	return c
}

// Return Completed Redis command.
func (c BfMaddItem) Build() Completed {
	return completed(c)
}

type BfMaddKey Base

func (c BfMaddKey) Item(item ...string) BfMaddItem {
	c.command.append(item...)
	return BfMaddItem(c)
}

// Checks whether one or more items exist in a Bloom Filter.
//
// Time complexity: O(k * n), where k is the number of hash functions and n is the number of items
type BfMexists Base

// Checks whether one or more items exist in a Bloom Filter
//
// Command: BF.MEXISTS.
//
// Time complexity: O(k * n), where k is the number of hash functions and n is the number of items
func (b Builder) BfMexists() BfMexists {
	c := BfMexists{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("BF.MEXISTS")
	return c
}

func (c BfMexists) Key(key string) BfMexistsKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return BfMexistsKey(c)
}

type BfMexistsItem Base

func (c BfMexistsItem) Item(item ...string) BfMexistsItem {
	c.command.append(item...)
	return c
}

// Return Completed Redis command.
func (c BfMexistsItem) Build() Completed {
	return completed(c)
}

type BfMexistsKey Base

func (c BfMexistsKey) Item(item ...string) BfMexistsItem {
	c.command.append(item...)
	return BfMexistsItem(c)
}

// Creates a new Bloom Filter.
//
// Time complexity: O(1)
type BfReserve Base

// Creates a new Bloom Filter
//
// Command: BF.RESERVE.
//
// Time complexity: O(1)
func (b Builder) BfReserve() BfReserve {
	c := BfReserve{command: emptyCommand(), cslot: b.slot}
	c.command.append("BF.RESERVE")
	return c
}

func (c BfReserve) Key(key string) BfReserveKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return BfReserveKey(c)
}

type BfReserveCapacity Base

func (c BfReserveCapacity) Expansion(expansion int64) BfReserveExpansion {
	c.command.append("EXPANSION", strconv.FormatInt(expansion, 10))
	return BfReserveExpansion(c)
}

func (c BfReserveCapacity) Nonscaling() BfReserveNonscaling {
	c.command.append("NONSCALING")
	return BfReserveNonscaling(c)
}

// Return Completed Redis command.
func (c BfReserveCapacity) Build() Completed {
	return completed(c)
}

type BfReserveErrorRate Base

func (c BfReserveErrorRate) Capacity(capacity int64) BfReserveCapacity {
	c.command.append(strconv.FormatInt(capacity, 10))
	return BfReserveCapacity(c)
}

type BfReserveExpansion Base

func (c BfReserveExpansion) Nonscaling() BfReserveNonscaling {
	c.command.append("NONSCALING")
	return BfReserveNonscaling(c)
}

// Return Completed Redis command.
func (c BfReserveExpansion) Build() Completed {
	return completed(c)
}

type BfReserveKey Base

func (c BfReserveKey) ErrorRate(errorRate float64) BfReserveErrorRate {
	c.command.append(strconv.FormatFloat(errorRate, 'f', -1, 64))
	return BfReserveErrorRate(c)
}

type BfReserveNonscaling Base

// Return Completed Redis command.
func (c BfReserveNonscaling) Build() Completed {
	return completed(c)
}

// Begins an incremental save of the bloom filter.
//
// Time complexity: O(n), where n is the capacity
type BfScandump Base

// Begins an incremental save of the bloom filter
//
// Command: BF.SCANDUMP.
//
// Time complexity: O(n), where n is the capacity
func (b Builder) BfScandump() BfScandump {
	c := BfScandump{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("BF.SCANDUMP")
	return c
}

func (c BfScandump) Key(key string) BfScandumpKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return BfScandumpKey(c)
}

type BfScandumpIterator Base

// Return Completed Redis command.
func (c BfScandumpIterator) Build() Completed {
	return completed(c)
}

type BfScandumpKey Base

func (c BfScandumpKey) Iterator(iterator int64) BfScandumpIterator {
	c.command.append(strconv.FormatInt(iterator, 10))
	return BfScandumpIterator(c)
}

// Asynchronously rewrite the append-only file.
type Bgrewriteaof Base

// Asynchronously rewrite the append-only file
//
// Command: BGREWRITEAOF.
func (b Builder) Bgrewriteaof() Bgrewriteaof {
	c := Bgrewriteaof{command: emptyCommand(), cslot: b.slot}
	c.command.append("BGREWRITEAOF")
	return c
}

// Return Completed Redis command.
func (c Bgrewriteaof) Build() Completed {
	return completed(c)
}

// Asynchronously save the dataset to disk.
type Bgsave Base

// Asynchronously save the dataset to disk
//
// Command: BGSAVE.
func (b Builder) Bgsave() Bgsave {
	c := Bgsave{command: emptyCommand(), cslot: b.slot}
	c.command.append("BGSAVE")
	return c
}

func (c Bgsave) Schedule() BgsaveSchedule {
	c.command.append("SCHEDULE")
	return BgsaveSchedule(c)
}

// Return Completed Redis command.
func (c Bgsave) Build() Completed {
	return completed(c)
}

type BgsaveSchedule Base

// Return Completed Redis command.
func (c BgsaveSchedule) Build() Completed {
	return completed(c)
}

// Count set bits in a string.
//
// Time complexity: O(N)
type Bitcount Base

// Count set bits in a string
//
// Command: BITCOUNT.
//
// Time complexity: O(N)
func (b Builder) Bitcount() Bitcount {
	c := Bitcount{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("BITCOUNT")
	return c
}

func (c Bitcount) Key(key string) BitcountKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return BitcountKey(c)
}

type BitcountIndexEnd Base

func (c BitcountIndexEnd) Byte() BitcountIndexIndexUnitByte {
	c.command.append("BYTE")
	return BitcountIndexIndexUnitByte(c)
}

func (c BitcountIndexEnd) Bit() BitcountIndexIndexUnitBit {
	c.command.append("BIT")
	return BitcountIndexIndexUnitBit(c)
}

// Return Completed Redis command.
func (c BitcountIndexEnd) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BitcountIndexEnd) Cache() Cacheable {
	return cacheable(c)
}

type BitcountIndexIndexUnitBit Base

// Return Completed Redis command.
func (c BitcountIndexIndexUnitBit) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BitcountIndexIndexUnitBit) Cache() Cacheable {
	return cacheable(c)
}

type BitcountIndexIndexUnitByte Base

// Return Completed Redis command.
func (c BitcountIndexIndexUnitByte) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BitcountIndexIndexUnitByte) Cache() Cacheable {
	return cacheable(c)
}

type BitcountIndexStart Base

func (c BitcountIndexStart) End(end int64) BitcountIndexEnd {
	c.command.append(strconv.FormatInt(end, 10))
	return BitcountIndexEnd(c)
}

type BitcountKey Base

func (c BitcountKey) Start(start int64) BitcountIndexStart {
	c.command.append(strconv.FormatInt(start, 10))
	return BitcountIndexStart(c)
}

// Return Completed Redis command.
func (c BitcountKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BitcountKey) Cache() Cacheable {
	return cacheable(c)
}

// Perform arbitrary bitfield integer operations on strings.
//
// Time complexity: O(1) for each subcommand specified
type Bitfield Base

// Perform arbitrary bitfield integer operations on strings
//
// Command: BITFIELD.
//
// Time complexity: O(1) for each subcommand specified
func (b Builder) Bitfield() Bitfield {
	c := Bitfield{command: emptyCommand(), cslot: b.slot}
	c.command.append("BITFIELD")
	return c
}

func (c Bitfield) Key(key string) BitfieldKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return BitfieldKey(c)
}

type BitfieldKey Base

func (c BitfieldKey) Get(encoding string, offset int64) BitfieldOperationGet {
	c.command.append("GET", encoding, strconv.FormatInt(offset, 10))
	return BitfieldOperationGet(c)
}

func (c BitfieldKey) OverflowWrap() BitfieldOperationWriteOverflowWrap {
	c.command.append("OVERFLOW", "WRAP")
	return BitfieldOperationWriteOverflowWrap(c)
}

func (c BitfieldKey) OverflowSat() BitfieldOperationWriteOverflowSat {
	c.command.append("OVERFLOW", "SAT")
	return BitfieldOperationWriteOverflowSat(c)
}

func (c BitfieldKey) OverflowFail() BitfieldOperationWriteOverflowFail {
	c.command.append("OVERFLOW", "FAIL")
	return BitfieldOperationWriteOverflowFail(c)
}

func (c BitfieldKey) Set(encoding string, offset int64, value int64) BitfieldOperationWriteSetSet {
	c.command.append("SET", encoding, strconv.FormatInt(offset, 10), strconv.FormatInt(value, 10))
	return BitfieldOperationWriteSetSet(c)
}

func (c BitfieldKey) Incrby(encoding string, offset int64, increment int64) BitfieldOperationWriteSetIncrby {
	c.command.append("INCRBY", encoding, strconv.FormatInt(offset, 10), strconv.FormatInt(increment, 10))
	return BitfieldOperationWriteSetIncrby(c)
}

type BitfieldOperationGet Base

func (c BitfieldOperationGet) OverflowWrap() BitfieldOperationWriteOverflowWrap {
	c.command.append("OVERFLOW", "WRAP")
	return BitfieldOperationWriteOverflowWrap(c)
}

func (c BitfieldOperationGet) OverflowSat() BitfieldOperationWriteOverflowSat {
	c.command.append("OVERFLOW", "SAT")
	return BitfieldOperationWriteOverflowSat(c)
}

func (c BitfieldOperationGet) OverflowFail() BitfieldOperationWriteOverflowFail {
	c.command.append("OVERFLOW", "FAIL")
	return BitfieldOperationWriteOverflowFail(c)
}

func (c BitfieldOperationGet) Set(encoding string, offset int64, value int64) BitfieldOperationWriteSetSet {
	c.command.append("SET", encoding, strconv.FormatInt(offset, 10), strconv.FormatInt(value, 10))
	return BitfieldOperationWriteSetSet(c)
}

func (c BitfieldOperationGet) Incrby(encoding string, offset int64, increment int64) BitfieldOperationWriteSetIncrby {
	c.command.append("INCRBY", encoding, strconv.FormatInt(offset, 10), strconv.FormatInt(increment, 10))
	return BitfieldOperationWriteSetIncrby(c)
}

type BitfieldOperationWriteOverflowFail Base

func (c BitfieldOperationWriteOverflowFail) Set(encoding string, offset int64, value int64) BitfieldOperationWriteSetSet {
	c.command.append("SET", encoding, strconv.FormatInt(offset, 10), strconv.FormatInt(value, 10))
	return BitfieldOperationWriteSetSet(c)
}

func (c BitfieldOperationWriteOverflowFail) Incrby(encoding string, offset int64, increment int64) BitfieldOperationWriteSetIncrby {
	c.command.append("INCRBY", encoding, strconv.FormatInt(offset, 10), strconv.FormatInt(increment, 10))
	return BitfieldOperationWriteSetIncrby(c)
}

type BitfieldOperationWriteOverflowSat Base

func (c BitfieldOperationWriteOverflowSat) Set(encoding string, offset int64, value int64) BitfieldOperationWriteSetSet {
	c.command.append("SET", encoding, strconv.FormatInt(offset, 10), strconv.FormatInt(value, 10))
	return BitfieldOperationWriteSetSet(c)
}

func (c BitfieldOperationWriteOverflowSat) Incrby(encoding string, offset int64, increment int64) BitfieldOperationWriteSetIncrby {
	c.command.append("INCRBY", encoding, strconv.FormatInt(offset, 10), strconv.FormatInt(increment, 10))
	return BitfieldOperationWriteSetIncrby(c)
}

type BitfieldOperationWriteOverflowWrap Base

func (c BitfieldOperationWriteOverflowWrap) Set(encoding string, offset int64, value int64) BitfieldOperationWriteSetSet {
	c.command.append("SET", encoding, strconv.FormatInt(offset, 10), strconv.FormatInt(value, 10))
	return BitfieldOperationWriteSetSet(c)
}

func (c BitfieldOperationWriteOverflowWrap) Incrby(encoding string, offset int64, increment int64) BitfieldOperationWriteSetIncrby {
	c.command.append("INCRBY", encoding, strconv.FormatInt(offset, 10), strconv.FormatInt(increment, 10))
	return BitfieldOperationWriteSetIncrby(c)
}

type BitfieldOperationWriteSetIncrby Base

func (c BitfieldOperationWriteSetIncrby) Get(encoding string, offset int64) BitfieldOperationGet {
	c.command.append("GET", encoding, strconv.FormatInt(offset, 10))
	return BitfieldOperationGet(c)
}

func (c BitfieldOperationWriteSetIncrby) OverflowWrap() BitfieldOperationWriteOverflowWrap {
	c.command.append("OVERFLOW", "WRAP")
	return BitfieldOperationWriteOverflowWrap(c)
}

func (c BitfieldOperationWriteSetIncrby) OverflowSat() BitfieldOperationWriteOverflowSat {
	c.command.append("OVERFLOW", "SAT")
	return BitfieldOperationWriteOverflowSat(c)
}

func (c BitfieldOperationWriteSetIncrby) OverflowFail() BitfieldOperationWriteOverflowFail {
	c.command.append("OVERFLOW", "FAIL")
	return BitfieldOperationWriteOverflowFail(c)
}

func (c BitfieldOperationWriteSetIncrby) Set(encoding string, offset int64, value int64) BitfieldOperationWriteSetSet {
	c.command.append("SET", encoding, strconv.FormatInt(offset, 10), strconv.FormatInt(value, 10))
	return BitfieldOperationWriteSetSet(c)
}

func (c BitfieldOperationWriteSetIncrby) Incrby(encoding string, offset int64, increment int64) BitfieldOperationWriteSetIncrby {
	c.command.append("INCRBY", encoding, strconv.FormatInt(offset, 10), strconv.FormatInt(increment, 10))
	return c
}

// Return Completed Redis command.
func (c BitfieldOperationWriteSetIncrby) Build() Completed {
	return completed(c)
}

type BitfieldOperationWriteSetSet Base

func (c BitfieldOperationWriteSetSet) Incrby(encoding string, offset int64, increment int64) BitfieldOperationWriteSetIncrby {
	c.command.append("INCRBY", encoding, strconv.FormatInt(offset, 10), strconv.FormatInt(increment, 10))
	return BitfieldOperationWriteSetIncrby(c)
}

func (c BitfieldOperationWriteSetSet) Get(encoding string, offset int64) BitfieldOperationGet {
	c.command.append("GET", encoding, strconv.FormatInt(offset, 10))
	return BitfieldOperationGet(c)
}

func (c BitfieldOperationWriteSetSet) OverflowWrap() BitfieldOperationWriteOverflowWrap {
	c.command.append("OVERFLOW", "WRAP")
	return BitfieldOperationWriteOverflowWrap(c)
}

func (c BitfieldOperationWriteSetSet) OverflowSat() BitfieldOperationWriteOverflowSat {
	c.command.append("OVERFLOW", "SAT")
	return BitfieldOperationWriteOverflowSat(c)
}

func (c BitfieldOperationWriteSetSet) OverflowFail() BitfieldOperationWriteOverflowFail {
	c.command.append("OVERFLOW", "FAIL")
	return BitfieldOperationWriteOverflowFail(c)
}

func (c BitfieldOperationWriteSetSet) Set(encoding string, offset int64, value int64) BitfieldOperationWriteSetSet {
	c.command.append("SET", encoding, strconv.FormatInt(offset, 10), strconv.FormatInt(value, 10))
	return c
}

// Return Completed Redis command.
func (c BitfieldOperationWriteSetSet) Build() Completed {
	return completed(c)
}

// Perform arbitrary bitfield integer operations on strings. Read-only variant of BITFIELD.
//
// Time complexity: O(1) for each subcommand specified
type BitfieldRo Base

// Perform arbitrary bitfield integer operations on strings. Read-only variant of BITFIELD
//
// Command: BITFIELD_RO.
//
// Time complexity: O(1) for each subcommand specified
func (b Builder) BitfieldRo() BitfieldRo {
	c := BitfieldRo{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("BITFIELD_RO")
	return c
}

func (c BitfieldRo) Key(key string) BitfieldRoKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return BitfieldRoKey(c)
}

type BitfieldRoGet Base

func (c BitfieldRoGet) Get(encoding string, offset int64) BitfieldRoGet {
	c.command.append("GET", encoding, strconv.FormatInt(offset, 10))
	return c
}

// Return Completed Redis command.
func (c BitfieldRoGet) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BitfieldRoGet) Cache() Cacheable {
	return cacheable(c)
}

type BitfieldRoKey Base

func (c BitfieldRoKey) Get() BitfieldRoGet {
	return BitfieldRoGet(c)
}

// Perform bitwise operations between strings.
//
// Time complexity: O(N)
type Bitop Base

// Perform bitwise operations between strings
//
// Command: BITOP.
//
// Time complexity: O(N)
func (b Builder) Bitop() Bitop {
	c := Bitop{command: emptyCommand(), cslot: b.slot}
	c.command.append("BITOP")
	return c
}

func (c Bitop) Operation(operation string) BitopOperation {
	c.command.append(operation)
	return BitopOperation(c)
}

type BitopDestkey Base

func (c BitopDestkey) Key(key ...string) BitopKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return BitopKey(c)
}

type BitopKey Base

func (c BitopKey) Key(key ...string) BitopKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c BitopKey) Build() Completed {
	return completed(c)
}

type BitopOperation Base

func (c BitopOperation) Destkey(destkey string) BitopDestkey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destkey)
	} else {
		c.cslot.set(getSlot(destkey))
	}
	c.command.append(destkey)
	return BitopDestkey(c)
}

// Find first bit set or clear in a string.
//
// Time complexity: O(N)
type Bitpos Base

// Find first bit set or clear in a string
//
// Command: BITPOS.
//
// Time complexity: O(N)
func (b Builder) Bitpos() Bitpos {
	c := Bitpos{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("BITPOS")
	return c
}

func (c Bitpos) Key(key string) BitposKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return BitposKey(c)
}

type BitposBit Base

func (c BitposBit) Start(start int64) BitposIndexStart {
	c.command.append(strconv.FormatInt(start, 10))
	return BitposIndexStart(c)
}

// Return Completed Redis command.
func (c BitposBit) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BitposBit) Cache() Cacheable {
	return cacheable(c)
}

type BitposIndexEndIndexEnd Base

func (c BitposIndexEndIndexEnd) Byte() BitposIndexEndIndexIndexUnitByte {
	c.command.append("BYTE")
	return BitposIndexEndIndexIndexUnitByte(c)
}

func (c BitposIndexEndIndexEnd) Bit() BitposIndexEndIndexIndexUnitBit {
	c.command.append("BIT")
	return BitposIndexEndIndexIndexUnitBit(c)
}

// Return Completed Redis command.
func (c BitposIndexEndIndexEnd) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BitposIndexEndIndexEnd) Cache() Cacheable {
	return cacheable(c)
}

type BitposIndexEndIndexIndexUnitBit Base

// Return Completed Redis command.
func (c BitposIndexEndIndexIndexUnitBit) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BitposIndexEndIndexIndexUnitBit) Cache() Cacheable {
	return cacheable(c)
}

type BitposIndexEndIndexIndexUnitByte Base

// Return Completed Redis command.
func (c BitposIndexEndIndexIndexUnitByte) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BitposIndexEndIndexIndexUnitByte) Cache() Cacheable {
	return cacheable(c)
}

type BitposIndexStart Base

func (c BitposIndexStart) End(end int64) BitposIndexEndIndexEnd {
	c.command.append(strconv.FormatInt(end, 10))
	return BitposIndexEndIndexEnd(c)
}

// Return Completed Redis command.
func (c BitposIndexStart) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c BitposIndexStart) Cache() Cacheable {
	return cacheable(c)
}

type BitposKey Base

func (c BitposKey) Bit(bit int64) BitposBit {
	c.command.append(strconv.FormatInt(bit, 10))
	return BitposBit(c)
}

// Pop an element from a list, push it to another list and return it; or block until one is available.
//
// Time complexity: O(1)
type Blmove Base

// Pop an element from a list, push it to another list and return it; or block until one is available
//
// Command: BLMOVE.
//
// Time complexity: O(1)
func (b Builder) Blmove() Blmove {
	c := Blmove{command: emptyCommand(), cslot: b.slot, ctags: ctagBlock}
	c.command.append("BLMOVE")
	return c
}

func (c Blmove) Source(source string) BlmoveSource {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(source)
	} else {
		c.cslot.set(getSlot(source))
	}
	c.command.append(source)
	return BlmoveSource(c)
}

type BlmoveDestination Base

func (c BlmoveDestination) Left() BlmoveWherefromLeft {
	c.command.append("LEFT")
	return BlmoveWherefromLeft(c)
}

func (c BlmoveDestination) Right() BlmoveWherefromRight {
	c.command.append("RIGHT")
	return BlmoveWherefromRight(c)
}

type BlmoveSource Base

func (c BlmoveSource) Destination(destination string) BlmoveDestination {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append(destination)
	return BlmoveDestination(c)
}

type BlmoveTimeout Base

// Return Completed Redis command.
func (c BlmoveTimeout) Build() Completed {
	return completed(c)
}

type BlmoveWherefromLeft Base

func (c BlmoveWherefromLeft) Left() BlmoveWheretoLeft {
	c.command.append("LEFT")
	return BlmoveWheretoLeft(c)
}

func (c BlmoveWherefromLeft) Right() BlmoveWheretoRight {
	c.command.append("RIGHT")
	return BlmoveWheretoRight(c)
}

type BlmoveWherefromRight Base

func (c BlmoveWherefromRight) Left() BlmoveWheretoLeft {
	c.command.append("LEFT")
	return BlmoveWheretoLeft(c)
}

func (c BlmoveWherefromRight) Right() BlmoveWheretoRight {
	c.command.append("RIGHT")
	return BlmoveWheretoRight(c)
}

type BlmoveWheretoLeft Base

func (c BlmoveWheretoLeft) Timeout(timeout float64) BlmoveTimeout {
	c.command.append(strconv.FormatFloat(timeout, 'f', -1, 64))
	return BlmoveTimeout(c)
}

type BlmoveWheretoRight Base

func (c BlmoveWheretoRight) Timeout(timeout float64) BlmoveTimeout {
	c.command.append(strconv.FormatFloat(timeout, 'f', -1, 64))
	return BlmoveTimeout(c)
}

// Pop elements from a list, or block until one is available.
//
// Time complexity: O(N+M) where N is the number of provided keys and M is the number of elements returned.
type Blmpop Base

// Pop elements from a list, or block until one is available
//
// Command: BLMPOP.
//
// Time complexity: O(N+M) where N is the number of provided keys and M is the number of elements returned.
func (b Builder) Blmpop() Blmpop {
	c := Blmpop{command: emptyCommand(), cslot: b.slot, ctags: ctagBlock}
	c.command.append("BLMPOP")
	return c
}

func (c Blmpop) Timeout(timeout float64) BlmpopTimeout {
	c.command.append(strconv.FormatFloat(timeout, 'f', -1, 64))
	return BlmpopTimeout(c)
}

type BlmpopCount Base

// Return Completed Redis command.
func (c BlmpopCount) Build() Completed {
	return completed(c)
}

type BlmpopKey Base

func (c BlmpopKey) Key(key ...string) BlmpopKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c BlmpopKey) Left() BlmpopWhereLeft {
	c.command.append("LEFT")
	return BlmpopWhereLeft(c)
}

func (c BlmpopKey) Right() BlmpopWhereRight {
	c.command.append("RIGHT")
	return BlmpopWhereRight(c)
}

type BlmpopNumkeys Base

func (c BlmpopNumkeys) Key(key ...string) BlmpopKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return BlmpopKey(c)
}

type BlmpopTimeout Base

func (c BlmpopTimeout) Numkeys(numkeys int64) BlmpopNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return BlmpopNumkeys(c)
}

type BlmpopWhereLeft Base

func (c BlmpopWhereLeft) Count(count int64) BlmpopCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return BlmpopCount(c)
}

// Return Completed Redis command.
func (c BlmpopWhereLeft) Build() Completed {
	return completed(c)
}

type BlmpopWhereRight Base

func (c BlmpopWhereRight) Count(count int64) BlmpopCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return BlmpopCount(c)
}

// Return Completed Redis command.
func (c BlmpopWhereRight) Build() Completed {
	return completed(c)
}

// Remove and get the first element in a list, or block until one is available.
//
// Time complexity: O(N) where N is the number of provided keys.
type Blpop Base

// Remove and get the first element in a list, or block until one is available
//
// Command: BLPOP.
//
// Time complexity: O(N) where N is the number of provided keys.
func (b Builder) Blpop() Blpop {
	c := Blpop{command: emptyCommand(), cslot: b.slot, ctags: ctagBlock}
	c.command.append("BLPOP")
	return c
}

func (c Blpop) Key(key ...string) BlpopKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return BlpopKey(c)
}

type BlpopKey Base

func (c BlpopKey) Key(key ...string) BlpopKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c BlpopKey) Timeout(timeout float64) BlpopTimeout {
	c.command.append(strconv.FormatFloat(timeout, 'f', -1, 64))
	return BlpopTimeout(c)
}

type BlpopTimeout Base

// Return Completed Redis command.
func (c BlpopTimeout) Build() Completed {
	return completed(c)
}

// Remove and get the last element in a list, or block until one is available.
//
// Time complexity: O(N) where N is the number of provided keys.
type Brpop Base

// Remove and get the last element in a list, or block until one is available
//
// Command: BRPOP.
//
// Time complexity: O(N) where N is the number of provided keys.
func (b Builder) Brpop() Brpop {
	c := Brpop{command: emptyCommand(), cslot: b.slot, ctags: ctagBlock}
	c.command.append("BRPOP")
	return c
}

func (c Brpop) Key(key ...string) BrpopKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return BrpopKey(c)
}

type BrpopKey Base

func (c BrpopKey) Key(key ...string) BrpopKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c BrpopKey) Timeout(timeout float64) BrpopTimeout {
	c.command.append(strconv.FormatFloat(timeout, 'f', -1, 64))
	return BrpopTimeout(c)
}

type BrpopTimeout Base

// Return Completed Redis command.
func (c BrpopTimeout) Build() Completed {
	return completed(c)
}

// Pop an element from a list, push it to another list and return it; or block until one is available.
//
// Time complexity: O(1)
type Brpoplpush Base

// Pop an element from a list, push it to another list and return it; or block until one is available
//
// Command: BRPOPLPUSH.
//
// Time complexity: O(1)
func (b Builder) Brpoplpush() Brpoplpush {
	c := Brpoplpush{command: emptyCommand(), cslot: b.slot, ctags: ctagBlock}
	c.command.append("BRPOPLPUSH")
	return c
}

func (c Brpoplpush) Source(source string) BrpoplpushSource {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(source)
	} else {
		c.cslot.set(getSlot(source))
	}
	c.command.append(source)
	return BrpoplpushSource(c)
}

type BrpoplpushDestination Base

func (c BrpoplpushDestination) Timeout(timeout float64) BrpoplpushTimeout {
	c.command.append(strconv.FormatFloat(timeout, 'f', -1, 64))
	return BrpoplpushTimeout(c)
}

type BrpoplpushSource Base

func (c BrpoplpushSource) Destination(destination string) BrpoplpushDestination {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append(destination)
	return BrpoplpushDestination(c)
}

type BrpoplpushTimeout Base

// Return Completed Redis command.
func (c BrpoplpushTimeout) Build() Completed {
	return completed(c)
}

// Remove and return members with scores in a sorted set or block until one is available.
//
// Time complexity: O(K) + O(N*log(M)) where K is the number of provided keys, N being the number of elements in the sorted set, and M being the number of elements popped.
type Bzmpop Base

// Remove and return members with scores in a sorted set or block until one is available
//
// Command: BZMPOP.
//
// Time complexity: O(K) + O(N*log(M)) where K is the number of provided keys, N being the number of elements in the sorted set, and M being the number of elements popped.
func (b Builder) Bzmpop() Bzmpop {
	c := Bzmpop{command: emptyCommand(), cslot: b.slot, ctags: ctagBlock}
	c.command.append("BZMPOP")
	return c
}

func (c Bzmpop) Timeout(timeout float64) BzmpopTimeout {
	c.command.append(strconv.FormatFloat(timeout, 'f', -1, 64))
	return BzmpopTimeout(c)
}

type BzmpopCount Base

// Return Completed Redis command.
func (c BzmpopCount) Build() Completed {
	return completed(c)
}

type BzmpopKey Base

func (c BzmpopKey) Key(key ...string) BzmpopKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c BzmpopKey) Min() BzmpopWhereMin {
	c.command.append("MIN")
	return BzmpopWhereMin(c)
}

func (c BzmpopKey) Max() BzmpopWhereMax {
	c.command.append("MAX")
	return BzmpopWhereMax(c)
}

type BzmpopNumkeys Base

func (c BzmpopNumkeys) Key(key ...string) BzmpopKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return BzmpopKey(c)
}

type BzmpopTimeout Base

func (c BzmpopTimeout) Numkeys(numkeys int64) BzmpopNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return BzmpopNumkeys(c)
}

type BzmpopWhereMax Base

func (c BzmpopWhereMax) Count(count int64) BzmpopCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return BzmpopCount(c)
}

// Return Completed Redis command.
func (c BzmpopWhereMax) Build() Completed {
	return completed(c)
}

type BzmpopWhereMin Base

func (c BzmpopWhereMin) Count(count int64) BzmpopCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return BzmpopCount(c)
}

// Return Completed Redis command.
func (c BzmpopWhereMin) Build() Completed {
	return completed(c)
}

// Remove and return the member with the highest score from one or more sorted sets, or block until one is available.
//
// Time complexity: O(log(N)) with N being the number of elements in the sorted set.
type Bzpopmax Base

// Remove and return the member with the highest score from one or more sorted sets, or block until one is available
//
// Command: BZPOPMAX.
//
// Time complexity: O(log(N)) with N being the number of elements in the sorted set.
func (b Builder) Bzpopmax() Bzpopmax {
	c := Bzpopmax{command: emptyCommand(), cslot: b.slot, ctags: ctagBlock}
	c.command.append("BZPOPMAX")
	return c
}

func (c Bzpopmax) Key(key ...string) BzpopmaxKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return BzpopmaxKey(c)
}

type BzpopmaxKey Base

func (c BzpopmaxKey) Key(key ...string) BzpopmaxKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c BzpopmaxKey) Timeout(timeout float64) BzpopmaxTimeout {
	c.command.append(strconv.FormatFloat(timeout, 'f', -1, 64))
	return BzpopmaxTimeout(c)
}

type BzpopmaxTimeout Base

// Return Completed Redis command.
func (c BzpopmaxTimeout) Build() Completed {
	return completed(c)
}

// Remove and return the member with the lowest score from one or more sorted sets, or block until one is available.
//
// Time complexity: O(log(N)) with N being the number of elements in the sorted set.
type Bzpopmin Base

// Remove and return the member with the lowest score from one or more sorted sets, or block until one is available
//
// Command: BZPOPMIN.
//
// Time complexity: O(log(N)) with N being the number of elements in the sorted set.
func (b Builder) Bzpopmin() Bzpopmin {
	c := Bzpopmin{command: emptyCommand(), cslot: b.slot, ctags: ctagBlock}
	c.command.append("BZPOPMIN")
	return c
}

func (c Bzpopmin) Key(key ...string) BzpopminKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return BzpopminKey(c)
}

type BzpopminKey Base

func (c BzpopminKey) Key(key ...string) BzpopminKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c BzpopminKey) Timeout(timeout float64) BzpopminTimeout {
	c.command.append(strconv.FormatFloat(timeout, 'f', -1, 64))
	return BzpopminTimeout(c)
}

type BzpopminTimeout Base

// Return Completed Redis command.
func (c BzpopminTimeout) Build() Completed {
	return completed(c)
}

// Adds an item to a Cuckoo Filter.
//
// Time complexity: O(k + i), where k is the number of sub-filters and i is maxIterations
type CfAdd Base

// Adds an item to a Cuckoo Filter
//
// Command: CF.ADD.
//
// Time complexity: O(k + i), where k is the number of sub-filters and i is maxIterations
func (b Builder) CfAdd() CfAdd {
	c := CfAdd{command: emptyCommand(), cslot: b.slot}
	c.command.append("CF.ADD")
	return c
}

func (c CfAdd) Key(key string) CfAddKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CfAddKey(c)
}

type CfAddItem Base

// Return Completed Redis command.
func (c CfAddItem) Build() Completed {
	return completed(c)
}

type CfAddKey Base

func (c CfAddKey) Item(item string) CfAddItem {
	c.command.append(item)
	return CfAddItem(c)
}

// Adds an item to a Cuckoo Filter if the item did not exist previously..
//
// Time complexity: O(k + i), where k is the number of sub-filters and i is maxIterations
type CfAddnx Base

// Adds an item to a Cuckoo Filter if the item did not exist previously.
//
// Command: CF.ADDNX.
//
// Time complexity: O(k + i), where k is the number of sub-filters and i is maxIterations
func (b Builder) CfAddnx() CfAddnx {
	c := CfAddnx{command: emptyCommand(), cslot: b.slot}
	c.command.append("CF.ADDNX")
	return c
}

func (c CfAddnx) Key(key string) CfAddnxKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CfAddnxKey(c)
}

type CfAddnxItem Base

// Return Completed Redis command.
func (c CfAddnxItem) Build() Completed {
	return completed(c)
}

type CfAddnxKey Base

func (c CfAddnxKey) Item(item string) CfAddnxItem {
	c.command.append(item)
	return CfAddnxItem(c)
}

// Return the number of times an item might be in a Cuckoo Filter.
//
// Time complexity: O(k), where k is the number of sub-filters
type CfCount Base

// Return the number of times an item might be in a Cuckoo Filter
//
// Command: CF.COUNT.
//
// Time complexity: O(k), where k is the number of sub-filters
func (b Builder) CfCount() CfCount {
	c := CfCount{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("CF.COUNT")
	return c
}

func (c CfCount) Key(key string) CfCountKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CfCountKey(c)
}

type CfCountItem Base

// Return Completed Redis command.
func (c CfCountItem) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c CfCountItem) Cache() Cacheable {
	return cacheable(c)
}

type CfCountKey Base

func (c CfCountKey) Item(item string) CfCountItem {
	c.command.append(item)
	return CfCountItem(c)
}

// Deletes an item from a Cuckoo Filter.
//
// Time complexity: O(k), where k is the number of sub-filters
type CfDel Base

// Deletes an item from a Cuckoo Filter
//
// Command: CF.DEL.
//
// Time complexity: O(k), where k is the number of sub-filters
func (b Builder) CfDel() CfDel {
	c := CfDel{command: emptyCommand(), cslot: b.slot}
	c.command.append("CF.DEL")
	return c
}

func (c CfDel) Key(key string) CfDelKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CfDelKey(c)
}

type CfDelItem Base

// Return Completed Redis command.
func (c CfDelItem) Build() Completed {
	return completed(c)
}

type CfDelKey Base

func (c CfDelKey) Item(item string) CfDelItem {
	c.command.append(item)
	return CfDelItem(c)
}

// Checks whether one or more items exist in a Cuckoo Filter.
//
// Time complexity: O(k), where k is the number of sub-filters
type CfExists Base

// Checks whether one or more items exist in a Cuckoo Filter
//
// Command: CF.EXISTS.
//
// Time complexity: O(k), where k is the number of sub-filters
func (b Builder) CfExists() CfExists {
	c := CfExists{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("CF.EXISTS")
	return c
}

func (c CfExists) Key(key string) CfExistsKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CfExistsKey(c)
}

type CfExistsItem Base

// Return Completed Redis command.
func (c CfExistsItem) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c CfExistsItem) Cache() Cacheable {
	return cacheable(c)
}

type CfExistsKey Base

func (c CfExistsKey) Item(item string) CfExistsItem {
	c.command.append(item)
	return CfExistsItem(c)
}

// Returns information about a Cuckoo Filter.
//
// Time complexity: O(1)
type CfInfo Base

// Returns information about a Cuckoo Filter
//
// Command: CF.INFO.
//
// Time complexity: O(1)
func (b Builder) CfInfo() CfInfo {
	c := CfInfo{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("CF.INFO")
	return c
}

func (c CfInfo) Key(key string) CfInfoKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CfInfoKey(c)
}

type CfInfoKey Base

// Return Completed Redis command.
func (c CfInfoKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c CfInfoKey) Cache() Cacheable {
	return cacheable(c)
}

// Adds one or more items to a Cuckoo Filter. A filter will be created if it does not exist.
//
// Time complexity: O(n * (k + i)), where n is the number of items, k is the number of sub-filters and i is maxIterations
type CfInsert Base

// Adds one or more items to a Cuckoo Filter. A filter will be created if it does not exist
//
// Command: CF.INSERT.
//
// Time complexity: O(n * (k + i)), where n is the number of items, k is the number of sub-filters and i is maxIterations
func (b Builder) CfInsert() CfInsert {
	c := CfInsert{command: emptyCommand(), cslot: b.slot}
	c.command.append("CF.INSERT")
	return c
}

func (c CfInsert) Key(key string) CfInsertKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CfInsertKey(c)
}

type CfInsertCapacity Base

func (c CfInsertCapacity) Nocreate() CfInsertNocreate {
	c.command.append("NOCREATE")
	return CfInsertNocreate(c)
}

func (c CfInsertCapacity) Items() CfInsertItems {
	c.command.append("ITEMS")
	return CfInsertItems(c)
}

type CfInsertItem Base

func (c CfInsertItem) Item(item ...string) CfInsertItem {
	c.command.append(item...)
	return c
}

// Return Completed Redis command.
func (c CfInsertItem) Build() Completed {
	return completed(c)
}

type CfInsertItems Base

func (c CfInsertItems) Item(item ...string) CfInsertItem {
	c.command.append(item...)
	return CfInsertItem(c)
}

type CfInsertKey Base

func (c CfInsertKey) Capacity(capacity int64) CfInsertCapacity {
	c.command.append("CAPACITY", strconv.FormatInt(capacity, 10))
	return CfInsertCapacity(c)
}

func (c CfInsertKey) Nocreate() CfInsertNocreate {
	c.command.append("NOCREATE")
	return CfInsertNocreate(c)
}

func (c CfInsertKey) Items() CfInsertItems {
	c.command.append("ITEMS")
	return CfInsertItems(c)
}

type CfInsertNocreate Base

func (c CfInsertNocreate) Items() CfInsertItems {
	c.command.append("ITEMS")
	return CfInsertItems(c)
}

// Adds one or more items to a Cuckoo Filter if the items did not exist previously. A filter will be created if it does not exist.
//
// Time complexity: O(n * (k + i)), where n is the number of items, k is the number of sub-filters and i is maxIterations
type CfInsertnx Base

// Adds one or more items to a Cuckoo Filter if the items did not exist previously. A filter will be created if it does not exist
//
// Command: CF.INSERTNX.
//
// Time complexity: O(n * (k + i)), where n is the number of items, k is the number of sub-filters and i is maxIterations
func (b Builder) CfInsertnx() CfInsertnx {
	c := CfInsertnx{command: emptyCommand(), cslot: b.slot}
	c.command.append("CF.INSERTNX")
	return c
}

func (c CfInsertnx) Key(key string) CfInsertnxKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CfInsertnxKey(c)
}

type CfInsertnxCapacity Base

func (c CfInsertnxCapacity) Nocreate() CfInsertnxNocreate {
	c.command.append("NOCREATE")
	return CfInsertnxNocreate(c)
}

func (c CfInsertnxCapacity) Items() CfInsertnxItems {
	c.command.append("ITEMS")
	return CfInsertnxItems(c)
}

type CfInsertnxItem Base

func (c CfInsertnxItem) Item(item ...string) CfInsertnxItem {
	c.command.append(item...)
	return c
}

// Return Completed Redis command.
func (c CfInsertnxItem) Build() Completed {
	return completed(c)
}

type CfInsertnxItems Base

func (c CfInsertnxItems) Item(item ...string) CfInsertnxItem {
	c.command.append(item...)
	return CfInsertnxItem(c)
}

type CfInsertnxKey Base

func (c CfInsertnxKey) Capacity(capacity int64) CfInsertnxCapacity {
	c.command.append("CAPACITY", strconv.FormatInt(capacity, 10))
	return CfInsertnxCapacity(c)
}

func (c CfInsertnxKey) Nocreate() CfInsertnxNocreate {
	c.command.append("NOCREATE")
	return CfInsertnxNocreate(c)
}

func (c CfInsertnxKey) Items() CfInsertnxItems {
	c.command.append("ITEMS")
	return CfInsertnxItems(c)
}

type CfInsertnxNocreate Base

func (c CfInsertnxNocreate) Items() CfInsertnxItems {
	c.command.append("ITEMS")
	return CfInsertnxItems(c)
}

// Restores a filter previously saved using SCANDUMP.
//
// Time complexity: O(n), where n is the capacity
type CfLoadchunk Base

// Restores a filter previously saved using SCANDUMP
//
// Command: CF.LOADCHUNK.
//
// Time complexity: O(n), where n is the capacity
func (b Builder) CfLoadchunk() CfLoadchunk {
	c := CfLoadchunk{command: emptyCommand(), cslot: b.slot}
	c.command.append("CF.LOADCHUNK")
	return c
}

func (c CfLoadchunk) Key(key string) CfLoadchunkKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CfLoadchunkKey(c)
}

type CfLoadchunkData Base

// Return Completed Redis command.
func (c CfLoadchunkData) Build() Completed {
	return completed(c)
}

type CfLoadchunkIterator Base

func (c CfLoadchunkIterator) Data(data string) CfLoadchunkData {
	c.command.append(data)
	return CfLoadchunkData(c)
}

type CfLoadchunkKey Base

func (c CfLoadchunkKey) Iterator(iterator int64) CfLoadchunkIterator {
	c.command.append(strconv.FormatInt(iterator, 10))
	return CfLoadchunkIterator(c)
}

// Checks whether one or more items exist in a Cuckoo Filter.
//
// Time complexity: O(k * n), where k is the number of sub-filters and n is the number of items
type CfMexists Base

// Checks whether one or more items exist in a Cuckoo Filter
//
// Command: CF.MEXISTS.
//
// Time complexity: O(k * n), where k is the number of sub-filters and n is the number of items
func (b Builder) CfMexists() CfMexists {
	c := CfMexists{command: emptyCommand(), cslot: b.slot}
	c.command.append("CF.MEXISTS")
	return c
}

func (c CfMexists) Key(key string) CfMexistsKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CfMexistsKey(c)
}

type CfMexistsItem Base

func (c CfMexistsItem) Item(item ...string) CfMexistsItem {
	c.command.append(item...)
	return c
}

// Return Completed Redis command.
func (c CfMexistsItem) Build() Completed {
	return completed(c)
}

type CfMexistsKey Base

func (c CfMexistsKey) Item(item ...string) CfMexistsItem {
	c.command.append(item...)
	return CfMexistsItem(c)
}

// Creates a new Cuckoo Filter.
//
// Time complexity: O(1)
type CfReserve Base

// Creates a new Cuckoo Filter
//
// Command: CF.RESERVE.
//
// Time complexity: O(1)
func (b Builder) CfReserve() CfReserve {
	c := CfReserve{command: emptyCommand(), cslot: b.slot}
	c.command.append("CF.RESERVE")
	return c
}

func (c CfReserve) Key(key string) CfReserveKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CfReserveKey(c)
}

type CfReserveBucketsize Base

func (c CfReserveBucketsize) Maxiterations(maxiterations int64) CfReserveMaxiterations {
	c.command.append("MAXITERATIONS", strconv.FormatInt(maxiterations, 10))
	return CfReserveMaxiterations(c)
}

func (c CfReserveBucketsize) Expansion(expansion int64) CfReserveExpansion {
	c.command.append("EXPANSION", strconv.FormatInt(expansion, 10))
	return CfReserveExpansion(c)
}

// Return Completed Redis command.
func (c CfReserveBucketsize) Build() Completed {
	return completed(c)
}

type CfReserveCapacity Base

func (c CfReserveCapacity) Bucketsize(bucketsize int64) CfReserveBucketsize {
	c.command.append("BUCKETSIZE", strconv.FormatInt(bucketsize, 10))
	return CfReserveBucketsize(c)
}

func (c CfReserveCapacity) Maxiterations(maxiterations int64) CfReserveMaxiterations {
	c.command.append("MAXITERATIONS", strconv.FormatInt(maxiterations, 10))
	return CfReserveMaxiterations(c)
}

func (c CfReserveCapacity) Expansion(expansion int64) CfReserveExpansion {
	c.command.append("EXPANSION", strconv.FormatInt(expansion, 10))
	return CfReserveExpansion(c)
}

// Return Completed Redis command.
func (c CfReserveCapacity) Build() Completed {
	return completed(c)
}

type CfReserveExpansion Base

// Return Completed Redis command.
func (c CfReserveExpansion) Build() Completed {
	return completed(c)
}

type CfReserveKey Base

func (c CfReserveKey) Capacity(capacity int64) CfReserveCapacity {
	c.command.append(strconv.FormatInt(capacity, 10))
	return CfReserveCapacity(c)
}

type CfReserveMaxiterations Base

func (c CfReserveMaxiterations) Expansion(expansion int64) CfReserveExpansion {
	c.command.append("EXPANSION", strconv.FormatInt(expansion, 10))
	return CfReserveExpansion(c)
}

// Return Completed Redis command.
func (c CfReserveMaxiterations) Build() Completed {
	return completed(c)
}

// Begins an incremental save of the bloom filter.
//
// Time complexity: O(n), where n is the capacity
type CfScandump Base

// Begins an incremental save of the bloom filter
//
// Command: CF.SCANDUMP.
//
// Time complexity: O(n), where n is the capacity
func (b Builder) CfScandump() CfScandump {
	c := CfScandump{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("CF.SCANDUMP")
	return c
}

func (c CfScandump) Key(key string) CfScandumpKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CfScandumpKey(c)
}

type CfScandumpIterator Base

// Return Completed Redis command.
func (c CfScandumpIterator) Build() Completed {
	return completed(c)
}

type CfScandumpKey Base

func (c CfScandumpKey) Iterator(iterator int64) CfScandumpIterator {
	c.command.append(strconv.FormatInt(iterator, 10))
	return CfScandumpIterator(c)
}

// Instruct the server about tracking or not keys in the next request.
//
// Time complexity: O(1)
type ClientCaching Base

// Instruct the server about tracking or not keys in the next request
//
// Command: CLIENT CACHING.
//
// Time complexity: O(1)
func (b Builder) ClientCaching() ClientCaching {
	c := ClientCaching{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLIENT", "CACHING")
	return c
}

func (c ClientCaching) Yes() ClientCachingModeYes {
	c.command.append("YES")
	return ClientCachingModeYes(c)
}

func (c ClientCaching) No() ClientCachingModeNo {
	c.command.append("NO")
	return ClientCachingModeNo(c)
}

type ClientCachingModeNo Base

// Return Completed Redis command.
func (c ClientCachingModeNo) Build() Completed {
	return completed(c)
}

type ClientCachingModeYes Base

// Return Completed Redis command.
func (c ClientCachingModeYes) Build() Completed {
	return completed(c)
}

// Get the current connection name.
//
// Time complexity: O(1)
type ClientGetname Base

// Get the current connection name
//
// Command: CLIENT GETNAME.
//
// Time complexity: O(1)
func (b Builder) ClientGetname() ClientGetname {
	c := ClientGetname{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLIENT", "GETNAME")
	return c
}

// Return Completed Redis command.
func (c ClientGetname) Build() Completed {
	return completed(c)
}

// Get tracking notifications redirection client ID if any.
//
// Time complexity: O(1)
type ClientGetredir Base

// Get tracking notifications redirection client ID if any
//
// Command: CLIENT GETREDIR.
//
// Time complexity: O(1)
func (b Builder) ClientGetredir() ClientGetredir {
	c := ClientGetredir{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLIENT", "GETREDIR")
	return c
}

// Return Completed Redis command.
func (c ClientGetredir) Build() Completed {
	return completed(c)
}

// Returns the client ID for the current connection.
//
// Time complexity: O(1)
type ClientId Base

// Returns the client ID for the current connection
//
// Command: CLIENT ID.
//
// Time complexity: O(1)
func (b Builder) ClientId() ClientId {
	c := ClientId{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLIENT", "ID")
	return c
}

// Return Completed Redis command.
func (c ClientId) Build() Completed {
	return completed(c)
}

// Returns information about the current client connection..
//
// Time complexity: O(1)
type ClientInfo Base

// Returns information about the current client connection.
//
// Command: CLIENT INFO.
//
// Time complexity: O(1)
func (b Builder) ClientInfo() ClientInfo {
	c := ClientInfo{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLIENT", "INFO")
	return c
}

// Return Completed Redis command.
func (c ClientInfo) Build() Completed {
	return completed(c)
}

// Kill the connection of a client.
//
// Time complexity: O(N) where N is the number of client connections
type ClientKill Base

// Kill the connection of a client
//
// Command: CLIENT KILL.
//
// Time complexity: O(N) where N is the number of client connections
func (b Builder) ClientKill() ClientKill {
	c := ClientKill{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLIENT", "KILL")
	return c
}

func (c ClientKill) IpPort(ipPort string) ClientKillIpPort {
	c.command.append(ipPort)
	return ClientKillIpPort(c)
}

func (c ClientKill) Id(clientId int64) ClientKillId {
	c.command.append("ID", strconv.FormatInt(clientId, 10))
	return ClientKillId(c)
}

func (c ClientKill) TypeNormal() ClientKillTypeNormal {
	c.command.append("TYPE", "NORMAL")
	return ClientKillTypeNormal(c)
}

func (c ClientKill) TypeMaster() ClientKillTypeMaster {
	c.command.append("TYPE", "MASTER")
	return ClientKillTypeMaster(c)
}

func (c ClientKill) TypeReplica() ClientKillTypeReplica {
	c.command.append("TYPE", "REPLICA")
	return ClientKillTypeReplica(c)
}

func (c ClientKill) TypePubsub() ClientKillTypePubsub {
	c.command.append("TYPE", "PUBSUB")
	return ClientKillTypePubsub(c)
}

func (c ClientKill) User(username string) ClientKillUser {
	c.command.append("USER", username)
	return ClientKillUser(c)
}

func (c ClientKill) Addr(ipPort string) ClientKillAddr {
	c.command.append("ADDR", ipPort)
	return ClientKillAddr(c)
}

func (c ClientKill) Laddr(ipPort string) ClientKillLaddr {
	c.command.append("LADDR", ipPort)
	return ClientKillLaddr(c)
}

func (c ClientKill) Skipme(yesNo string) ClientKillSkipme {
	c.command.append("SKIPME", yesNo)
	return ClientKillSkipme(c)
}

// Return Completed Redis command.
func (c ClientKill) Build() Completed {
	return completed(c)
}

type ClientKillAddr Base

func (c ClientKillAddr) Laddr(ipPort string) ClientKillLaddr {
	c.command.append("LADDR", ipPort)
	return ClientKillLaddr(c)
}

func (c ClientKillAddr) Skipme(yesNo string) ClientKillSkipme {
	c.command.append("SKIPME", yesNo)
	return ClientKillSkipme(c)
}

// Return Completed Redis command.
func (c ClientKillAddr) Build() Completed {
	return completed(c)
}

type ClientKillId Base

func (c ClientKillId) TypeNormal() ClientKillTypeNormal {
	c.command.append("TYPE", "NORMAL")
	return ClientKillTypeNormal(c)
}

func (c ClientKillId) TypeMaster() ClientKillTypeMaster {
	c.command.append("TYPE", "MASTER")
	return ClientKillTypeMaster(c)
}

func (c ClientKillId) TypeReplica() ClientKillTypeReplica {
	c.command.append("TYPE", "REPLICA")
	return ClientKillTypeReplica(c)
}

func (c ClientKillId) TypePubsub() ClientKillTypePubsub {
	c.command.append("TYPE", "PUBSUB")
	return ClientKillTypePubsub(c)
}

func (c ClientKillId) User(username string) ClientKillUser {
	c.command.append("USER", username)
	return ClientKillUser(c)
}

func (c ClientKillId) Addr(ipPort string) ClientKillAddr {
	c.command.append("ADDR", ipPort)
	return ClientKillAddr(c)
}

func (c ClientKillId) Laddr(ipPort string) ClientKillLaddr {
	c.command.append("LADDR", ipPort)
	return ClientKillLaddr(c)
}

func (c ClientKillId) Skipme(yesNo string) ClientKillSkipme {
	c.command.append("SKIPME", yesNo)
	return ClientKillSkipme(c)
}

// Return Completed Redis command.
func (c ClientKillId) Build() Completed {
	return completed(c)
}

type ClientKillIpPort Base

func (c ClientKillIpPort) Id(clientId int64) ClientKillId {
	c.command.append("ID", strconv.FormatInt(clientId, 10))
	return ClientKillId(c)
}

func (c ClientKillIpPort) TypeNormal() ClientKillTypeNormal {
	c.command.append("TYPE", "NORMAL")
	return ClientKillTypeNormal(c)
}

func (c ClientKillIpPort) TypeMaster() ClientKillTypeMaster {
	c.command.append("TYPE", "MASTER")
	return ClientKillTypeMaster(c)
}

func (c ClientKillIpPort) TypeReplica() ClientKillTypeReplica {
	c.command.append("TYPE", "REPLICA")
	return ClientKillTypeReplica(c)
}

func (c ClientKillIpPort) TypePubsub() ClientKillTypePubsub {
	c.command.append("TYPE", "PUBSUB")
	return ClientKillTypePubsub(c)
}

func (c ClientKillIpPort) User(username string) ClientKillUser {
	c.command.append("USER", username)
	return ClientKillUser(c)
}

func (c ClientKillIpPort) Addr(ipPort string) ClientKillAddr {
	c.command.append("ADDR", ipPort)
	return ClientKillAddr(c)
}

func (c ClientKillIpPort) Laddr(ipPort string) ClientKillLaddr {
	c.command.append("LADDR", ipPort)
	return ClientKillLaddr(c)
}

func (c ClientKillIpPort) Skipme(yesNo string) ClientKillSkipme {
	c.command.append("SKIPME", yesNo)
	return ClientKillSkipme(c)
}

// Return Completed Redis command.
func (c ClientKillIpPort) Build() Completed {
	return completed(c)
}

type ClientKillLaddr Base

func (c ClientKillLaddr) Skipme(yesNo string) ClientKillSkipme {
	c.command.append("SKIPME", yesNo)
	return ClientKillSkipme(c)
}

// Return Completed Redis command.
func (c ClientKillLaddr) Build() Completed {
	return completed(c)
}

type ClientKillSkipme Base

// Return Completed Redis command.
func (c ClientKillSkipme) Build() Completed {
	return completed(c)
}

type ClientKillTypeMaster Base

func (c ClientKillTypeMaster) User(username string) ClientKillUser {
	c.command.append("USER", username)
	return ClientKillUser(c)
}

func (c ClientKillTypeMaster) Addr(ipPort string) ClientKillAddr {
	c.command.append("ADDR", ipPort)
	return ClientKillAddr(c)
}

func (c ClientKillTypeMaster) Laddr(ipPort string) ClientKillLaddr {
	c.command.append("LADDR", ipPort)
	return ClientKillLaddr(c)
}

func (c ClientKillTypeMaster) Skipme(yesNo string) ClientKillSkipme {
	c.command.append("SKIPME", yesNo)
	return ClientKillSkipme(c)
}

// Return Completed Redis command.
func (c ClientKillTypeMaster) Build() Completed {
	return completed(c)
}

type ClientKillTypeNormal Base

func (c ClientKillTypeNormal) User(username string) ClientKillUser {
	c.command.append("USER", username)
	return ClientKillUser(c)
}

func (c ClientKillTypeNormal) Addr(ipPort string) ClientKillAddr {
	c.command.append("ADDR", ipPort)
	return ClientKillAddr(c)
}

func (c ClientKillTypeNormal) Laddr(ipPort string) ClientKillLaddr {
	c.command.append("LADDR", ipPort)
	return ClientKillLaddr(c)
}

func (c ClientKillTypeNormal) Skipme(yesNo string) ClientKillSkipme {
	c.command.append("SKIPME", yesNo)
	return ClientKillSkipme(c)
}

// Return Completed Redis command.
func (c ClientKillTypeNormal) Build() Completed {
	return completed(c)
}

type ClientKillTypePubsub Base

func (c ClientKillTypePubsub) User(username string) ClientKillUser {
	c.command.append("USER", username)
	return ClientKillUser(c)
}

func (c ClientKillTypePubsub) Addr(ipPort string) ClientKillAddr {
	c.command.append("ADDR", ipPort)
	return ClientKillAddr(c)
}

func (c ClientKillTypePubsub) Laddr(ipPort string) ClientKillLaddr {
	c.command.append("LADDR", ipPort)
	return ClientKillLaddr(c)
}

func (c ClientKillTypePubsub) Skipme(yesNo string) ClientKillSkipme {
	c.command.append("SKIPME", yesNo)
	return ClientKillSkipme(c)
}

// Return Completed Redis command.
func (c ClientKillTypePubsub) Build() Completed {
	return completed(c)
}

type ClientKillTypeReplica Base

func (c ClientKillTypeReplica) User(username string) ClientKillUser {
	c.command.append("USER", username)
	return ClientKillUser(c)
}

func (c ClientKillTypeReplica) Addr(ipPort string) ClientKillAddr {
	c.command.append("ADDR", ipPort)
	return ClientKillAddr(c)
}

func (c ClientKillTypeReplica) Laddr(ipPort string) ClientKillLaddr {
	c.command.append("LADDR", ipPort)
	return ClientKillLaddr(c)
}

func (c ClientKillTypeReplica) Skipme(yesNo string) ClientKillSkipme {
	c.command.append("SKIPME", yesNo)
	return ClientKillSkipme(c)
}

// Return Completed Redis command.
func (c ClientKillTypeReplica) Build() Completed {
	return completed(c)
}

type ClientKillUser Base

func (c ClientKillUser) Addr(ipPort string) ClientKillAddr {
	c.command.append("ADDR", ipPort)
	return ClientKillAddr(c)
}

func (c ClientKillUser) Laddr(ipPort string) ClientKillLaddr {
	c.command.append("LADDR", ipPort)
	return ClientKillLaddr(c)
}

func (c ClientKillUser) Skipme(yesNo string) ClientKillSkipme {
	c.command.append("SKIPME", yesNo)
	return ClientKillSkipme(c)
}

// Return Completed Redis command.
func (c ClientKillUser) Build() Completed {
	return completed(c)
}

// Get the list of client connections.
//
// Time complexity: O(N) where N is the number of client connections
type ClientList Base

// Get the list of client connections
//
// Command: CLIENT LIST.
//
// Time complexity: O(N) where N is the number of client connections
func (b Builder) ClientList() ClientList {
	c := ClientList{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLIENT", "LIST")
	return c
}

func (c ClientList) TypeNormal() ClientListTypeNormal {
	c.command.append("TYPE", "NORMAL")
	return ClientListTypeNormal(c)
}

func (c ClientList) TypeMaster() ClientListTypeMaster {
	c.command.append("TYPE", "MASTER")
	return ClientListTypeMaster(c)
}

func (c ClientList) TypeReplica() ClientListTypeReplica {
	c.command.append("TYPE", "REPLICA")
	return ClientListTypeReplica(c)
}

func (c ClientList) TypePubsub() ClientListTypePubsub {
	c.command.append("TYPE", "PUBSUB")
	return ClientListTypePubsub(c)
}

func (c ClientList) Id() ClientListIdId {
	c.command.append("ID")
	return ClientListIdId(c)
}

// Return Completed Redis command.
func (c ClientList) Build() Completed {
	return completed(c)
}

type ClientListIdClientId Base

func (c ClientListIdClientId) ClientId(clientId ...int64) ClientListIdClientId {
	for _, n := range clientId {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return c
}

// Return Completed Redis command.
func (c ClientListIdClientId) Build() Completed {
	return completed(c)
}

type ClientListIdId Base

func (c ClientListIdId) ClientId(clientId ...int64) ClientListIdClientId {
	for _, n := range clientId {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return ClientListIdClientId(c)
}

type ClientListTypeMaster Base

func (c ClientListTypeMaster) Id() ClientListIdId {
	c.command.append("ID")
	return ClientListIdId(c)
}

// Return Completed Redis command.
func (c ClientListTypeMaster) Build() Completed {
	return completed(c)
}

type ClientListTypeNormal Base

func (c ClientListTypeNormal) Id() ClientListIdId {
	c.command.append("ID")
	return ClientListIdId(c)
}

// Return Completed Redis command.
func (c ClientListTypeNormal) Build() Completed {
	return completed(c)
}

type ClientListTypePubsub Base

func (c ClientListTypePubsub) Id() ClientListIdId {
	c.command.append("ID")
	return ClientListIdId(c)
}

// Return Completed Redis command.
func (c ClientListTypePubsub) Build() Completed {
	return completed(c)
}

type ClientListTypeReplica Base

func (c ClientListTypeReplica) Id() ClientListIdId {
	c.command.append("ID")
	return ClientListIdId(c)
}

// Return Completed Redis command.
func (c ClientListTypeReplica) Build() Completed {
	return completed(c)
}

// Set client eviction mode for the current connection.
//
// Time complexity: O(1)
type ClientNoEvict Base

// Set client eviction mode for the current connection
//
// Command: CLIENT NO-EVICT.
//
// Time complexity: O(1)
func (b Builder) ClientNoEvict() ClientNoEvict {
	c := ClientNoEvict{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLIENT", "NO-EVICT")
	return c
}

func (c ClientNoEvict) On() ClientNoEvictEnabledOn {
	c.command.append("ON")
	return ClientNoEvictEnabledOn(c)
}

func (c ClientNoEvict) Off() ClientNoEvictEnabledOff {
	c.command.append("OFF")
	return ClientNoEvictEnabledOff(c)
}

type ClientNoEvictEnabledOff Base

// Return Completed Redis command.
func (c ClientNoEvictEnabledOff) Build() Completed {
	return completed(c)
}

type ClientNoEvictEnabledOn Base

// Return Completed Redis command.
func (c ClientNoEvictEnabledOn) Build() Completed {
	return completed(c)
}

// Stop processing commands from clients for some time.
//
// Time complexity: O(1)
type ClientPause Base

// Stop processing commands from clients for some time
//
// Command: CLIENT PAUSE.
//
// Time complexity: O(1)
func (b Builder) ClientPause() ClientPause {
	c := ClientPause{command: emptyCommand(), cslot: b.slot, ctags: ctagBlock}
	c.command.append("CLIENT", "PAUSE")
	return c
}

func (c ClientPause) Timeout(timeout int64) ClientPauseTimeout {
	c.command.append(strconv.FormatInt(timeout, 10))
	return ClientPauseTimeout(c)
}

type ClientPauseModeAll Base

// Return Completed Redis command.
func (c ClientPauseModeAll) Build() Completed {
	return completed(c)
}

type ClientPauseModeWrite Base

// Return Completed Redis command.
func (c ClientPauseModeWrite) Build() Completed {
	return completed(c)
}

type ClientPauseTimeout Base

func (c ClientPauseTimeout) Write() ClientPauseModeWrite {
	c.command.append("WRITE")
	return ClientPauseModeWrite(c)
}

func (c ClientPauseTimeout) All() ClientPauseModeAll {
	c.command.append("ALL")
	return ClientPauseModeAll(c)
}

// Return Completed Redis command.
func (c ClientPauseTimeout) Build() Completed {
	return completed(c)
}

// Instruct the server whether to reply to commands.
//
// Time complexity: O(1)
type ClientReply Base

// Instruct the server whether to reply to commands
//
// Command: CLIENT REPLY.
//
// Time complexity: O(1)
func (b Builder) ClientReply() ClientReply {
	c := ClientReply{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLIENT", "REPLY")
	return c
}

func (c ClientReply) On() ClientReplyReplyModeOn {
	c.command.append("ON")
	return ClientReplyReplyModeOn(c)
}

func (c ClientReply) Off() ClientReplyReplyModeOff {
	c.command.append("OFF")
	return ClientReplyReplyModeOff(c)
}

func (c ClientReply) Skip() ClientReplyReplyModeSkip {
	c.command.append("SKIP")
	return ClientReplyReplyModeSkip(c)
}

type ClientReplyReplyModeOff Base

// Return Completed Redis command.
func (c ClientReplyReplyModeOff) Build() Completed {
	return completed(c)
}

type ClientReplyReplyModeOn Base

// Return Completed Redis command.
func (c ClientReplyReplyModeOn) Build() Completed {
	return completed(c)
}

type ClientReplyReplyModeSkip Base

// Return Completed Redis command.
func (c ClientReplyReplyModeSkip) Build() Completed {
	return completed(c)
}

// Set the current connection name.
//
// Time complexity: O(1)
type ClientSetname Base

// Set the current connection name
//
// Command: CLIENT SETNAME.
//
// Time complexity: O(1)
func (b Builder) ClientSetname() ClientSetname {
	c := ClientSetname{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLIENT", "SETNAME")
	return c
}

func (c ClientSetname) ConnectionName(connectionName string) ClientSetnameConnectionName {
	c.command.append(connectionName)
	return ClientSetnameConnectionName(c)
}

type ClientSetnameConnectionName Base

// Return Completed Redis command.
func (c ClientSetnameConnectionName) Build() Completed {
	return completed(c)
}

// Enable or disable server assisted client side caching support.
//
// Time complexity: O(1). Some options may introduce additional complexity.
type ClientTracking Base

// Enable or disable server assisted client side caching support
//
// Command: CLIENT TRACKING.
//
// Time complexity: O(1). Some options may introduce additional complexity.
func (b Builder) ClientTracking() ClientTracking {
	c := ClientTracking{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLIENT", "TRACKING")
	return c
}

func (c ClientTracking) On() ClientTrackingStatusOn {
	c.command.append("ON")
	return ClientTrackingStatusOn(c)
}

func (c ClientTracking) Off() ClientTrackingStatusOff {
	c.command.append("OFF")
	return ClientTrackingStatusOff(c)
}

type ClientTrackingBcast Base

func (c ClientTrackingBcast) Optin() ClientTrackingOptin {
	c.command.append("OPTIN")
	return ClientTrackingOptin(c)
}

func (c ClientTrackingBcast) Optout() ClientTrackingOptout {
	c.command.append("OPTOUT")
	return ClientTrackingOptout(c)
}

func (c ClientTrackingBcast) Noloop() ClientTrackingNoloop {
	c.command.append("NOLOOP")
	return ClientTrackingNoloop(c)
}

// Return Completed Redis command.
func (c ClientTrackingBcast) Build() Completed {
	return completed(c)
}

type ClientTrackingNoloop Base

// Return Completed Redis command.
func (c ClientTrackingNoloop) Build() Completed {
	return completed(c)
}

type ClientTrackingOptin Base

func (c ClientTrackingOptin) Optout() ClientTrackingOptout {
	c.command.append("OPTOUT")
	return ClientTrackingOptout(c)
}

func (c ClientTrackingOptin) Noloop() ClientTrackingNoloop {
	c.command.append("NOLOOP")
	return ClientTrackingNoloop(c)
}

// Return Completed Redis command.
func (c ClientTrackingOptin) Build() Completed {
	return completed(c)
}

type ClientTrackingOptout Base

func (c ClientTrackingOptout) Noloop() ClientTrackingNoloop {
	c.command.append("NOLOOP")
	return ClientTrackingNoloop(c)
}

// Return Completed Redis command.
func (c ClientTrackingOptout) Build() Completed {
	return completed(c)
}

type ClientTrackingPrefix Base

func (c ClientTrackingPrefix) Prefix(prefix string) ClientTrackingPrefix {
	c.command.append("PREFIX", prefix)
	return c
}

func (c ClientTrackingPrefix) Bcast() ClientTrackingBcast {
	c.command.append("BCAST")
	return ClientTrackingBcast(c)
}

func (c ClientTrackingPrefix) Optin() ClientTrackingOptin {
	c.command.append("OPTIN")
	return ClientTrackingOptin(c)
}

func (c ClientTrackingPrefix) Optout() ClientTrackingOptout {
	c.command.append("OPTOUT")
	return ClientTrackingOptout(c)
}

func (c ClientTrackingPrefix) Noloop() ClientTrackingNoloop {
	c.command.append("NOLOOP")
	return ClientTrackingNoloop(c)
}

// Return Completed Redis command.
func (c ClientTrackingPrefix) Build() Completed {
	return completed(c)
}

type ClientTrackingRedirect Base

func (c ClientTrackingRedirect) Prefix() ClientTrackingPrefix {
	return ClientTrackingPrefix(c)
}

func (c ClientTrackingRedirect) Bcast() ClientTrackingBcast {
	c.command.append("BCAST")
	return ClientTrackingBcast(c)
}

func (c ClientTrackingRedirect) Optin() ClientTrackingOptin {
	c.command.append("OPTIN")
	return ClientTrackingOptin(c)
}

func (c ClientTrackingRedirect) Optout() ClientTrackingOptout {
	c.command.append("OPTOUT")
	return ClientTrackingOptout(c)
}

func (c ClientTrackingRedirect) Noloop() ClientTrackingNoloop {
	c.command.append("NOLOOP")
	return ClientTrackingNoloop(c)
}

// Return Completed Redis command.
func (c ClientTrackingRedirect) Build() Completed {
	return completed(c)
}

type ClientTrackingStatusOff Base

func (c ClientTrackingStatusOff) Redirect(clientId int64) ClientTrackingRedirect {
	c.command.append("REDIRECT", strconv.FormatInt(clientId, 10))
	return ClientTrackingRedirect(c)
}

func (c ClientTrackingStatusOff) Prefix() ClientTrackingPrefix {
	return ClientTrackingPrefix(c)
}

func (c ClientTrackingStatusOff) Bcast() ClientTrackingBcast {
	c.command.append("BCAST")
	return ClientTrackingBcast(c)
}

func (c ClientTrackingStatusOff) Optin() ClientTrackingOptin {
	c.command.append("OPTIN")
	return ClientTrackingOptin(c)
}

func (c ClientTrackingStatusOff) Optout() ClientTrackingOptout {
	c.command.append("OPTOUT")
	return ClientTrackingOptout(c)
}

func (c ClientTrackingStatusOff) Noloop() ClientTrackingNoloop {
	c.command.append("NOLOOP")
	return ClientTrackingNoloop(c)
}

// Return Completed Redis command.
func (c ClientTrackingStatusOff) Build() Completed {
	return completed(c)
}

type ClientTrackingStatusOn Base

func (c ClientTrackingStatusOn) Redirect(clientId int64) ClientTrackingRedirect {
	c.command.append("REDIRECT", strconv.FormatInt(clientId, 10))
	return ClientTrackingRedirect(c)
}

func (c ClientTrackingStatusOn) Prefix() ClientTrackingPrefix {
	return ClientTrackingPrefix(c)
}

func (c ClientTrackingStatusOn) Bcast() ClientTrackingBcast {
	c.command.append("BCAST")
	return ClientTrackingBcast(c)
}

func (c ClientTrackingStatusOn) Optin() ClientTrackingOptin {
	c.command.append("OPTIN")
	return ClientTrackingOptin(c)
}

func (c ClientTrackingStatusOn) Optout() ClientTrackingOptout {
	c.command.append("OPTOUT")
	return ClientTrackingOptout(c)
}

func (c ClientTrackingStatusOn) Noloop() ClientTrackingNoloop {
	c.command.append("NOLOOP")
	return ClientTrackingNoloop(c)
}

// Return Completed Redis command.
func (c ClientTrackingStatusOn) Build() Completed {
	return completed(c)
}

// Return information about server assisted client side caching for the current connection.
//
// Time complexity: O(1)
type ClientTrackinginfo Base

// Return information about server assisted client side caching for the current connection
//
// Command: CLIENT TRACKINGINFO.
//
// Time complexity: O(1)
func (b Builder) ClientTrackinginfo() ClientTrackinginfo {
	c := ClientTrackinginfo{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLIENT", "TRACKINGINFO")
	return c
}

// Return Completed Redis command.
func (c ClientTrackinginfo) Build() Completed {
	return completed(c)
}

// Unblock a client blocked in a blocking command from a different connection.
//
// Time complexity: O(log N) where N is the number of client connections
type ClientUnblock Base

// Unblock a client blocked in a blocking command from a different connection
//
// Command: CLIENT UNBLOCK.
//
// Time complexity: O(log N) where N is the number of client connections
func (b Builder) ClientUnblock() ClientUnblock {
	c := ClientUnblock{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLIENT", "UNBLOCK")
	return c
}

func (c ClientUnblock) ClientId(clientId int64) ClientUnblockClientId {
	c.command.append(strconv.FormatInt(clientId, 10))
	return ClientUnblockClientId(c)
}

type ClientUnblockClientId Base

func (c ClientUnblockClientId) Timeout() ClientUnblockUnblockTypeTimeout {
	c.command.append("TIMEOUT")
	return ClientUnblockUnblockTypeTimeout(c)
}

func (c ClientUnblockClientId) Error() ClientUnblockUnblockTypeError {
	c.command.append("ERROR")
	return ClientUnblockUnblockTypeError(c)
}

// Return Completed Redis command.
func (c ClientUnblockClientId) Build() Completed {
	return completed(c)
}

type ClientUnblockUnblockTypeError Base

// Return Completed Redis command.
func (c ClientUnblockUnblockTypeError) Build() Completed {
	return completed(c)
}

type ClientUnblockUnblockTypeTimeout Base

// Return Completed Redis command.
func (c ClientUnblockUnblockTypeTimeout) Build() Completed {
	return completed(c)
}

// Resume processing of clients that were paused.
//
// Time complexity: O(N) Where N is the number of paused clients
type ClientUnpause Base

// Resume processing of clients that were paused
//
// Command: CLIENT UNPAUSE.
//
// Time complexity: O(N) Where N is the number of paused clients
func (b Builder) ClientUnpause() ClientUnpause {
	c := ClientUnpause{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLIENT", "UNPAUSE")
	return c
}

// Return Completed Redis command.
func (c ClientUnpause) Build() Completed {
	return completed(c)
}

// Assign new hash slots to receiving node.
//
// Time complexity: O(N) where N is the total number of hash slot arguments
type ClusterAddslots Base

// Assign new hash slots to receiving node
//
// Command: CLUSTER ADDSLOTS.
//
// Time complexity: O(N) where N is the total number of hash slot arguments
func (b Builder) ClusterAddslots() ClusterAddslots {
	c := ClusterAddslots{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "ADDSLOTS")
	return c
}

func (c ClusterAddslots) Slot(slot ...int64) ClusterAddslotsSlot {
	for _, n := range slot {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return ClusterAddslotsSlot(c)
}

type ClusterAddslotsSlot Base

func (c ClusterAddslotsSlot) Slot(slot ...int64) ClusterAddslotsSlot {
	for _, n := range slot {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return c
}

// Return Completed Redis command.
func (c ClusterAddslotsSlot) Build() Completed {
	return completed(c)
}

// Assign new hash slots to receiving node.
//
// Time complexity: O(N) where N is the total number of the slots between the start slot and end slot arguments.
type ClusterAddslotsrange Base

// Assign new hash slots to receiving node
//
// Command: CLUSTER ADDSLOTSRANGE.
//
// Time complexity: O(N) where N is the total number of the slots between the start slot and end slot arguments.
func (b Builder) ClusterAddslotsrange() ClusterAddslotsrange {
	c := ClusterAddslotsrange{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "ADDSLOTSRANGE")
	return c
}

func (c ClusterAddslotsrange) StartSlotEndSlot() ClusterAddslotsrangeStartSlotEndSlot {
	return ClusterAddslotsrangeStartSlotEndSlot(c)
}

type ClusterAddslotsrangeStartSlotEndSlot Base

func (c ClusterAddslotsrangeStartSlotEndSlot) StartSlotEndSlot(startSlot int64, endSlot int64) ClusterAddslotsrangeStartSlotEndSlot {
	c.command.append(strconv.FormatInt(startSlot, 10), strconv.FormatInt(endSlot, 10))
	return c
}

// Return Completed Redis command.
func (c ClusterAddslotsrangeStartSlotEndSlot) Build() Completed {
	return completed(c)
}

// Advance the cluster config epoch.
//
// Time complexity: O(1)
type ClusterBumpepoch Base

// Advance the cluster config epoch
//
// Command: CLUSTER BUMPEPOCH.
//
// Time complexity: O(1)
func (b Builder) ClusterBumpepoch() ClusterBumpepoch {
	c := ClusterBumpepoch{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "BUMPEPOCH")
	return c
}

// Return Completed Redis command.
func (c ClusterBumpepoch) Build() Completed {
	return completed(c)
}

// Return the number of failure reports active for a given node.
//
// Time complexity: O(N) where N is the number of failure reports
type ClusterCountFailureReports Base

// Return the number of failure reports active for a given node
//
// Command: CLUSTER COUNT-FAILURE-REPORTS.
//
// Time complexity: O(N) where N is the number of failure reports
func (b Builder) ClusterCountFailureReports() ClusterCountFailureReports {
	c := ClusterCountFailureReports{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "COUNT-FAILURE-REPORTS")
	return c
}

func (c ClusterCountFailureReports) NodeId(nodeId string) ClusterCountFailureReportsNodeId {
	c.command.append(nodeId)
	return ClusterCountFailureReportsNodeId(c)
}

type ClusterCountFailureReportsNodeId Base

// Return Completed Redis command.
func (c ClusterCountFailureReportsNodeId) Build() Completed {
	return completed(c)
}

// Return the number of local keys in the specified hash slot.
//
// Time complexity: O(1)
type ClusterCountkeysinslot Base

// Return the number of local keys in the specified hash slot
//
// Command: CLUSTER COUNTKEYSINSLOT.
//
// Time complexity: O(1)
func (b Builder) ClusterCountkeysinslot() ClusterCountkeysinslot {
	c := ClusterCountkeysinslot{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "COUNTKEYSINSLOT")
	return c
}

func (c ClusterCountkeysinslot) Slot(slot int64) ClusterCountkeysinslotSlot {
	c.command.append(strconv.FormatInt(slot, 10))
	return ClusterCountkeysinslotSlot(c)
}

type ClusterCountkeysinslotSlot Base

// Return Completed Redis command.
func (c ClusterCountkeysinslotSlot) Build() Completed {
	return completed(c)
}

// Set hash slots as unbound in receiving node.
//
// Time complexity: O(N) where N is the total number of hash slot arguments
type ClusterDelslots Base

// Set hash slots as unbound in receiving node
//
// Command: CLUSTER DELSLOTS.
//
// Time complexity: O(N) where N is the total number of hash slot arguments
func (b Builder) ClusterDelslots() ClusterDelslots {
	c := ClusterDelslots{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "DELSLOTS")
	return c
}

func (c ClusterDelslots) Slot(slot ...int64) ClusterDelslotsSlot {
	for _, n := range slot {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return ClusterDelslotsSlot(c)
}

type ClusterDelslotsSlot Base

func (c ClusterDelslotsSlot) Slot(slot ...int64) ClusterDelslotsSlot {
	for _, n := range slot {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return c
}

// Return Completed Redis command.
func (c ClusterDelslotsSlot) Build() Completed {
	return completed(c)
}

// Set hash slots as unbound in receiving node.
//
// Time complexity: O(N) where N is the total number of the slots between the start slot and end slot arguments.
type ClusterDelslotsrange Base

// Set hash slots as unbound in receiving node
//
// Command: CLUSTER DELSLOTSRANGE.
//
// Time complexity: O(N) where N is the total number of the slots between the start slot and end slot arguments.
func (b Builder) ClusterDelslotsrange() ClusterDelslotsrange {
	c := ClusterDelslotsrange{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "DELSLOTSRANGE")
	return c
}

func (c ClusterDelslotsrange) StartSlotEndSlot() ClusterDelslotsrangeStartSlotEndSlot {
	return ClusterDelslotsrangeStartSlotEndSlot(c)
}

type ClusterDelslotsrangeStartSlotEndSlot Base

func (c ClusterDelslotsrangeStartSlotEndSlot) StartSlotEndSlot(startSlot int64, endSlot int64) ClusterDelslotsrangeStartSlotEndSlot {
	c.command.append(strconv.FormatInt(startSlot, 10), strconv.FormatInt(endSlot, 10))
	return c
}

// Return Completed Redis command.
func (c ClusterDelslotsrangeStartSlotEndSlot) Build() Completed {
	return completed(c)
}

// Forces a replica to perform a manual failover of its master..
//
// Time complexity: O(1)
type ClusterFailover Base

// Forces a replica to perform a manual failover of its master.
//
// Command: CLUSTER FAILOVER.
//
// Time complexity: O(1)
func (b Builder) ClusterFailover() ClusterFailover {
	c := ClusterFailover{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "FAILOVER")
	return c
}

func (c ClusterFailover) Force() ClusterFailoverOptionsForce {
	c.command.append("FORCE")
	return ClusterFailoverOptionsForce(c)
}

func (c ClusterFailover) Takeover() ClusterFailoverOptionsTakeover {
	c.command.append("TAKEOVER")
	return ClusterFailoverOptionsTakeover(c)
}

// Return Completed Redis command.
func (c ClusterFailover) Build() Completed {
	return completed(c)
}

type ClusterFailoverOptionsForce Base

// Return Completed Redis command.
func (c ClusterFailoverOptionsForce) Build() Completed {
	return completed(c)
}

type ClusterFailoverOptionsTakeover Base

// Return Completed Redis command.
func (c ClusterFailoverOptionsTakeover) Build() Completed {
	return completed(c)
}

// Delete a node's own slots information.
//
// Time complexity: O(1)
type ClusterFlushslots Base

// Delete a node's own slots information
//
// Command: CLUSTER FLUSHSLOTS.
//
// Time complexity: O(1)
func (b Builder) ClusterFlushslots() ClusterFlushslots {
	c := ClusterFlushslots{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "FLUSHSLOTS")
	return c
}

// Return Completed Redis command.
func (c ClusterFlushslots) Build() Completed {
	return completed(c)
}

// Remove a node from the nodes table.
//
// Time complexity: O(1)
type ClusterForget Base

// Remove a node from the nodes table
//
// Command: CLUSTER FORGET.
//
// Time complexity: O(1)
func (b Builder) ClusterForget() ClusterForget {
	c := ClusterForget{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "FORGET")
	return c
}

func (c ClusterForget) NodeId(nodeId string) ClusterForgetNodeId {
	c.command.append(nodeId)
	return ClusterForgetNodeId(c)
}

type ClusterForgetNodeId Base

// Return Completed Redis command.
func (c ClusterForgetNodeId) Build() Completed {
	return completed(c)
}

// Return local key names in the specified hash slot.
//
// Time complexity: O(log(N)) where N is the number of requested keys
type ClusterGetkeysinslot Base

// Return local key names in the specified hash slot
//
// Command: CLUSTER GETKEYSINSLOT.
//
// Time complexity: O(log(N)) where N is the number of requested keys
func (b Builder) ClusterGetkeysinslot() ClusterGetkeysinslot {
	c := ClusterGetkeysinslot{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "GETKEYSINSLOT")
	return c
}

func (c ClusterGetkeysinslot) Slot(slot int64) ClusterGetkeysinslotSlot {
	c.command.append(strconv.FormatInt(slot, 10))
	return ClusterGetkeysinslotSlot(c)
}

type ClusterGetkeysinslotCount Base

// Return Completed Redis command.
func (c ClusterGetkeysinslotCount) Build() Completed {
	return completed(c)
}

type ClusterGetkeysinslotSlot Base

func (c ClusterGetkeysinslotSlot) Count(count int64) ClusterGetkeysinslotCount {
	c.command.append(strconv.FormatInt(count, 10))
	return ClusterGetkeysinslotCount(c)
}

// Provides info about Redis Cluster node state.
//
// Time complexity: O(1)
type ClusterInfo Base

// Provides info about Redis Cluster node state
//
// Command: CLUSTER INFO.
//
// Time complexity: O(1)
func (b Builder) ClusterInfo() ClusterInfo {
	c := ClusterInfo{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "INFO")
	return c
}

// Return Completed Redis command.
func (c ClusterInfo) Build() Completed {
	return completed(c)
}

// Returns the hash slot of the specified key.
//
// Time complexity: O(N) where N is the number of bytes in the key
type ClusterKeyslot Base

// Returns the hash slot of the specified key
//
// Command: CLUSTER KEYSLOT.
//
// Time complexity: O(N) where N is the number of bytes in the key
func (b Builder) ClusterKeyslot() ClusterKeyslot {
	c := ClusterKeyslot{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "KEYSLOT")
	return c
}

func (c ClusterKeyslot) Key(key string) ClusterKeyslotKey {
	c.command.append(key)
	return ClusterKeyslotKey(c)
}

type ClusterKeyslotKey Base

// Return Completed Redis command.
func (c ClusterKeyslotKey) Build() Completed {
	return completed(c)
}

// Returns a list of all TCP links to and from peer nodes in cluster.
//
// Time complexity: O(N) where N is the total number of Cluster nodes
type ClusterLinks Base

// Returns a list of all TCP links to and from peer nodes in cluster
//
// Command: CLUSTER LINKS.
//
// Time complexity: O(N) where N is the total number of Cluster nodes
func (b Builder) ClusterLinks() ClusterLinks {
	c := ClusterLinks{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "LINKS")
	return c
}

// Return Completed Redis command.
func (c ClusterLinks) Build() Completed {
	return completed(c)
}

// Force a node cluster to handshake with another node.
//
// Time complexity: O(1)
type ClusterMeet Base

// Force a node cluster to handshake with another node
//
// Command: CLUSTER MEET.
//
// Time complexity: O(1)
func (b Builder) ClusterMeet() ClusterMeet {
	c := ClusterMeet{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "MEET")
	return c
}

func (c ClusterMeet) Ip(ip string) ClusterMeetIp {
	c.command.append(ip)
	return ClusterMeetIp(c)
}

type ClusterMeetClusterBusPort Base

// Return Completed Redis command.
func (c ClusterMeetClusterBusPort) Build() Completed {
	return completed(c)
}

type ClusterMeetIp Base

func (c ClusterMeetIp) Port(port int64) ClusterMeetPort {
	c.command.append(strconv.FormatInt(port, 10))
	return ClusterMeetPort(c)
}

type ClusterMeetPort Base

func (c ClusterMeetPort) ClusterBusPort(clusterBusPort int64) ClusterMeetClusterBusPort {
	c.command.append(strconv.FormatInt(clusterBusPort, 10))
	return ClusterMeetClusterBusPort(c)
}

// Return Completed Redis command.
func (c ClusterMeetPort) Build() Completed {
	return completed(c)
}

// Return the node id.
//
// Time complexity: O(1)
type ClusterMyid Base

// Return the node id
//
// Command: CLUSTER MYID.
//
// Time complexity: O(1)
func (b Builder) ClusterMyid() ClusterMyid {
	c := ClusterMyid{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "MYID")
	return c
}

// Return Completed Redis command.
func (c ClusterMyid) Build() Completed {
	return completed(c)
}

// Get Cluster config for the node.
//
// Time complexity: O(N) where N is the total number of Cluster nodes
type ClusterNodes Base

// Get Cluster config for the node
//
// Command: CLUSTER NODES.
//
// Time complexity: O(N) where N is the total number of Cluster nodes
func (b Builder) ClusterNodes() ClusterNodes {
	c := ClusterNodes{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "NODES")
	return c
}

// Return Completed Redis command.
func (c ClusterNodes) Build() Completed {
	return completed(c)
}

// List replica nodes of the specified master node.
//
// Time complexity: O(1)
type ClusterReplicas Base

// List replica nodes of the specified master node
//
// Command: CLUSTER REPLICAS.
//
// Time complexity: O(1)
func (b Builder) ClusterReplicas() ClusterReplicas {
	c := ClusterReplicas{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "REPLICAS")
	return c
}

func (c ClusterReplicas) NodeId(nodeId string) ClusterReplicasNodeId {
	c.command.append(nodeId)
	return ClusterReplicasNodeId(c)
}

type ClusterReplicasNodeId Base

// Return Completed Redis command.
func (c ClusterReplicasNodeId) Build() Completed {
	return completed(c)
}

// Reconfigure a node as a replica of the specified master node.
//
// Time complexity: O(1)
type ClusterReplicate Base

// Reconfigure a node as a replica of the specified master node
//
// Command: CLUSTER REPLICATE.
//
// Time complexity: O(1)
func (b Builder) ClusterReplicate() ClusterReplicate {
	c := ClusterReplicate{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "REPLICATE")
	return c
}

func (c ClusterReplicate) NodeId(nodeId string) ClusterReplicateNodeId {
	c.command.append(nodeId)
	return ClusterReplicateNodeId(c)
}

type ClusterReplicateNodeId Base

// Return Completed Redis command.
func (c ClusterReplicateNodeId) Build() Completed {
	return completed(c)
}

// Reset a Redis Cluster node.
//
// Time complexity: O(N) where N is the number of known nodes. The command may execute a FLUSHALL as a side effect.
type ClusterReset Base

// Reset a Redis Cluster node
//
// Command: CLUSTER RESET.
//
// Time complexity: O(N) where N is the number of known nodes. The command may execute a FLUSHALL as a side effect.
func (b Builder) ClusterReset() ClusterReset {
	c := ClusterReset{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "RESET")
	return c
}

func (c ClusterReset) Hard() ClusterResetResetTypeHard {
	c.command.append("HARD")
	return ClusterResetResetTypeHard(c)
}

func (c ClusterReset) Soft() ClusterResetResetTypeSoft {
	c.command.append("SOFT")
	return ClusterResetResetTypeSoft(c)
}

// Return Completed Redis command.
func (c ClusterReset) Build() Completed {
	return completed(c)
}

type ClusterResetResetTypeHard Base

// Return Completed Redis command.
func (c ClusterResetResetTypeHard) Build() Completed {
	return completed(c)
}

type ClusterResetResetTypeSoft Base

// Return Completed Redis command.
func (c ClusterResetResetTypeSoft) Build() Completed {
	return completed(c)
}

// Forces the node to save cluster state on disk.
//
// Time complexity: O(1)
type ClusterSaveconfig Base

// Forces the node to save cluster state on disk
//
// Command: CLUSTER SAVECONFIG.
//
// Time complexity: O(1)
func (b Builder) ClusterSaveconfig() ClusterSaveconfig {
	c := ClusterSaveconfig{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "SAVECONFIG")
	return c
}

// Return Completed Redis command.
func (c ClusterSaveconfig) Build() Completed {
	return completed(c)
}

// Set the configuration epoch in a new node.
//
// Time complexity: O(1)
type ClusterSetConfigEpoch Base

// Set the configuration epoch in a new node
//
// Command: CLUSTER SET-CONFIG-EPOCH.
//
// Time complexity: O(1)
func (b Builder) ClusterSetConfigEpoch() ClusterSetConfigEpoch {
	c := ClusterSetConfigEpoch{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "SET-CONFIG-EPOCH")
	return c
}

func (c ClusterSetConfigEpoch) ConfigEpoch(configEpoch int64) ClusterSetConfigEpochConfigEpoch {
	c.command.append(strconv.FormatInt(configEpoch, 10))
	return ClusterSetConfigEpochConfigEpoch(c)
}

type ClusterSetConfigEpochConfigEpoch Base

// Return Completed Redis command.
func (c ClusterSetConfigEpochConfigEpoch) Build() Completed {
	return completed(c)
}

// Bind a hash slot to a specific node.
//
// Time complexity: O(1)
type ClusterSetslot Base

// Bind a hash slot to a specific node
//
// Command: CLUSTER SETSLOT.
//
// Time complexity: O(1)
func (b Builder) ClusterSetslot() ClusterSetslot {
	c := ClusterSetslot{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "SETSLOT")
	return c
}

func (c ClusterSetslot) Slot(slot int64) ClusterSetslotSlot {
	c.command.append(strconv.FormatInt(slot, 10))
	return ClusterSetslotSlot(c)
}

type ClusterSetslotNodeId Base

// Return Completed Redis command.
func (c ClusterSetslotNodeId) Build() Completed {
	return completed(c)
}

type ClusterSetslotSlot Base

func (c ClusterSetslotSlot) Importing() ClusterSetslotSubcommandImporting {
	c.command.append("IMPORTING")
	return ClusterSetslotSubcommandImporting(c)
}

func (c ClusterSetslotSlot) Migrating() ClusterSetslotSubcommandMigrating {
	c.command.append("MIGRATING")
	return ClusterSetslotSubcommandMigrating(c)
}

func (c ClusterSetslotSlot) Stable() ClusterSetslotSubcommandStable {
	c.command.append("STABLE")
	return ClusterSetslotSubcommandStable(c)
}

func (c ClusterSetslotSlot) Node() ClusterSetslotSubcommandNode {
	c.command.append("NODE")
	return ClusterSetslotSubcommandNode(c)
}

type ClusterSetslotSubcommandImporting Base

func (c ClusterSetslotSubcommandImporting) NodeId(nodeId string) ClusterSetslotNodeId {
	c.command.append(nodeId)
	return ClusterSetslotNodeId(c)
}

// Return Completed Redis command.
func (c ClusterSetslotSubcommandImporting) Build() Completed {
	return completed(c)
}

type ClusterSetslotSubcommandMigrating Base

func (c ClusterSetslotSubcommandMigrating) NodeId(nodeId string) ClusterSetslotNodeId {
	c.command.append(nodeId)
	return ClusterSetslotNodeId(c)
}

// Return Completed Redis command.
func (c ClusterSetslotSubcommandMigrating) Build() Completed {
	return completed(c)
}

type ClusterSetslotSubcommandNode Base

func (c ClusterSetslotSubcommandNode) NodeId(nodeId string) ClusterSetslotNodeId {
	c.command.append(nodeId)
	return ClusterSetslotNodeId(c)
}

// Return Completed Redis command.
func (c ClusterSetslotSubcommandNode) Build() Completed {
	return completed(c)
}

type ClusterSetslotSubcommandStable Base

func (c ClusterSetslotSubcommandStable) NodeId(nodeId string) ClusterSetslotNodeId {
	c.command.append(nodeId)
	return ClusterSetslotNodeId(c)
}

// Return Completed Redis command.
func (c ClusterSetslotSubcommandStable) Build() Completed {
	return completed(c)
}

type ClusterShards Base

// Command: CLUSTER SHARDS.
func (b Builder) ClusterShards() ClusterShards {
	c := ClusterShards{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "SHARDS")
	return c
}

// Return Completed Redis command.
func (c ClusterShards) Build() Completed {
	return completed(c)
}

// List replica nodes of the specified master node.
//
// Time complexity: O(1)
type ClusterSlaves Base

// List replica nodes of the specified master node
//
// Command: CLUSTER SLAVES.
//
// Time complexity: O(1)
func (b Builder) ClusterSlaves() ClusterSlaves {
	c := ClusterSlaves{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "SLAVES")
	return c
}

func (c ClusterSlaves) NodeId(nodeId string) ClusterSlavesNodeId {
	c.command.append(nodeId)
	return ClusterSlavesNodeId(c)
}

type ClusterSlavesNodeId Base

// Return Completed Redis command.
func (c ClusterSlavesNodeId) Build() Completed {
	return completed(c)
}

// Get array of Cluster slot to node mappings.
//
// Time complexity: O(N) where N is the total number of Cluster nodes
type ClusterSlots Base

// Get array of Cluster slot to node mappings
//
// Command: CLUSTER SLOTS.
//
// Time complexity: O(N) where N is the total number of Cluster nodes
func (b Builder) ClusterSlots() ClusterSlots {
	c := ClusterSlots{command: emptyCommand(), cslot: b.slot}
	c.command.append("CLUSTER", "SLOTS")
	return c
}

// Return Completed Redis command.
func (c ClusterSlots) Build() Completed {
	return completed(c)
}

// Increases the count of one or more items by increment.
//
// Time complexity: O(n) where n is the number of items
type CmsIncrby Base

// Increases the count of one or more items by increment
//
// Command: CMS.INCRBY.
//
// Time complexity: O(n) where n is the number of items
func (b Builder) CmsIncrby() CmsIncrby {
	c := CmsIncrby{command: emptyCommand(), cslot: b.slot}
	c.command.append("CMS.INCRBY")
	return c
}

func (c CmsIncrby) Key(key string) CmsIncrbyKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CmsIncrbyKey(c)
}

type CmsIncrbyItemsIncrement Base

func (c CmsIncrbyItemsIncrement) Item(item string) CmsIncrbyItemsItem {
	c.command.append(item)
	return CmsIncrbyItemsItem(c)
}

// Return Completed Redis command.
func (c CmsIncrbyItemsIncrement) Build() Completed {
	return completed(c)
}

type CmsIncrbyItemsItem Base

func (c CmsIncrbyItemsItem) Increment(increment int64) CmsIncrbyItemsIncrement {
	c.command.append(strconv.FormatInt(increment, 10))
	return CmsIncrbyItemsIncrement(c)
}

type CmsIncrbyKey Base

func (c CmsIncrbyKey) Item(item string) CmsIncrbyItemsItem {
	c.command.append(item)
	return CmsIncrbyItemsItem(c)
}

// Returns information about a sketch.
//
// Time complexity: O(1)
type CmsInfo Base

// Returns information about a sketch
//
// Command: CMS.INFO.
//
// Time complexity: O(1)
func (b Builder) CmsInfo() CmsInfo {
	c := CmsInfo{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("CMS.INFO")
	return c
}

func (c CmsInfo) Key(key string) CmsInfoKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CmsInfoKey(c)
}

type CmsInfoKey Base

// Return Completed Redis command.
func (c CmsInfoKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c CmsInfoKey) Cache() Cacheable {
	return cacheable(c)
}

// Initializes a Count-Min Sketch to dimensions specified by user.
//
// Time complexity: O(1)
type CmsInitbydim Base

// Initializes a Count-Min Sketch to dimensions specified by user
//
// Command: CMS.INITBYDIM.
//
// Time complexity: O(1)
func (b Builder) CmsInitbydim() CmsInitbydim {
	c := CmsInitbydim{command: emptyCommand(), cslot: b.slot}
	c.command.append("CMS.INITBYDIM")
	return c
}

func (c CmsInitbydim) Key(key string) CmsInitbydimKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CmsInitbydimKey(c)
}

type CmsInitbydimDepth Base

// Return Completed Redis command.
func (c CmsInitbydimDepth) Build() Completed {
	return completed(c)
}

type CmsInitbydimKey Base

func (c CmsInitbydimKey) Width(width int64) CmsInitbydimWidth {
	c.command.append(strconv.FormatInt(width, 10))
	return CmsInitbydimWidth(c)
}

type CmsInitbydimWidth Base

func (c CmsInitbydimWidth) Depth(depth int64) CmsInitbydimDepth {
	c.command.append(strconv.FormatInt(depth, 10))
	return CmsInitbydimDepth(c)
}

// Initializes a Count-Min Sketch to accommodate requested tolerances..
//
// Time complexity: O(1)
type CmsInitbyprob Base

// Initializes a Count-Min Sketch to accommodate requested tolerances.
//
// Command: CMS.INITBYPROB.
//
// Time complexity: O(1)
func (b Builder) CmsInitbyprob() CmsInitbyprob {
	c := CmsInitbyprob{command: emptyCommand(), cslot: b.slot}
	c.command.append("CMS.INITBYPROB")
	return c
}

func (c CmsInitbyprob) Key(key string) CmsInitbyprobKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CmsInitbyprobKey(c)
}

type CmsInitbyprobError Base

func (c CmsInitbyprobError) Probability(probability float64) CmsInitbyprobProbability {
	c.command.append(strconv.FormatFloat(probability, 'f', -1, 64))
	return CmsInitbyprobProbability(c)
}

type CmsInitbyprobKey Base

func (c CmsInitbyprobKey) Error(error float64) CmsInitbyprobError {
	c.command.append(strconv.FormatFloat(error, 'f', -1, 64))
	return CmsInitbyprobError(c)
}

type CmsInitbyprobProbability Base

// Return Completed Redis command.
func (c CmsInitbyprobProbability) Build() Completed {
	return completed(c)
}

// Merges several sketches into one sketch.
//
// Time complexity: O(n) where n is the number of sketches
type CmsMerge Base

// Merges several sketches into one sketch
//
// Command: CMS.MERGE.
//
// Time complexity: O(n) where n is the number of sketches
func (b Builder) CmsMerge() CmsMerge {
	c := CmsMerge{command: emptyCommand(), cslot: b.slot}
	c.command.append("CMS.MERGE")
	return c
}

func (c CmsMerge) Destination(destination string) CmsMergeDestination {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append(destination)
	return CmsMergeDestination(c)
}

type CmsMergeDestination Base

func (c CmsMergeDestination) Numkeys(numkeys int64) CmsMergeNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return CmsMergeNumkeys(c)
}

type CmsMergeNumkeys Base

func (c CmsMergeNumkeys) Source(source ...string) CmsMergeSource {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range source {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range source {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(source...)
	return CmsMergeSource(c)
}

type CmsMergeSource Base

func (c CmsMergeSource) Source(source ...string) CmsMergeSource {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range source {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range source {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(source...)
	return c
}

func (c CmsMergeSource) Weights() CmsMergeWeightWeights {
	c.command.append("WEIGHTS")
	return CmsMergeWeightWeights(c)
}

// Return Completed Redis command.
func (c CmsMergeSource) Build() Completed {
	return completed(c)
}

type CmsMergeWeightWeight Base

func (c CmsMergeWeightWeight) Weight(weight ...float64) CmsMergeWeightWeight {
	for _, n := range weight {
		c.command.append(strconv.FormatFloat(n, 'f', -1, 64))
	}
	return c
}

// Return Completed Redis command.
func (c CmsMergeWeightWeight) Build() Completed {
	return completed(c)
}

type CmsMergeWeightWeights Base

func (c CmsMergeWeightWeights) Weight(weight ...float64) CmsMergeWeightWeight {
	for _, n := range weight {
		c.command.append(strconv.FormatFloat(n, 'f', -1, 64))
	}
	return CmsMergeWeightWeight(c)
}

// Returns the count for one or more items in a sketch.
//
// Time complexity: O(n) where n is the number of items
type CmsQuery Base

// Returns the count for one or more items in a sketch
//
// Command: CMS.QUERY.
//
// Time complexity: O(n) where n is the number of items
func (b Builder) CmsQuery() CmsQuery {
	c := CmsQuery{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("CMS.QUERY")
	return c
}

func (c CmsQuery) Key(key string) CmsQueryKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return CmsQueryKey(c)
}

type CmsQueryItem Base

func (c CmsQueryItem) Item(item ...string) CmsQueryItem {
	c.command.append(item...)
	return c
}

// Return Completed Redis command.
func (c CmsQueryItem) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c CmsQueryItem) Cache() Cacheable {
	return cacheable(c)
}

type CmsQueryKey Base

func (c CmsQueryKey) Item(item ...string) CmsQueryItem {
	c.command.append(item...)
	return CmsQueryItem(c)
}

// Get array of Redis command details.
//
// Time complexity: O(N) where N is the total number of Redis commands
type Command Base

// Get array of Redis command details
//
// Command: COMMAND.
//
// Time complexity: O(N) where N is the total number of Redis commands
func (b Builder) Command() Command {
	c := Command{command: emptyCommand(), cslot: b.slot}
	c.command.append("COMMAND")
	return c
}

// Return Completed Redis command.
func (c Command) Build() Completed {
	return completed(c)
}

// Get total number of Redis commands.
//
// Time complexity: O(1)
type CommandCount Base

// Get total number of Redis commands
//
// Command: COMMAND COUNT.
//
// Time complexity: O(1)
func (b Builder) CommandCount() CommandCount {
	c := CommandCount{command: emptyCommand(), cslot: b.slot}
	c.command.append("COMMAND", "COUNT")
	return c
}

// Return Completed Redis command.
func (c CommandCount) Build() Completed {
	return completed(c)
}

type CommandDocs Base

// Command: COMMAND DOCS.
func (b Builder) CommandDocs() CommandDocs {
	c := CommandDocs{command: emptyCommand(), cslot: b.slot}
	c.command.append("COMMAND", "DOCS")
	return c
}

func (c CommandDocs) CommandName(commandName ...string) CommandDocsCommandName {
	c.command.append(commandName...)
	return CommandDocsCommandName(c)
}

// Return Completed Redis command.
func (c CommandDocs) Build() Completed {
	return completed(c)
}

type CommandDocsCommandName Base

func (c CommandDocsCommandName) CommandName(commandName ...string) CommandDocsCommandName {
	c.command.append(commandName...)
	return c
}

// Return Completed Redis command.
func (c CommandDocsCommandName) Build() Completed {
	return completed(c)
}

// Extract keys given a full Redis command.
//
// Time complexity: O(N) where N is the number of arguments to the command
type CommandGetkeys Base

// Extract keys given a full Redis command
//
// Command: COMMAND GETKEYS.
//
// Time complexity: O(N) where N is the number of arguments to the command
func (b Builder) CommandGetkeys() CommandGetkeys {
	c := CommandGetkeys{command: emptyCommand(), cslot: b.slot}
	c.command.append("COMMAND", "GETKEYS")
	return c
}

// Return Completed Redis command.
func (c CommandGetkeys) Build() Completed {
	return completed(c)
}

// Extract keys given a full Redis command.
//
// Time complexity: O(N) where N is the number of arguments to the command
type CommandGetkeysandflags Base

// Extract keys given a full Redis command
//
// Command: COMMAND GETKEYSANDFLAGS.
//
// Time complexity: O(N) where N is the number of arguments to the command
func (b Builder) CommandGetkeysandflags() CommandGetkeysandflags {
	c := CommandGetkeysandflags{command: emptyCommand(), cslot: b.slot}
	c.command.append("COMMAND", "GETKEYSANDFLAGS")
	return c
}

// Return Completed Redis command.
func (c CommandGetkeysandflags) Build() Completed {
	return completed(c)
}

// Get array of specific Redis command details.
//
// Time complexity: O(N) when N is number of commands to look up
type CommandInfo Base

// Get array of specific Redis command details
//
// Command: COMMAND INFO.
//
// Time complexity: O(N) when N is number of commands to look up
func (b Builder) CommandInfo() CommandInfo {
	c := CommandInfo{command: emptyCommand(), cslot: b.slot}
	c.command.append("COMMAND", "INFO")
	return c
}

func (c CommandInfo) CommandName(commandName ...string) CommandInfoCommandName {
	c.command.append(commandName...)
	return CommandInfoCommandName(c)
}

// Return Completed Redis command.
func (c CommandInfo) Build() Completed {
	return completed(c)
}

type CommandInfoCommandName Base

func (c CommandInfoCommandName) CommandName(commandName ...string) CommandInfoCommandName {
	c.command.append(commandName...)
	return c
}

// Return Completed Redis command.
func (c CommandInfoCommandName) Build() Completed {
	return completed(c)
}

type CommandList Base

// Command: COMMAND LIST.
func (b Builder) CommandList() CommandList {
	c := CommandList{command: emptyCommand(), cslot: b.slot}
	c.command.append("COMMAND", "LIST")
	return c
}

func (c CommandList) FilterbyModuleName(name string) CommandListFilterbyModuleName {
	c.command.append("FILTERBY", "MODULE", name)
	return CommandListFilterbyModuleName(c)
}

func (c CommandList) FilterbyAclcatCategory(category string) CommandListFilterbyAclcatCategory {
	c.command.append("FILTERBY", "ACLCAT", category)
	return CommandListFilterbyAclcatCategory(c)
}

func (c CommandList) FilterbyPatternPattern(pattern string) CommandListFilterbyPatternPattern {
	c.command.append("FILTERBY", "PATTERN", pattern)
	return CommandListFilterbyPatternPattern(c)
}

// Return Completed Redis command.
func (c CommandList) Build() Completed {
	return completed(c)
}

type CommandListFilterbyAclcatCategory Base

// Return Completed Redis command.
func (c CommandListFilterbyAclcatCategory) Build() Completed {
	return completed(c)
}

type CommandListFilterbyModuleName Base

// Return Completed Redis command.
func (c CommandListFilterbyModuleName) Build() Completed {
	return completed(c)
}

type CommandListFilterbyPatternPattern Base

// Return Completed Redis command.
func (c CommandListFilterbyPatternPattern) Build() Completed {
	return completed(c)
}

// Get the values of configuration parameters.
type ConfigGet Base

// Get the values of configuration parameters
//
// Command: CONFIG GET.
func (b Builder) ConfigGet() ConfigGet {
	c := ConfigGet{command: emptyCommand(), cslot: b.slot}
	c.command.append("CONFIG", "GET")
	return c
}

func (c ConfigGet) Parameter(parameter ...string) ConfigGetParameter {
	c.command.append(parameter...)
	return ConfigGetParameter(c)
}

type ConfigGetParameter Base

func (c ConfigGetParameter) Parameter(parameter ...string) ConfigGetParameter {
	c.command.append(parameter...)
	return c
}

// Return Completed Redis command.
func (c ConfigGetParameter) Build() Completed {
	return completed(c)
}

// Reset the stats returned by INFO.
//
// Time complexity: O(1)
type ConfigResetstat Base

// Reset the stats returned by INFO
//
// Command: CONFIG RESETSTAT.
//
// Time complexity: O(1)
func (b Builder) ConfigResetstat() ConfigResetstat {
	c := ConfigResetstat{command: emptyCommand(), cslot: b.slot}
	c.command.append("CONFIG", "RESETSTAT")
	return c
}

// Return Completed Redis command.
func (c ConfigResetstat) Build() Completed {
	return completed(c)
}

// Rewrite the configuration file with the in memory configuration.
type ConfigRewrite Base

// Rewrite the configuration file with the in memory configuration
//
// Command: CONFIG REWRITE.
func (b Builder) ConfigRewrite() ConfigRewrite {
	c := ConfigRewrite{command: emptyCommand(), cslot: b.slot}
	c.command.append("CONFIG", "REWRITE")
	return c
}

// Return Completed Redis command.
func (c ConfigRewrite) Build() Completed {
	return completed(c)
}

// Set configuration parameters to the given values.
type ConfigSet Base

// Set configuration parameters to the given values
//
// Command: CONFIG SET.
func (b Builder) ConfigSet() ConfigSet {
	c := ConfigSet{command: emptyCommand(), cslot: b.slot}
	c.command.append("CONFIG", "SET")
	return c
}

func (c ConfigSet) ParameterValue() ConfigSetParameterValue {
	return ConfigSetParameterValue(c)
}

type ConfigSetParameterValue Base

func (c ConfigSetParameterValue) ParameterValue(parameter string, value string) ConfigSetParameterValue {
	c.command.append(parameter, value)
	return c
}

// Return Completed Redis command.
func (c ConfigSetParameterValue) Build() Completed {
	return completed(c)
}

// Copy a key.
//
// Time complexity: O(N) worst case for collections, where N is the number of nested items. O(1) for string values.
type Copy Base

// Copy a key
//
// Command: COPY.
//
// Time complexity: O(N) worst case for collections, where N is the number of nested items. O(1) for string values.
func (b Builder) Copy() Copy {
	c := Copy{command: emptyCommand(), cslot: b.slot}
	c.command.append("COPY")
	return c
}

func (c Copy) Source(source string) CopySource {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(source)
	} else {
		c.cslot.set(getSlot(source))
	}
	c.command.append(source)
	return CopySource(c)
}

type CopyDb Base

func (c CopyDb) Replace() CopyReplace {
	c.command.append("REPLACE")
	return CopyReplace(c)
}

// Return Completed Redis command.
func (c CopyDb) Build() Completed {
	return completed(c)
}

type CopyDestination Base

func (c CopyDestination) Db(destinationDb int64) CopyDb {
	c.command.append("DB", strconv.FormatInt(destinationDb, 10))
	return CopyDb(c)
}

func (c CopyDestination) Replace() CopyReplace {
	c.command.append("REPLACE")
	return CopyReplace(c)
}

// Return Completed Redis command.
func (c CopyDestination) Build() Completed {
	return completed(c)
}

type CopyReplace Base

// Return Completed Redis command.
func (c CopyReplace) Build() Completed {
	return completed(c)
}

type CopySource Base

func (c CopySource) Destination(destination string) CopyDestination {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append(destination)
	return CopyDestination(c)
}

// Return the number of keys in the selected database.
type Dbsize Base

// Return the number of keys in the selected database
//
// Command: DBSIZE.
func (b Builder) Dbsize() Dbsize {
	c := Dbsize{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("DBSIZE")
	return c
}

// Return Completed Redis command.
func (c Dbsize) Build() Completed {
	return completed(c)
}

// Get debugging information about a key.
type DebugObject Base

// Get debugging information about a key
//
// Command: DEBUG OBJECT.
func (b Builder) DebugObject() DebugObject {
	c := DebugObject{command: emptyCommand(), cslot: b.slot}
	c.command.append("DEBUG", "OBJECT")
	return c
}

func (c DebugObject) Key(key string) DebugObjectKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return DebugObjectKey(c)
}

type DebugObjectKey Base

// Return Completed Redis command.
func (c DebugObjectKey) Build() Completed {
	return completed(c)
}

// Make the server crash.
type DebugSegfault Base

// Make the server crash
//
// Command: DEBUG SEGFAULT.
func (b Builder) DebugSegfault() DebugSegfault {
	c := DebugSegfault{command: emptyCommand(), cslot: b.slot}
	c.command.append("DEBUG", "SEGFAULT")
	return c
}

// Return Completed Redis command.
func (c DebugSegfault) Build() Completed {
	return completed(c)
}

// Decrement the integer value of a key by one.
//
// Time complexity: O(1)
type Decr Base

// Decrement the integer value of a key by one
//
// Command: DECR.
//
// Time complexity: O(1)
func (b Builder) Decr() Decr {
	c := Decr{command: emptyCommand(), cslot: b.slot}
	c.command.append("DECR")
	return c
}

func (c Decr) Key(key string) DecrKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return DecrKey(c)
}

type DecrKey Base

// Return Completed Redis command.
func (c DecrKey) Build() Completed {
	return completed(c)
}

// Decrement the integer value of a key by the given number.
//
// Time complexity: O(1)
type Decrby Base

// Decrement the integer value of a key by the given number
//
// Command: DECRBY.
//
// Time complexity: O(1)
func (b Builder) Decrby() Decrby {
	c := Decrby{command: emptyCommand(), cslot: b.slot}
	c.command.append("DECRBY")
	return c
}

func (c Decrby) Key(key string) DecrbyKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return DecrbyKey(c)
}

type DecrbyDecrement Base

// Return Completed Redis command.
func (c DecrbyDecrement) Build() Completed {
	return completed(c)
}

type DecrbyKey Base

func (c DecrbyKey) Decrement(decrement int64) DecrbyDecrement {
	c.command.append(strconv.FormatInt(decrement, 10))
	return DecrbyDecrement(c)
}

// Delete a key.
//
// Time complexity: O(N) where N is the number of keys that will be removed. When a key to remove holds a value other than a string, the individual complexity for this key is O(M) where M is the number of elements in the list, set, sorted set or hash. Removing a single key that holds a string value is O(1).
type Del Base

// Delete a key
//
// Command: DEL.
//
// Time complexity: O(N) where N is the number of keys that will be removed. When a key to remove holds a value other than a string, the individual complexity for this key is O(M) where M is the number of elements in the list, set, sorted set or hash. Removing a single key that holds a string value is O(1).
func (b Builder) Del() Del {
	c := Del{command: emptyCommand(), cslot: b.slot}
	c.command.append("DEL")
	return c
}

func (c Del) Key(key ...string) DelKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return DelKey(c)
}

type DelKey Base

func (c DelKey) Key(key ...string) DelKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c DelKey) Build() Completed {
	return completed(c)
}

// Discard all commands issued after MULTI.
type Discard Base

// Discard all commands issued after MULTI
//
// Command: DISCARD.
func (b Builder) Discard() Discard {
	c := Discard{command: emptyCommand(), cslot: b.slot}
	c.command.append("DISCARD")
	return c
}

// Return Completed Redis command.
func (c Discard) Build() Completed {
	return completed(c)
}

// Return a serialized version of the value stored at the specified key..
//
// Time complexity: O(1) to access the key and additional O(N*M) to serialize it, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1).
type Dump Base

// Return a serialized version of the value stored at the specified key.
//
// Command: DUMP.
//
// Time complexity: O(1) to access the key and additional O(N*M) to serialize it, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1).
func (b Builder) Dump() Dump {
	c := Dump{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("DUMP")
	return c
}

func (c Dump) Key(key string) DumpKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return DumpKey(c)
}

type DumpKey Base

// Return Completed Redis command.
func (c DumpKey) Build() Completed {
	return completed(c)
}

// Echo the given string.
type Echo Base

// Echo the given string
//
// Command: ECHO.
func (b Builder) Echo() Echo {
	c := Echo{command: emptyCommand(), cslot: b.slot}
	c.command.append("ECHO")
	return c
}

func (c Echo) Message(message string) EchoMessage {
	c.command.append(message)
	return EchoMessage(c)
}

type EchoMessage Base

// Return Completed Redis command.
func (c EchoMessage) Build() Completed {
	return completed(c)
}

// Execute a Lua script server side.
//
// Time complexity: Depends on the script that is executed.
type Eval Base

// Execute a Lua script server side
//
// Command: EVAL.
//
// Time complexity: Depends on the script that is executed.
func (b Builder) Eval() Eval {
	c := Eval{command: emptyCommand(), cslot: b.slot}
	c.command.append("EVAL")
	return c
}

func (c Eval) Script(script string) EvalScript {
	c.command.append(script)
	return EvalScript(c)
}

type EvalArg Base

func (c EvalArg) Arg(arg ...string) EvalArg {
	c.command.append(arg...)
	return c
}

// Return Completed Redis command.
func (c EvalArg) Build() Completed {
	return completed(c)
}

type EvalKey Base

func (c EvalKey) Key(key ...string) EvalKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c EvalKey) Arg(arg ...string) EvalArg {
	c.command.append(arg...)
	return EvalArg(c)
}

// Return Completed Redis command.
func (c EvalKey) Build() Completed {
	return completed(c)
}

type EvalNumkeys Base

func (c EvalNumkeys) Key(key ...string) EvalKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return EvalKey(c)
}

func (c EvalNumkeys) Arg(arg ...string) EvalArg {
	c.command.append(arg...)
	return EvalArg(c)
}

// Return Completed Redis command.
func (c EvalNumkeys) Build() Completed {
	return completed(c)
}

// Execute a read-only Lua script server side.
//
// Time complexity: Depends on the script that is executed.
type EvalRo Base

// Execute a read-only Lua script server side
//
// Command: EVAL_RO.
//
// Time complexity: Depends on the script that is executed.
func (b Builder) EvalRo() EvalRo {
	c := EvalRo{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("EVAL_RO")
	return c
}

func (c EvalRo) Script(script string) EvalRoScript {
	c.command.append(script)
	return EvalRoScript(c)
}

type EvalRoArg Base

func (c EvalRoArg) Arg(arg ...string) EvalRoArg {
	c.command.append(arg...)
	return c
}

// Return Completed Redis command.
func (c EvalRoArg) Build() Completed {
	return completed(c)
}

type EvalRoKey Base

func (c EvalRoKey) Key(key ...string) EvalRoKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c EvalRoKey) Arg(arg ...string) EvalRoArg {
	c.command.append(arg...)
	return EvalRoArg(c)
}

// Return Completed Redis command.
func (c EvalRoKey) Build() Completed {
	return completed(c)
}

type EvalRoNumkeys Base

func (c EvalRoNumkeys) Key(key ...string) EvalRoKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return EvalRoKey(c)
}

func (c EvalRoNumkeys) Arg(arg ...string) EvalRoArg {
	c.command.append(arg...)
	return EvalRoArg(c)
}

// Return Completed Redis command.
func (c EvalRoNumkeys) Build() Completed {
	return completed(c)
}

type EvalRoScript Base

func (c EvalRoScript) Numkeys(numkeys int64) EvalRoNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return EvalRoNumkeys(c)
}

type EvalScript Base

func (c EvalScript) Numkeys(numkeys int64) EvalNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return EvalNumkeys(c)
}

// Execute a Lua script server side.
//
// Time complexity: Depends on the script that is executed.
type Evalsha Base

// Execute a Lua script server side
//
// Command: EVALSHA.
//
// Time complexity: Depends on the script that is executed.
func (b Builder) Evalsha() Evalsha {
	c := Evalsha{command: emptyCommand(), cslot: b.slot}
	c.command.append("EVALSHA")
	return c
}

func (c Evalsha) Sha1(sha1 string) EvalshaSha1 {
	c.command.append(sha1)
	return EvalshaSha1(c)
}

type EvalshaArg Base

func (c EvalshaArg) Arg(arg ...string) EvalshaArg {
	c.command.append(arg...)
	return c
}

// Return Completed Redis command.
func (c EvalshaArg) Build() Completed {
	return completed(c)
}

type EvalshaKey Base

func (c EvalshaKey) Key(key ...string) EvalshaKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c EvalshaKey) Arg(arg ...string) EvalshaArg {
	c.command.append(arg...)
	return EvalshaArg(c)
}

// Return Completed Redis command.
func (c EvalshaKey) Build() Completed {
	return completed(c)
}

type EvalshaNumkeys Base

func (c EvalshaNumkeys) Key(key ...string) EvalshaKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return EvalshaKey(c)
}

func (c EvalshaNumkeys) Arg(arg ...string) EvalshaArg {
	c.command.append(arg...)
	return EvalshaArg(c)
}

// Return Completed Redis command.
func (c EvalshaNumkeys) Build() Completed {
	return completed(c)
}

// Execute a read-only Lua script server side.
//
// Time complexity: Depends on the script that is executed.
type EvalshaRo Base

// Execute a read-only Lua script server side
//
// Command: EVALSHA_RO.
//
// Time complexity: Depends on the script that is executed.
func (b Builder) EvalshaRo() EvalshaRo {
	c := EvalshaRo{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("EVALSHA_RO")
	return c
}

func (c EvalshaRo) Sha1(sha1 string) EvalshaRoSha1 {
	c.command.append(sha1)
	return EvalshaRoSha1(c)
}

type EvalshaRoArg Base

func (c EvalshaRoArg) Arg(arg ...string) EvalshaRoArg {
	c.command.append(arg...)
	return c
}

// Return Completed Redis command.
func (c EvalshaRoArg) Build() Completed {
	return completed(c)
}

type EvalshaRoKey Base

func (c EvalshaRoKey) Key(key ...string) EvalshaRoKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c EvalshaRoKey) Arg(arg ...string) EvalshaRoArg {
	c.command.append(arg...)
	return EvalshaRoArg(c)
}

// Return Completed Redis command.
func (c EvalshaRoKey) Build() Completed {
	return completed(c)
}

type EvalshaRoNumkeys Base

func (c EvalshaRoNumkeys) Key(key ...string) EvalshaRoKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return EvalshaRoKey(c)
}

func (c EvalshaRoNumkeys) Arg(arg ...string) EvalshaRoArg {
	c.command.append(arg...)
	return EvalshaRoArg(c)
}

// Return Completed Redis command.
func (c EvalshaRoNumkeys) Build() Completed {
	return completed(c)
}

type EvalshaRoSha1 Base

func (c EvalshaRoSha1) Numkeys(numkeys int64) EvalshaRoNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return EvalshaRoNumkeys(c)
}

type EvalshaSha1 Base

func (c EvalshaSha1) Numkeys(numkeys int64) EvalshaNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return EvalshaNumkeys(c)
}

// Execute all commands issued after MULTI.
type Exec Base

// Execute all commands issued after MULTI
//
// Command: EXEC.
func (b Builder) Exec() Exec {
	c := Exec{command: emptyCommand(), cslot: b.slot}
	c.command.append("EXEC")
	return c
}

// Return Completed Redis command.
func (c Exec) Build() Completed {
	return completed(c)
}

// Determine if a key exists.
//
// Time complexity: O(N) where N is the number of keys to check.
type Exists Base

// Determine if a key exists
//
// Command: EXISTS.
//
// Time complexity: O(N) where N is the number of keys to check.
func (b Builder) Exists() Exists {
	c := Exists{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("EXISTS")
	return c
}

func (c Exists) Key(key ...string) ExistsKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return ExistsKey(c)
}

type ExistsKey Base

func (c ExistsKey) Key(key ...string) ExistsKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c ExistsKey) Build() Completed {
	return completed(c)
}

// Set a key's time to live in seconds.
//
// Time complexity: O(1)
type Expire Base

// Set a key's time to live in seconds
//
// Command: EXPIRE.
//
// Time complexity: O(1)
func (b Builder) Expire() Expire {
	c := Expire{command: emptyCommand(), cslot: b.slot}
	c.command.append("EXPIRE")
	return c
}

func (c Expire) Key(key string) ExpireKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ExpireKey(c)
}

type ExpireConditionGt Base

// Return Completed Redis command.
func (c ExpireConditionGt) Build() Completed {
	return completed(c)
}

type ExpireConditionLt Base

// Return Completed Redis command.
func (c ExpireConditionLt) Build() Completed {
	return completed(c)
}

type ExpireConditionNx Base

// Return Completed Redis command.
func (c ExpireConditionNx) Build() Completed {
	return completed(c)
}

type ExpireConditionXx Base

// Return Completed Redis command.
func (c ExpireConditionXx) Build() Completed {
	return completed(c)
}

type ExpireKey Base

func (c ExpireKey) Seconds(seconds int64) ExpireSeconds {
	c.command.append(strconv.FormatInt(seconds, 10))
	return ExpireSeconds(c)
}

type ExpireSeconds Base

func (c ExpireSeconds) Nx() ExpireConditionNx {
	c.command.append("NX")
	return ExpireConditionNx(c)
}

func (c ExpireSeconds) Xx() ExpireConditionXx {
	c.command.append("XX")
	return ExpireConditionXx(c)
}

func (c ExpireSeconds) Gt() ExpireConditionGt {
	c.command.append("GT")
	return ExpireConditionGt(c)
}

func (c ExpireSeconds) Lt() ExpireConditionLt {
	c.command.append("LT")
	return ExpireConditionLt(c)
}

// Return Completed Redis command.
func (c ExpireSeconds) Build() Completed {
	return completed(c)
}

// Set the expiration for a key as a UNIX timestamp.
//
// Time complexity: O(1)
type Expireat Base

// Set the expiration for a key as a UNIX timestamp
//
// Command: EXPIREAT.
//
// Time complexity: O(1)
func (b Builder) Expireat() Expireat {
	c := Expireat{command: emptyCommand(), cslot: b.slot}
	c.command.append("EXPIREAT")
	return c
}

func (c Expireat) Key(key string) ExpireatKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ExpireatKey(c)
}

type ExpireatConditionGt Base

// Return Completed Redis command.
func (c ExpireatConditionGt) Build() Completed {
	return completed(c)
}

type ExpireatConditionLt Base

// Return Completed Redis command.
func (c ExpireatConditionLt) Build() Completed {
	return completed(c)
}

type ExpireatConditionNx Base

// Return Completed Redis command.
func (c ExpireatConditionNx) Build() Completed {
	return completed(c)
}

type ExpireatConditionXx Base

// Return Completed Redis command.
func (c ExpireatConditionXx) Build() Completed {
	return completed(c)
}

type ExpireatKey Base

func (c ExpireatKey) Timestamp(timestamp int64) ExpireatTimestamp {
	c.command.append(strconv.FormatInt(timestamp, 10))
	return ExpireatTimestamp(c)
}

type ExpireatTimestamp Base

func (c ExpireatTimestamp) Nx() ExpireatConditionNx {
	c.command.append("NX")
	return ExpireatConditionNx(c)
}

func (c ExpireatTimestamp) Xx() ExpireatConditionXx {
	c.command.append("XX")
	return ExpireatConditionXx(c)
}

func (c ExpireatTimestamp) Gt() ExpireatConditionGt {
	c.command.append("GT")
	return ExpireatConditionGt(c)
}

func (c ExpireatTimestamp) Lt() ExpireatConditionLt {
	c.command.append("LT")
	return ExpireatConditionLt(c)
}

// Return Completed Redis command.
func (c ExpireatTimestamp) Build() Completed {
	return completed(c)
}

// Get the expiration Unix timestamp for a key.
//
// Time complexity: O(1)
type Expiretime Base

// Get the expiration Unix timestamp for a key
//
// Command: EXPIRETIME.
//
// Time complexity: O(1)
func (b Builder) Expiretime() Expiretime {
	c := Expiretime{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("EXPIRETIME")
	return c
}

func (c Expiretime) Key(key string) ExpiretimeKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ExpiretimeKey(c)
}

type ExpiretimeKey Base

// Return Completed Redis command.
func (c ExpiretimeKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ExpiretimeKey) Cache() Cacheable {
	return cacheable(c)
}

// Start a coordinated failover between this server and one of its replicas..
type Failover Base

// Start a coordinated failover between this server and one of its replicas.
//
// Command: FAILOVER.
func (b Builder) Failover() Failover {
	c := Failover{command: emptyCommand(), cslot: b.slot}
	c.command.append("FAILOVER")
	return c
}

func (c Failover) To() FailoverTargetTo {
	c.command.append("TO")
	return FailoverTargetTo(c)
}

func (c Failover) Abort() FailoverAbort {
	c.command.append("ABORT")
	return FailoverAbort(c)
}

func (c Failover) Timeout(milliseconds int64) FailoverTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(milliseconds, 10))
	return FailoverTimeout(c)
}

// Return Completed Redis command.
func (c Failover) Build() Completed {
	return completed(c)
}

type FailoverAbort Base

func (c FailoverAbort) Timeout(milliseconds int64) FailoverTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(milliseconds, 10))
	return FailoverTimeout(c)
}

// Return Completed Redis command.
func (c FailoverAbort) Build() Completed {
	return completed(c)
}

type FailoverTargetForce Base

func (c FailoverTargetForce) Abort() FailoverAbort {
	c.command.append("ABORT")
	return FailoverAbort(c)
}

func (c FailoverTargetForce) Timeout(milliseconds int64) FailoverTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(milliseconds, 10))
	return FailoverTimeout(c)
}

// Return Completed Redis command.
func (c FailoverTargetForce) Build() Completed {
	return completed(c)
}

type FailoverTargetHost Base

func (c FailoverTargetHost) Port(port int64) FailoverTargetPort {
	c.command.append(strconv.FormatInt(port, 10))
	return FailoverTargetPort(c)
}

type FailoverTargetPort Base

func (c FailoverTargetPort) Force() FailoverTargetForce {
	c.command.append("FORCE")
	return FailoverTargetForce(c)
}

func (c FailoverTargetPort) Abort() FailoverAbort {
	c.command.append("ABORT")
	return FailoverAbort(c)
}

func (c FailoverTargetPort) Timeout(milliseconds int64) FailoverTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(milliseconds, 10))
	return FailoverTimeout(c)
}

// Return Completed Redis command.
func (c FailoverTargetPort) Build() Completed {
	return completed(c)
}

type FailoverTargetTo Base

func (c FailoverTargetTo) Host(host string) FailoverTargetHost {
	c.command.append(host)
	return FailoverTargetHost(c)
}

type FailoverTimeout Base

// Return Completed Redis command.
func (c FailoverTimeout) Build() Completed {
	return completed(c)
}

type Fcall Base

// Command: FCALL.
func (b Builder) Fcall() Fcall {
	c := Fcall{command: emptyCommand(), cslot: b.slot}
	c.command.append("FCALL")
	return c
}

func (c Fcall) Function(function string) FcallFunction {
	c.command.append(function)
	return FcallFunction(c)
}

type FcallArg Base

func (c FcallArg) Arg(arg ...string) FcallArg {
	c.command.append(arg...)
	return c
}

// Return Completed Redis command.
func (c FcallArg) Build() Completed {
	return completed(c)
}

type FcallFunction Base

func (c FcallFunction) Numkeys(numkeys int64) FcallNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return FcallNumkeys(c)
}

type FcallKey Base

func (c FcallKey) Key(key ...string) FcallKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c FcallKey) Arg(arg ...string) FcallArg {
	c.command.append(arg...)
	return FcallArg(c)
}

// Return Completed Redis command.
func (c FcallKey) Build() Completed {
	return completed(c)
}

type FcallNumkeys Base

func (c FcallNumkeys) Key(key ...string) FcallKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return FcallKey(c)
}

func (c FcallNumkeys) Arg(arg ...string) FcallArg {
	c.command.append(arg...)
	return FcallArg(c)
}

// Return Completed Redis command.
func (c FcallNumkeys) Build() Completed {
	return completed(c)
}

type FcallRo Base

// Command: FCALL_RO.
func (b Builder) FcallRo() FcallRo {
	c := FcallRo{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("FCALL_RO")
	return c
}

func (c FcallRo) Function(function string) FcallRoFunction {
	c.command.append(function)
	return FcallRoFunction(c)
}

type FcallRoArg Base

func (c FcallRoArg) Arg(arg ...string) FcallRoArg {
	c.command.append(arg...)
	return c
}

// Return Completed Redis command.
func (c FcallRoArg) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c FcallRoArg) Cache() Cacheable {
	return cacheable(c)
}

type FcallRoFunction Base

func (c FcallRoFunction) Numkeys(numkeys int64) FcallRoNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return FcallRoNumkeys(c)
}

type FcallRoKey Base

func (c FcallRoKey) Key(key ...string) FcallRoKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c FcallRoKey) Arg(arg ...string) FcallRoArg {
	c.command.append(arg...)
	return FcallRoArg(c)
}

// Return Completed Redis command.
func (c FcallRoKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c FcallRoKey) Cache() Cacheable {
	return cacheable(c)
}

type FcallRoNumkeys Base

func (c FcallRoNumkeys) Key(key ...string) FcallRoKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return FcallRoKey(c)
}

func (c FcallRoNumkeys) Arg(arg ...string) FcallRoArg {
	c.command.append(arg...)
	return FcallRoArg(c)
}

// Return Completed Redis command.
func (c FcallRoNumkeys) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c FcallRoNumkeys) Cache() Cacheable {
	return cacheable(c)
}

// Remove all keys from all databases.
//
// Time complexity: O(N) where N is the total number of keys in all databases
type Flushall Base

// Remove all keys from all databases
//
// Command: FLUSHALL.
//
// Time complexity: O(N) where N is the total number of keys in all databases
func (b Builder) Flushall() Flushall {
	c := Flushall{command: emptyCommand(), cslot: b.slot}
	c.command.append("FLUSHALL")
	return c
}

func (c Flushall) Async() FlushallAsync {
	c.command.append("ASYNC")
	return FlushallAsync(c)
}

func (c Flushall) Sync() FlushallAsyncSync {
	c.command.append("SYNC")
	return FlushallAsyncSync(c)
}

// Return Completed Redis command.
func (c Flushall) Build() Completed {
	return completed(c)
}

type FlushallAsync Base

// Return Completed Redis command.
func (c FlushallAsync) Build() Completed {
	return completed(c)
}

type FlushallAsyncSync Base

// Return Completed Redis command.
func (c FlushallAsyncSync) Build() Completed {
	return completed(c)
}

// Remove all keys from the current database.
//
// Time complexity: O(N) where N is the number of keys in the selected database
type Flushdb Base

// Remove all keys from the current database
//
// Command: FLUSHDB.
//
// Time complexity: O(N) where N is the number of keys in the selected database
func (b Builder) Flushdb() Flushdb {
	c := Flushdb{command: emptyCommand(), cslot: b.slot}
	c.command.append("FLUSHDB")
	return c
}

func (c Flushdb) Async() FlushdbAsync {
	c.command.append("ASYNC")
	return FlushdbAsync(c)
}

func (c Flushdb) Sync() FlushdbAsyncSync {
	c.command.append("SYNC")
	return FlushdbAsyncSync(c)
}

// Return Completed Redis command.
func (c Flushdb) Build() Completed {
	return completed(c)
}

type FlushdbAsync Base

// Return Completed Redis command.
func (c FlushdbAsync) Build() Completed {
	return completed(c)
}

type FlushdbAsyncSync Base

// Return Completed Redis command.
func (c FlushdbAsyncSync) Build() Completed {
	return completed(c)
}

// Adds terms to a dictionary.
//
// Time complexity: O(1)
type FtAggregate Base

// Adds terms to a dictionary
//
// Command: FT.AGGREGATE.
//
// Time complexity: O(1)
func (b Builder) FtAggregate() FtAggregate {
	c := FtAggregate{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.AGGREGATE")
	return c
}

func (c FtAggregate) Index(index string) FtAggregateIndex {
	c.command.append(index)
	return FtAggregateIndex(c)
}

type FtAggregateCursorCount Base

func (c FtAggregateCursorCount) Maxidle(idleTime int64) FtAggregateCursorMaxidle {
	c.command.append("MAXIDLE", strconv.FormatInt(idleTime, 10))
	return FtAggregateCursorMaxidle(c)
}

func (c FtAggregateCursorCount) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateCursorCount) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateCursorCount) Build() Completed {
	return completed(c)
}

type FtAggregateCursorMaxidle Base

func (c FtAggregateCursorMaxidle) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateCursorMaxidle) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateCursorMaxidle) Build() Completed {
	return completed(c)
}

type FtAggregateCursorWithcursor Base

func (c FtAggregateCursorWithcursor) Count(readSize int64) FtAggregateCursorCount {
	c.command.append("COUNT", strconv.FormatInt(readSize, 10))
	return FtAggregateCursorCount(c)
}

func (c FtAggregateCursorWithcursor) Maxidle(idleTime int64) FtAggregateCursorMaxidle {
	c.command.append("MAXIDLE", strconv.FormatInt(idleTime, 10))
	return FtAggregateCursorMaxidle(c)
}

func (c FtAggregateCursorWithcursor) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateCursorWithcursor) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateCursorWithcursor) Build() Completed {
	return completed(c)
}

type FtAggregateDialect Base

// Return Completed Redis command.
func (c FtAggregateDialect) Build() Completed {
	return completed(c)
}

type FtAggregateIndex Base

func (c FtAggregateIndex) Query(query string) FtAggregateQuery {
	c.command.append(query)
	return FtAggregateQuery(c)
}

type FtAggregateLoadField Base

func (c FtAggregateLoadField) Field(field ...string) FtAggregateLoadField {
	c.command.append(field...)
	return c
}

func (c FtAggregateLoadField) Timeout(timeout int64) FtAggregateTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtAggregateTimeout(c)
}

func (c FtAggregateLoadField) LoadAll() FtAggregateLoadallLoadAll {
	c.command.append("LOAD", "*")
	return FtAggregateLoadallLoadAll(c)
}

func (c FtAggregateLoadField) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateLoadField) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateLoadField) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateLoadField) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateLoadField) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateLoadField) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateLoadField) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateLoadField) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateLoadField) Build() Completed {
	return completed(c)
}

type FtAggregateLoadLoad Base

func (c FtAggregateLoadLoad) Field(field ...string) FtAggregateLoadField {
	c.command.append(field...)
	return FtAggregateLoadField(c)
}

type FtAggregateLoadallLoadAll Base

func (c FtAggregateLoadallLoadAll) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateLoadallLoadAll) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateLoadallLoadAll) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateLoadallLoadAll) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateLoadallLoadAll) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateLoadallLoadAll) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateLoadallLoadAll) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateLoadallLoadAll) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateLoadallLoadAll) Build() Completed {
	return completed(c)
}

type FtAggregateOpApplyApply Base

func (c FtAggregateOpApplyApply) As(name string) FtAggregateOpApplyAs {
	c.command.append("AS", name)
	return FtAggregateOpApplyAs(c)
}

type FtAggregateOpApplyAs Base

func (c FtAggregateOpApplyAs) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpApplyAs) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpApplyAs) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateOpApplyAs) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateOpApplyAs) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateOpApplyAs) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpApplyAs) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpApplyAs) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpApplyAs) Build() Completed {
	return completed(c)
}

type FtAggregateOpFilter Base

func (c FtAggregateOpFilter) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateOpFilter) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateOpFilter) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpFilter) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpFilter) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return c
}

func (c FtAggregateOpFilter) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpFilter) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpFilter) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpFilter) Build() Completed {
	return completed(c)
}

type FtAggregateOpGroupbyGroupby Base

func (c FtAggregateOpGroupbyGroupby) Property(property ...string) FtAggregateOpGroupbyProperty {
	c.command.append(property...)
	return FtAggregateOpGroupbyProperty(c)
}

func (c FtAggregateOpGroupbyGroupby) Reduce(function string) FtAggregateOpGroupbyReduceReduce {
	c.command.append("REDUCE", function)
	return FtAggregateOpGroupbyReduceReduce(c)
}

func (c FtAggregateOpGroupbyGroupby) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return c
}

func (c FtAggregateOpGroupbyGroupby) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateOpGroupbyGroupby) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpGroupbyGroupby) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpGroupbyGroupby) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateOpGroupbyGroupby) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpGroupbyGroupby) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpGroupbyGroupby) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpGroupbyGroupby) Build() Completed {
	return completed(c)
}

type FtAggregateOpGroupbyProperty Base

func (c FtAggregateOpGroupbyProperty) Property(property ...string) FtAggregateOpGroupbyProperty {
	c.command.append(property...)
	return c
}

func (c FtAggregateOpGroupbyProperty) Reduce(function string) FtAggregateOpGroupbyReduceReduce {
	c.command.append("REDUCE", function)
	return FtAggregateOpGroupbyReduceReduce(c)
}

func (c FtAggregateOpGroupbyProperty) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateOpGroupbyProperty) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateOpGroupbyProperty) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpGroupbyProperty) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpGroupbyProperty) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateOpGroupbyProperty) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpGroupbyProperty) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpGroupbyProperty) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpGroupbyProperty) Build() Completed {
	return completed(c)
}

type FtAggregateOpGroupbyReduceArg Base

func (c FtAggregateOpGroupbyReduceArg) Arg(arg ...string) FtAggregateOpGroupbyReduceArg {
	c.command.append(arg...)
	return c
}

func (c FtAggregateOpGroupbyReduceArg) As(name string) FtAggregateOpGroupbyReduceAs {
	c.command.append("AS", name)
	return FtAggregateOpGroupbyReduceAs(c)
}

func (c FtAggregateOpGroupbyReduceArg) By(by string) FtAggregateOpGroupbyReduceBy {
	c.command.append("BY", by)
	return FtAggregateOpGroupbyReduceBy(c)
}

func (c FtAggregateOpGroupbyReduceArg) Asc() FtAggregateOpGroupbyReduceOrderAsc {
	c.command.append("ASC")
	return FtAggregateOpGroupbyReduceOrderAsc(c)
}

func (c FtAggregateOpGroupbyReduceArg) Desc() FtAggregateOpGroupbyReduceOrderDesc {
	c.command.append("DESC")
	return FtAggregateOpGroupbyReduceOrderDesc(c)
}

func (c FtAggregateOpGroupbyReduceArg) Reduce(function string) FtAggregateOpGroupbyReduceReduce {
	c.command.append("REDUCE", function)
	return FtAggregateOpGroupbyReduceReduce(c)
}

func (c FtAggregateOpGroupbyReduceArg) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateOpGroupbyReduceArg) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateOpGroupbyReduceArg) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpGroupbyReduceArg) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpGroupbyReduceArg) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateOpGroupbyReduceArg) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpGroupbyReduceArg) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpGroupbyReduceArg) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpGroupbyReduceArg) Build() Completed {
	return completed(c)
}

type FtAggregateOpGroupbyReduceAs Base

func (c FtAggregateOpGroupbyReduceAs) By(by string) FtAggregateOpGroupbyReduceBy {
	c.command.append("BY", by)
	return FtAggregateOpGroupbyReduceBy(c)
}

func (c FtAggregateOpGroupbyReduceAs) Asc() FtAggregateOpGroupbyReduceOrderAsc {
	c.command.append("ASC")
	return FtAggregateOpGroupbyReduceOrderAsc(c)
}

func (c FtAggregateOpGroupbyReduceAs) Desc() FtAggregateOpGroupbyReduceOrderDesc {
	c.command.append("DESC")
	return FtAggregateOpGroupbyReduceOrderDesc(c)
}

func (c FtAggregateOpGroupbyReduceAs) Reduce(function string) FtAggregateOpGroupbyReduceReduce {
	c.command.append("REDUCE", function)
	return FtAggregateOpGroupbyReduceReduce(c)
}

func (c FtAggregateOpGroupbyReduceAs) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateOpGroupbyReduceAs) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateOpGroupbyReduceAs) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpGroupbyReduceAs) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpGroupbyReduceAs) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateOpGroupbyReduceAs) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpGroupbyReduceAs) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpGroupbyReduceAs) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpGroupbyReduceAs) Build() Completed {
	return completed(c)
}

type FtAggregateOpGroupbyReduceBy Base

func (c FtAggregateOpGroupbyReduceBy) Asc() FtAggregateOpGroupbyReduceOrderAsc {
	c.command.append("ASC")
	return FtAggregateOpGroupbyReduceOrderAsc(c)
}

func (c FtAggregateOpGroupbyReduceBy) Desc() FtAggregateOpGroupbyReduceOrderDesc {
	c.command.append("DESC")
	return FtAggregateOpGroupbyReduceOrderDesc(c)
}

func (c FtAggregateOpGroupbyReduceBy) Reduce(function string) FtAggregateOpGroupbyReduceReduce {
	c.command.append("REDUCE", function)
	return FtAggregateOpGroupbyReduceReduce(c)
}

func (c FtAggregateOpGroupbyReduceBy) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateOpGroupbyReduceBy) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateOpGroupbyReduceBy) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpGroupbyReduceBy) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpGroupbyReduceBy) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateOpGroupbyReduceBy) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpGroupbyReduceBy) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpGroupbyReduceBy) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpGroupbyReduceBy) Build() Completed {
	return completed(c)
}

type FtAggregateOpGroupbyReduceNargs Base

func (c FtAggregateOpGroupbyReduceNargs) Arg(arg ...string) FtAggregateOpGroupbyReduceArg {
	c.command.append(arg...)
	return FtAggregateOpGroupbyReduceArg(c)
}

func (c FtAggregateOpGroupbyReduceNargs) As(name string) FtAggregateOpGroupbyReduceAs {
	c.command.append("AS", name)
	return FtAggregateOpGroupbyReduceAs(c)
}

func (c FtAggregateOpGroupbyReduceNargs) By(by string) FtAggregateOpGroupbyReduceBy {
	c.command.append("BY", by)
	return FtAggregateOpGroupbyReduceBy(c)
}

func (c FtAggregateOpGroupbyReduceNargs) Asc() FtAggregateOpGroupbyReduceOrderAsc {
	c.command.append("ASC")
	return FtAggregateOpGroupbyReduceOrderAsc(c)
}

func (c FtAggregateOpGroupbyReduceNargs) Desc() FtAggregateOpGroupbyReduceOrderDesc {
	c.command.append("DESC")
	return FtAggregateOpGroupbyReduceOrderDesc(c)
}

func (c FtAggregateOpGroupbyReduceNargs) Reduce(function string) FtAggregateOpGroupbyReduceReduce {
	c.command.append("REDUCE", function)
	return FtAggregateOpGroupbyReduceReduce(c)
}

func (c FtAggregateOpGroupbyReduceNargs) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateOpGroupbyReduceNargs) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateOpGroupbyReduceNargs) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpGroupbyReduceNargs) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpGroupbyReduceNargs) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateOpGroupbyReduceNargs) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpGroupbyReduceNargs) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpGroupbyReduceNargs) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpGroupbyReduceNargs) Build() Completed {
	return completed(c)
}

type FtAggregateOpGroupbyReduceOrderAsc Base

func (c FtAggregateOpGroupbyReduceOrderAsc) Reduce(function string) FtAggregateOpGroupbyReduceReduce {
	c.command.append("REDUCE", function)
	return FtAggregateOpGroupbyReduceReduce(c)
}

func (c FtAggregateOpGroupbyReduceOrderAsc) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateOpGroupbyReduceOrderAsc) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateOpGroupbyReduceOrderAsc) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpGroupbyReduceOrderAsc) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpGroupbyReduceOrderAsc) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateOpGroupbyReduceOrderAsc) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpGroupbyReduceOrderAsc) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpGroupbyReduceOrderAsc) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpGroupbyReduceOrderAsc) Build() Completed {
	return completed(c)
}

type FtAggregateOpGroupbyReduceOrderDesc Base

func (c FtAggregateOpGroupbyReduceOrderDesc) Reduce(function string) FtAggregateOpGroupbyReduceReduce {
	c.command.append("REDUCE", function)
	return FtAggregateOpGroupbyReduceReduce(c)
}

func (c FtAggregateOpGroupbyReduceOrderDesc) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateOpGroupbyReduceOrderDesc) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateOpGroupbyReduceOrderDesc) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpGroupbyReduceOrderDesc) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpGroupbyReduceOrderDesc) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateOpGroupbyReduceOrderDesc) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpGroupbyReduceOrderDesc) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpGroupbyReduceOrderDesc) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpGroupbyReduceOrderDesc) Build() Completed {
	return completed(c)
}

type FtAggregateOpGroupbyReduceReduce Base

func (c FtAggregateOpGroupbyReduceReduce) Nargs(nargs int64) FtAggregateOpGroupbyReduceNargs {
	c.command.append(strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyReduceNargs(c)
}

type FtAggregateOpLimitLimit Base

func (c FtAggregateOpLimitLimit) OffsetNum(offset int64, num int64) FtAggregateOpLimitOffsetNum {
	c.command.append(strconv.FormatInt(offset, 10), strconv.FormatInt(num, 10))
	return FtAggregateOpLimitOffsetNum(c)
}

type FtAggregateOpLimitOffsetNum Base

func (c FtAggregateOpLimitOffsetNum) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateOpLimitOffsetNum) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateOpLimitOffsetNum) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateOpLimitOffsetNum) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpLimitOffsetNum) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpLimitOffsetNum) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpLimitOffsetNum) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpLimitOffsetNum) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpLimitOffsetNum) Build() Completed {
	return completed(c)
}

type FtAggregateOpSortbyFieldsOrderAsc Base

func (c FtAggregateOpSortbyFieldsOrderAsc) Property(property string) FtAggregateOpSortbyFieldsProperty {
	c.command.append(property)
	return FtAggregateOpSortbyFieldsProperty(c)
}

func (c FtAggregateOpSortbyFieldsOrderAsc) Max(num int64) FtAggregateOpSortbyMax {
	c.command.append("MAX", strconv.FormatInt(num, 10))
	return FtAggregateOpSortbyMax(c)
}

func (c FtAggregateOpSortbyFieldsOrderAsc) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpSortbyFieldsOrderAsc) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpSortbyFieldsOrderAsc) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateOpSortbyFieldsOrderAsc) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateOpSortbyFieldsOrderAsc) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateOpSortbyFieldsOrderAsc) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpSortbyFieldsOrderAsc) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpSortbyFieldsOrderAsc) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpSortbyFieldsOrderAsc) Build() Completed {
	return completed(c)
}

type FtAggregateOpSortbyFieldsOrderDesc Base

func (c FtAggregateOpSortbyFieldsOrderDesc) Property(property string) FtAggregateOpSortbyFieldsProperty {
	c.command.append(property)
	return FtAggregateOpSortbyFieldsProperty(c)
}

func (c FtAggregateOpSortbyFieldsOrderDesc) Max(num int64) FtAggregateOpSortbyMax {
	c.command.append("MAX", strconv.FormatInt(num, 10))
	return FtAggregateOpSortbyMax(c)
}

func (c FtAggregateOpSortbyFieldsOrderDesc) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpSortbyFieldsOrderDesc) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpSortbyFieldsOrderDesc) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateOpSortbyFieldsOrderDesc) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateOpSortbyFieldsOrderDesc) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateOpSortbyFieldsOrderDesc) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpSortbyFieldsOrderDesc) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpSortbyFieldsOrderDesc) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpSortbyFieldsOrderDesc) Build() Completed {
	return completed(c)
}

type FtAggregateOpSortbyFieldsProperty Base

func (c FtAggregateOpSortbyFieldsProperty) Asc() FtAggregateOpSortbyFieldsOrderAsc {
	c.command.append("ASC")
	return FtAggregateOpSortbyFieldsOrderAsc(c)
}

func (c FtAggregateOpSortbyFieldsProperty) Desc() FtAggregateOpSortbyFieldsOrderDesc {
	c.command.append("DESC")
	return FtAggregateOpSortbyFieldsOrderDesc(c)
}

func (c FtAggregateOpSortbyFieldsProperty) Property(property string) FtAggregateOpSortbyFieldsProperty {
	c.command.append(property)
	return c
}

func (c FtAggregateOpSortbyFieldsProperty) Max(num int64) FtAggregateOpSortbyMax {
	c.command.append("MAX", strconv.FormatInt(num, 10))
	return FtAggregateOpSortbyMax(c)
}

func (c FtAggregateOpSortbyFieldsProperty) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpSortbyFieldsProperty) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpSortbyFieldsProperty) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateOpSortbyFieldsProperty) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateOpSortbyFieldsProperty) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateOpSortbyFieldsProperty) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpSortbyFieldsProperty) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpSortbyFieldsProperty) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpSortbyFieldsProperty) Build() Completed {
	return completed(c)
}

type FtAggregateOpSortbyMax Base

func (c FtAggregateOpSortbyMax) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpSortbyMax) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpSortbyMax) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateOpSortbyMax) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateOpSortbyMax) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateOpSortbyMax) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpSortbyMax) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpSortbyMax) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpSortbyMax) Build() Completed {
	return completed(c)
}

type FtAggregateOpSortbySortby Base

func (c FtAggregateOpSortbySortby) Property(property string) FtAggregateOpSortbyFieldsProperty {
	c.command.append(property)
	return FtAggregateOpSortbyFieldsProperty(c)
}

func (c FtAggregateOpSortbySortby) Max(num int64) FtAggregateOpSortbyMax {
	c.command.append("MAX", strconv.FormatInt(num, 10))
	return FtAggregateOpSortbyMax(c)
}

func (c FtAggregateOpSortbySortby) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateOpSortbySortby) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateOpSortbySortby) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateOpSortbySortby) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateOpSortbySortby) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return c
}

func (c FtAggregateOpSortbySortby) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateOpSortbySortby) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateOpSortbySortby) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateOpSortbySortby) Build() Completed {
	return completed(c)
}

type FtAggregateParamsNameValue Base

func (c FtAggregateParamsNameValue) NameValue(name string, value string) FtAggregateParamsNameValue {
	c.command.append(name, value)
	return c
}

func (c FtAggregateParamsNameValue) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateParamsNameValue) Build() Completed {
	return completed(c)
}

type FtAggregateParamsNargs Base

func (c FtAggregateParamsNargs) NameValue() FtAggregateParamsNameValue {
	return FtAggregateParamsNameValue(c)
}

type FtAggregateParamsParams Base

func (c FtAggregateParamsParams) Nargs(nargs int64) FtAggregateParamsNargs {
	c.command.append(strconv.FormatInt(nargs, 10))
	return FtAggregateParamsNargs(c)
}

type FtAggregateQuery Base

func (c FtAggregateQuery) Verbatim() FtAggregateVerbatim {
	c.command.append("VERBATIM")
	return FtAggregateVerbatim(c)
}

func (c FtAggregateQuery) Load(count string) FtAggregateLoadLoad {
	c.command.append("LOAD", count)
	return FtAggregateLoadLoad(c)
}

func (c FtAggregateQuery) Timeout(timeout int64) FtAggregateTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtAggregateTimeout(c)
}

func (c FtAggregateQuery) LoadAll() FtAggregateLoadallLoadAll {
	c.command.append("LOAD", "*")
	return FtAggregateLoadallLoadAll(c)
}

func (c FtAggregateQuery) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateQuery) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateQuery) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateQuery) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateQuery) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateQuery) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateQuery) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateQuery) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateQuery) Build() Completed {
	return completed(c)
}

type FtAggregateTimeout Base

func (c FtAggregateTimeout) LoadAll() FtAggregateLoadallLoadAll {
	c.command.append("LOAD", "*")
	return FtAggregateLoadallLoadAll(c)
}

func (c FtAggregateTimeout) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateTimeout) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateTimeout) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateTimeout) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateTimeout) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateTimeout) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateTimeout) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateTimeout) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateTimeout) Build() Completed {
	return completed(c)
}

type FtAggregateVerbatim Base

func (c FtAggregateVerbatim) Load(count string) FtAggregateLoadLoad {
	c.command.append("LOAD", count)
	return FtAggregateLoadLoad(c)
}

func (c FtAggregateVerbatim) Timeout(timeout int64) FtAggregateTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtAggregateTimeout(c)
}

func (c FtAggregateVerbatim) LoadAll() FtAggregateLoadallLoadAll {
	c.command.append("LOAD", "*")
	return FtAggregateLoadallLoadAll(c)
}

func (c FtAggregateVerbatim) Groupby(nargs int64) FtAggregateOpGroupbyGroupby {
	c.command.append("GROUPBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpGroupbyGroupby(c)
}

func (c FtAggregateVerbatim) Sortby(nargs int64) FtAggregateOpSortbySortby {
	c.command.append("SORTBY", strconv.FormatInt(nargs, 10))
	return FtAggregateOpSortbySortby(c)
}

func (c FtAggregateVerbatim) Apply(expression string) FtAggregateOpApplyApply {
	c.command.append("APPLY", expression)
	return FtAggregateOpApplyApply(c)
}

func (c FtAggregateVerbatim) Limit() FtAggregateOpLimitLimit {
	c.command.append("LIMIT")
	return FtAggregateOpLimitLimit(c)
}

func (c FtAggregateVerbatim) Filter(filter string) FtAggregateOpFilter {
	c.command.append("FILTER", filter)
	return FtAggregateOpFilter(c)
}

func (c FtAggregateVerbatim) Withcursor() FtAggregateCursorWithcursor {
	c.command.append("WITHCURSOR")
	return FtAggregateCursorWithcursor(c)
}

func (c FtAggregateVerbatim) Params() FtAggregateParamsParams {
	c.command.append("PARAMS")
	return FtAggregateParamsParams(c)
}

func (c FtAggregateVerbatim) Dialect(dialect int64) FtAggregateDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtAggregateDialect(c)
}

// Return Completed Redis command.
func (c FtAggregateVerbatim) Build() Completed {
	return completed(c)
}

// Adds an alias to the index.
//
// Time complexity: O(1)
type FtAliasadd Base

// Adds an alias to the index
//
// Command: FT.ALIASADD.
//
// Time complexity: O(1)
func (b Builder) FtAliasadd() FtAliasadd {
	c := FtAliasadd{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.ALIASADD")
	return c
}

func (c FtAliasadd) Alias(alias string) FtAliasaddAlias {
	c.command.append(alias)
	return FtAliasaddAlias(c)
}

type FtAliasaddAlias Base

func (c FtAliasaddAlias) Index(index string) FtAliasaddIndex {
	c.command.append(index)
	return FtAliasaddIndex(c)
}

type FtAliasaddIndex Base

// Return Completed Redis command.
func (c FtAliasaddIndex) Build() Completed {
	return completed(c)
}

// Deletes an alias from the index.
//
// Time complexity: O(1)
type FtAliasdel Base

// Deletes an alias from the index
//
// Command: FT.ALIASDEL.
//
// Time complexity: O(1)
func (b Builder) FtAliasdel() FtAliasdel {
	c := FtAliasdel{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.ALIASDEL")
	return c
}

func (c FtAliasdel) Alias(alias string) FtAliasdelAlias {
	c.command.append(alias)
	return FtAliasdelAlias(c)
}

type FtAliasdelAlias Base

// Return Completed Redis command.
func (c FtAliasdelAlias) Build() Completed {
	return completed(c)
}

// Adds or updates an alias to the index.
//
// Time complexity: O(1)
type FtAliasupdate Base

// Adds or updates an alias to the index
//
// Command: FT.ALIASUPDATE.
//
// Time complexity: O(1)
func (b Builder) FtAliasupdate() FtAliasupdate {
	c := FtAliasupdate{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.ALIASUPDATE")
	return c
}

func (c FtAliasupdate) Alias(alias string) FtAliasupdateAlias {
	c.command.append(alias)
	return FtAliasupdateAlias(c)
}

type FtAliasupdateAlias Base

func (c FtAliasupdateAlias) Index(index string) FtAliasupdateIndex {
	c.command.append(index)
	return FtAliasupdateIndex(c)
}

type FtAliasupdateIndex Base

// Return Completed Redis command.
func (c FtAliasupdateIndex) Build() Completed {
	return completed(c)
}

// Adds a new field to the index.
//
// Time complexity: O(N) where N is the number of keys in the keyspace
type FtAlter Base

// Adds a new field to the index
//
// Command: FT.ALTER.
//
// Time complexity: O(N) where N is the number of keys in the keyspace
func (b Builder) FtAlter() FtAlter {
	c := FtAlter{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.ALTER")
	return c
}

func (c FtAlter) Index(index string) FtAlterIndex {
	c.command.append(index)
	return FtAlterIndex(c)
}

type FtAlterAdd Base

func (c FtAlterAdd) Field(field string) FtAlterField {
	c.command.append(field)
	return FtAlterField(c)
}

type FtAlterField Base

func (c FtAlterField) Options(options string) FtAlterOptions {
	c.command.append(options)
	return FtAlterOptions(c)
}

type FtAlterIndex Base

func (c FtAlterIndex) Skipinitialscan() FtAlterSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtAlterSkipinitialscan(c)
}

func (c FtAlterIndex) Schema() FtAlterSchema {
	c.command.append("SCHEMA")
	return FtAlterSchema(c)
}

type FtAlterOptions Base

// Return Completed Redis command.
func (c FtAlterOptions) Build() Completed {
	return completed(c)
}

type FtAlterSchema Base

func (c FtAlterSchema) Add() FtAlterAdd {
	c.command.append("ADD")
	return FtAlterAdd(c)
}

type FtAlterSkipinitialscan Base

func (c FtAlterSkipinitialscan) Schema() FtAlterSchema {
	c.command.append("SCHEMA")
	return FtAlterSchema(c)
}

// Retrieves runtime configuration options.
//
// Time complexity: O(1)
type FtConfigGet Base

// Retrieves runtime configuration options
//
// Command: FT.CONFIG GET.
//
// Time complexity: O(1)
func (b Builder) FtConfigGet() FtConfigGet {
	c := FtConfigGet{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.CONFIG", "GET")
	return c
}

func (c FtConfigGet) Option(option string) FtConfigGetOption {
	c.command.append(option)
	return FtConfigGetOption(c)
}

type FtConfigGetOption Base

// Return Completed Redis command.
func (c FtConfigGetOption) Build() Completed {
	return completed(c)
}

// Help description of runtime configuration options.
//
// Time complexity: O(1)
type FtConfigHelp Base

// Help description of runtime configuration options
//
// Command: FT.CONFIG HELP.
//
// Time complexity: O(1)
func (b Builder) FtConfigHelp() FtConfigHelp {
	c := FtConfigHelp{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.CONFIG", "HELP")
	return c
}

func (c FtConfigHelp) Option(option string) FtConfigHelpOption {
	c.command.append(option)
	return FtConfigHelpOption(c)
}

type FtConfigHelpOption Base

// Return Completed Redis command.
func (c FtConfigHelpOption) Build() Completed {
	return completed(c)
}

// Sets runtime configuration options.
//
// Time complexity: O(1)
type FtConfigSet Base

// Sets runtime configuration options
//
// Command: FT.CONFIG SET.
//
// Time complexity: O(1)
func (b Builder) FtConfigSet() FtConfigSet {
	c := FtConfigSet{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.CONFIG", "SET")
	return c
}

func (c FtConfigSet) Option(option string) FtConfigSetOption {
	c.command.append(option)
	return FtConfigSetOption(c)
}

type FtConfigSetOption Base

func (c FtConfigSetOption) Value(value string) FtConfigSetValue {
	c.command.append(value)
	return FtConfigSetValue(c)
}

type FtConfigSetValue Base

// Return Completed Redis command.
func (c FtConfigSetValue) Build() Completed {
	return completed(c)
}

// Creates an index with the given spec.
//
// Time complexity:
//   - O(K) at creation where K is the number of fields,
//   - O(N) if scanning the keyspace is triggered, where N is the number of keys in the keyspace
type FtCreate Base

// Creates an index with the given spec
//
// Command: FT.CREATE.
//
// Time complexity:
//   - O(K) at creation where K is the number of fields,
//   - O(N) if scanning the keyspace is triggered, where N is the number of keys in the keyspace
func (b Builder) FtCreate() FtCreate {
	c := FtCreate{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.CREATE")
	return c
}

func (c FtCreate) Index(index string) FtCreateIndex {
	c.command.append(index)
	return FtCreateIndex(c)
}

type FtCreateFieldAs Base

func (c FtCreateFieldAs) Text() FtCreateFieldFieldTypeText {
	c.command.append("TEXT")
	return FtCreateFieldFieldTypeText(c)
}

func (c FtCreateFieldAs) Tag() FtCreateFieldFieldTypeTag {
	c.command.append("TAG")
	return FtCreateFieldFieldTypeTag(c)
}

func (c FtCreateFieldAs) Numeric() FtCreateFieldFieldTypeNumeric {
	c.command.append("NUMERIC")
	return FtCreateFieldFieldTypeNumeric(c)
}

func (c FtCreateFieldAs) Geo() FtCreateFieldFieldTypeGeo {
	c.command.append("GEO")
	return FtCreateFieldFieldTypeGeo(c)
}

func (c FtCreateFieldAs) Vector(algo string, nargs int64, args ...string) FtCreateFieldFieldTypeVector {
	c.command.append("VECTOR", algo, strconv.FormatInt(nargs, 10))
	c.command.append(args...)
	return FtCreateFieldFieldTypeVector(c)
}

type FtCreateFieldFieldName Base

func (c FtCreateFieldFieldName) As(alias string) FtCreateFieldAs {
	c.command.append("AS", alias)
	return FtCreateFieldAs(c)
}

func (c FtCreateFieldFieldName) Text() FtCreateFieldFieldTypeText {
	c.command.append("TEXT")
	return FtCreateFieldFieldTypeText(c)
}

func (c FtCreateFieldFieldName) Tag() FtCreateFieldFieldTypeTag {
	c.command.append("TAG")
	return FtCreateFieldFieldTypeTag(c)
}

func (c FtCreateFieldFieldName) Numeric() FtCreateFieldFieldTypeNumeric {
	c.command.append("NUMERIC")
	return FtCreateFieldFieldTypeNumeric(c)
}

func (c FtCreateFieldFieldName) Geo() FtCreateFieldFieldTypeGeo {
	c.command.append("GEO")
	return FtCreateFieldFieldTypeGeo(c)
}

func (c FtCreateFieldFieldName) Vector(algo string, nargs int64, args ...string) FtCreateFieldFieldTypeVector {
	c.command.append("VECTOR", algo, strconv.FormatInt(nargs, 10))
	c.command.append(args...)
	return FtCreateFieldFieldTypeVector(c)
}

type FtCreateFieldFieldTypeGeo Base

func (c FtCreateFieldFieldTypeGeo) Withsuffixtrie() FtCreateFieldOptionWithsuffixtrie {
	c.command.append("WITHSUFFIXTRIE")
	return FtCreateFieldOptionWithsuffixtrie(c)
}

func (c FtCreateFieldFieldTypeGeo) Sortable() FtCreateFieldOptionSortableSortable {
	c.command.append("SORTABLE")
	return FtCreateFieldOptionSortableSortable(c)
}

func (c FtCreateFieldFieldTypeGeo) Noindex() FtCreateFieldOptionNoindex {
	c.command.append("NOINDEX")
	return FtCreateFieldOptionNoindex(c)
}

func (c FtCreateFieldFieldTypeGeo) Nostem() FtCreateFieldOptionNostem {
	c.command.append("NOSTEM")
	return FtCreateFieldOptionNostem(c)
}

func (c FtCreateFieldFieldTypeGeo) Phonetic(phonetic string) FtCreateFieldOptionPhonetic {
	c.command.append("PHONETIC", phonetic)
	return FtCreateFieldOptionPhonetic(c)
}

func (c FtCreateFieldFieldTypeGeo) Weight(weight float64) FtCreateFieldOptionWeight {
	c.command.append("WEIGHT", strconv.FormatFloat(weight, 'f', -1, 64))
	return FtCreateFieldOptionWeight(c)
}

func (c FtCreateFieldFieldTypeGeo) Separator(separator string) FtCreateFieldOptionSeparator {
	c.command.append("SEPARATOR", separator)
	return FtCreateFieldOptionSeparator(c)
}

func (c FtCreateFieldFieldTypeGeo) Casesensitive() FtCreateFieldOptionCasesensitive {
	c.command.append("CASESENSITIVE")
	return FtCreateFieldOptionCasesensitive(c)
}

func (c FtCreateFieldFieldTypeGeo) FieldName(fieldName string) FtCreateFieldFieldName {
	c.command.append(fieldName)
	return FtCreateFieldFieldName(c)
}

// Return Completed Redis command.
func (c FtCreateFieldFieldTypeGeo) Build() Completed {
	return completed(c)
}

type FtCreateFieldFieldTypeNumeric Base

func (c FtCreateFieldFieldTypeNumeric) Withsuffixtrie() FtCreateFieldOptionWithsuffixtrie {
	c.command.append("WITHSUFFIXTRIE")
	return FtCreateFieldOptionWithsuffixtrie(c)
}

func (c FtCreateFieldFieldTypeNumeric) Sortable() FtCreateFieldOptionSortableSortable {
	c.command.append("SORTABLE")
	return FtCreateFieldOptionSortableSortable(c)
}

func (c FtCreateFieldFieldTypeNumeric) Noindex() FtCreateFieldOptionNoindex {
	c.command.append("NOINDEX")
	return FtCreateFieldOptionNoindex(c)
}

func (c FtCreateFieldFieldTypeNumeric) Nostem() FtCreateFieldOptionNostem {
	c.command.append("NOSTEM")
	return FtCreateFieldOptionNostem(c)
}

func (c FtCreateFieldFieldTypeNumeric) Phonetic(phonetic string) FtCreateFieldOptionPhonetic {
	c.command.append("PHONETIC", phonetic)
	return FtCreateFieldOptionPhonetic(c)
}

func (c FtCreateFieldFieldTypeNumeric) Weight(weight float64) FtCreateFieldOptionWeight {
	c.command.append("WEIGHT", strconv.FormatFloat(weight, 'f', -1, 64))
	return FtCreateFieldOptionWeight(c)
}

func (c FtCreateFieldFieldTypeNumeric) Separator(separator string) FtCreateFieldOptionSeparator {
	c.command.append("SEPARATOR", separator)
	return FtCreateFieldOptionSeparator(c)
}

func (c FtCreateFieldFieldTypeNumeric) Casesensitive() FtCreateFieldOptionCasesensitive {
	c.command.append("CASESENSITIVE")
	return FtCreateFieldOptionCasesensitive(c)
}

func (c FtCreateFieldFieldTypeNumeric) FieldName(fieldName string) FtCreateFieldFieldName {
	c.command.append(fieldName)
	return FtCreateFieldFieldName(c)
}

// Return Completed Redis command.
func (c FtCreateFieldFieldTypeNumeric) Build() Completed {
	return completed(c)
}

type FtCreateFieldFieldTypeTag Base

func (c FtCreateFieldFieldTypeTag) Withsuffixtrie() FtCreateFieldOptionWithsuffixtrie {
	c.command.append("WITHSUFFIXTRIE")
	return FtCreateFieldOptionWithsuffixtrie(c)
}

func (c FtCreateFieldFieldTypeTag) Sortable() FtCreateFieldOptionSortableSortable {
	c.command.append("SORTABLE")
	return FtCreateFieldOptionSortableSortable(c)
}

func (c FtCreateFieldFieldTypeTag) Noindex() FtCreateFieldOptionNoindex {
	c.command.append("NOINDEX")
	return FtCreateFieldOptionNoindex(c)
}

func (c FtCreateFieldFieldTypeTag) Nostem() FtCreateFieldOptionNostem {
	c.command.append("NOSTEM")
	return FtCreateFieldOptionNostem(c)
}

func (c FtCreateFieldFieldTypeTag) Phonetic(phonetic string) FtCreateFieldOptionPhonetic {
	c.command.append("PHONETIC", phonetic)
	return FtCreateFieldOptionPhonetic(c)
}

func (c FtCreateFieldFieldTypeTag) Weight(weight float64) FtCreateFieldOptionWeight {
	c.command.append("WEIGHT", strconv.FormatFloat(weight, 'f', -1, 64))
	return FtCreateFieldOptionWeight(c)
}

func (c FtCreateFieldFieldTypeTag) Separator(separator string) FtCreateFieldOptionSeparator {
	c.command.append("SEPARATOR", separator)
	return FtCreateFieldOptionSeparator(c)
}

func (c FtCreateFieldFieldTypeTag) Casesensitive() FtCreateFieldOptionCasesensitive {
	c.command.append("CASESENSITIVE")
	return FtCreateFieldOptionCasesensitive(c)
}

func (c FtCreateFieldFieldTypeTag) FieldName(fieldName string) FtCreateFieldFieldName {
	c.command.append(fieldName)
	return FtCreateFieldFieldName(c)
}

// Return Completed Redis command.
func (c FtCreateFieldFieldTypeTag) Build() Completed {
	return completed(c)
}

type FtCreateFieldFieldTypeText Base

func (c FtCreateFieldFieldTypeText) Withsuffixtrie() FtCreateFieldOptionWithsuffixtrie {
	c.command.append("WITHSUFFIXTRIE")
	return FtCreateFieldOptionWithsuffixtrie(c)
}

func (c FtCreateFieldFieldTypeText) Sortable() FtCreateFieldOptionSortableSortable {
	c.command.append("SORTABLE")
	return FtCreateFieldOptionSortableSortable(c)
}

func (c FtCreateFieldFieldTypeText) Noindex() FtCreateFieldOptionNoindex {
	c.command.append("NOINDEX")
	return FtCreateFieldOptionNoindex(c)
}

func (c FtCreateFieldFieldTypeText) Nostem() FtCreateFieldOptionNostem {
	c.command.append("NOSTEM")
	return FtCreateFieldOptionNostem(c)
}

func (c FtCreateFieldFieldTypeText) Phonetic(phonetic string) FtCreateFieldOptionPhonetic {
	c.command.append("PHONETIC", phonetic)
	return FtCreateFieldOptionPhonetic(c)
}

func (c FtCreateFieldFieldTypeText) Weight(weight float64) FtCreateFieldOptionWeight {
	c.command.append("WEIGHT", strconv.FormatFloat(weight, 'f', -1, 64))
	return FtCreateFieldOptionWeight(c)
}

func (c FtCreateFieldFieldTypeText) Separator(separator string) FtCreateFieldOptionSeparator {
	c.command.append("SEPARATOR", separator)
	return FtCreateFieldOptionSeparator(c)
}

func (c FtCreateFieldFieldTypeText) Casesensitive() FtCreateFieldOptionCasesensitive {
	c.command.append("CASESENSITIVE")
	return FtCreateFieldOptionCasesensitive(c)
}

func (c FtCreateFieldFieldTypeText) FieldName(fieldName string) FtCreateFieldFieldName {
	c.command.append(fieldName)
	return FtCreateFieldFieldName(c)
}

// Return Completed Redis command.
func (c FtCreateFieldFieldTypeText) Build() Completed {
	return completed(c)
}

type FtCreateFieldFieldTypeVector Base

func (c FtCreateFieldFieldTypeVector) Withsuffixtrie() FtCreateFieldOptionWithsuffixtrie {
	c.command.append("WITHSUFFIXTRIE")
	return FtCreateFieldOptionWithsuffixtrie(c)
}

func (c FtCreateFieldFieldTypeVector) Sortable() FtCreateFieldOptionSortableSortable {
	c.command.append("SORTABLE")
	return FtCreateFieldOptionSortableSortable(c)
}

func (c FtCreateFieldFieldTypeVector) Noindex() FtCreateFieldOptionNoindex {
	c.command.append("NOINDEX")
	return FtCreateFieldOptionNoindex(c)
}

func (c FtCreateFieldFieldTypeVector) Nostem() FtCreateFieldOptionNostem {
	c.command.append("NOSTEM")
	return FtCreateFieldOptionNostem(c)
}

func (c FtCreateFieldFieldTypeVector) Phonetic(phonetic string) FtCreateFieldOptionPhonetic {
	c.command.append("PHONETIC", phonetic)
	return FtCreateFieldOptionPhonetic(c)
}

func (c FtCreateFieldFieldTypeVector) Weight(weight float64) FtCreateFieldOptionWeight {
	c.command.append("WEIGHT", strconv.FormatFloat(weight, 'f', -1, 64))
	return FtCreateFieldOptionWeight(c)
}

func (c FtCreateFieldFieldTypeVector) Separator(separator string) FtCreateFieldOptionSeparator {
	c.command.append("SEPARATOR", separator)
	return FtCreateFieldOptionSeparator(c)
}

func (c FtCreateFieldFieldTypeVector) Casesensitive() FtCreateFieldOptionCasesensitive {
	c.command.append("CASESENSITIVE")
	return FtCreateFieldOptionCasesensitive(c)
}

func (c FtCreateFieldFieldTypeVector) FieldName(fieldName string) FtCreateFieldFieldName {
	c.command.append(fieldName)
	return FtCreateFieldFieldName(c)
}

// Return Completed Redis command.
func (c FtCreateFieldFieldTypeVector) Build() Completed {
	return completed(c)
}

type FtCreateFieldOptionCasesensitive Base

func (c FtCreateFieldOptionCasesensitive) Withsuffixtrie() FtCreateFieldOptionWithsuffixtrie {
	c.command.append("WITHSUFFIXTRIE")
	return FtCreateFieldOptionWithsuffixtrie(c)
}

func (c FtCreateFieldOptionCasesensitive) Sortable() FtCreateFieldOptionSortableSortable {
	c.command.append("SORTABLE")
	return FtCreateFieldOptionSortableSortable(c)
}

func (c FtCreateFieldOptionCasesensitive) Noindex() FtCreateFieldOptionNoindex {
	c.command.append("NOINDEX")
	return FtCreateFieldOptionNoindex(c)
}

func (c FtCreateFieldOptionCasesensitive) Nostem() FtCreateFieldOptionNostem {
	c.command.append("NOSTEM")
	return FtCreateFieldOptionNostem(c)
}

func (c FtCreateFieldOptionCasesensitive) Phonetic(phonetic string) FtCreateFieldOptionPhonetic {
	c.command.append("PHONETIC", phonetic)
	return FtCreateFieldOptionPhonetic(c)
}

func (c FtCreateFieldOptionCasesensitive) Weight(weight float64) FtCreateFieldOptionWeight {
	c.command.append("WEIGHT", strconv.FormatFloat(weight, 'f', -1, 64))
	return FtCreateFieldOptionWeight(c)
}

func (c FtCreateFieldOptionCasesensitive) Separator(separator string) FtCreateFieldOptionSeparator {
	c.command.append("SEPARATOR", separator)
	return FtCreateFieldOptionSeparator(c)
}

func (c FtCreateFieldOptionCasesensitive) Casesensitive() FtCreateFieldOptionCasesensitive {
	c.command.append("CASESENSITIVE")
	return c
}

func (c FtCreateFieldOptionCasesensitive) FieldName(fieldName string) FtCreateFieldFieldName {
	c.command.append(fieldName)
	return FtCreateFieldFieldName(c)
}

// Return Completed Redis command.
func (c FtCreateFieldOptionCasesensitive) Build() Completed {
	return completed(c)
}

type FtCreateFieldOptionNoindex Base

func (c FtCreateFieldOptionNoindex) Nostem() FtCreateFieldOptionNostem {
	c.command.append("NOSTEM")
	return FtCreateFieldOptionNostem(c)
}

func (c FtCreateFieldOptionNoindex) Phonetic(phonetic string) FtCreateFieldOptionPhonetic {
	c.command.append("PHONETIC", phonetic)
	return FtCreateFieldOptionPhonetic(c)
}

func (c FtCreateFieldOptionNoindex) Weight(weight float64) FtCreateFieldOptionWeight {
	c.command.append("WEIGHT", strconv.FormatFloat(weight, 'f', -1, 64))
	return FtCreateFieldOptionWeight(c)
}

func (c FtCreateFieldOptionNoindex) Separator(separator string) FtCreateFieldOptionSeparator {
	c.command.append("SEPARATOR", separator)
	return FtCreateFieldOptionSeparator(c)
}

func (c FtCreateFieldOptionNoindex) Casesensitive() FtCreateFieldOptionCasesensitive {
	c.command.append("CASESENSITIVE")
	return FtCreateFieldOptionCasesensitive(c)
}

func (c FtCreateFieldOptionNoindex) Withsuffixtrie() FtCreateFieldOptionWithsuffixtrie {
	c.command.append("WITHSUFFIXTRIE")
	return FtCreateFieldOptionWithsuffixtrie(c)
}

func (c FtCreateFieldOptionNoindex) Sortable() FtCreateFieldOptionSortableSortable {
	c.command.append("SORTABLE")
	return FtCreateFieldOptionSortableSortable(c)
}

func (c FtCreateFieldOptionNoindex) Noindex() FtCreateFieldOptionNoindex {
	c.command.append("NOINDEX")
	return c
}

func (c FtCreateFieldOptionNoindex) FieldName(fieldName string) FtCreateFieldFieldName {
	c.command.append(fieldName)
	return FtCreateFieldFieldName(c)
}

// Return Completed Redis command.
func (c FtCreateFieldOptionNoindex) Build() Completed {
	return completed(c)
}

type FtCreateFieldOptionNostem Base

func (c FtCreateFieldOptionNostem) Phonetic(phonetic string) FtCreateFieldOptionPhonetic {
	c.command.append("PHONETIC", phonetic)
	return FtCreateFieldOptionPhonetic(c)
}

func (c FtCreateFieldOptionNostem) Weight(weight float64) FtCreateFieldOptionWeight {
	c.command.append("WEIGHT", strconv.FormatFloat(weight, 'f', -1, 64))
	return FtCreateFieldOptionWeight(c)
}

func (c FtCreateFieldOptionNostem) Separator(separator string) FtCreateFieldOptionSeparator {
	c.command.append("SEPARATOR", separator)
	return FtCreateFieldOptionSeparator(c)
}

func (c FtCreateFieldOptionNostem) Casesensitive() FtCreateFieldOptionCasesensitive {
	c.command.append("CASESENSITIVE")
	return FtCreateFieldOptionCasesensitive(c)
}

func (c FtCreateFieldOptionNostem) Withsuffixtrie() FtCreateFieldOptionWithsuffixtrie {
	c.command.append("WITHSUFFIXTRIE")
	return FtCreateFieldOptionWithsuffixtrie(c)
}

func (c FtCreateFieldOptionNostem) Sortable() FtCreateFieldOptionSortableSortable {
	c.command.append("SORTABLE")
	return FtCreateFieldOptionSortableSortable(c)
}

func (c FtCreateFieldOptionNostem) Noindex() FtCreateFieldOptionNoindex {
	c.command.append("NOINDEX")
	return FtCreateFieldOptionNoindex(c)
}

func (c FtCreateFieldOptionNostem) Nostem() FtCreateFieldOptionNostem {
	c.command.append("NOSTEM")
	return c
}

func (c FtCreateFieldOptionNostem) FieldName(fieldName string) FtCreateFieldFieldName {
	c.command.append(fieldName)
	return FtCreateFieldFieldName(c)
}

// Return Completed Redis command.
func (c FtCreateFieldOptionNostem) Build() Completed {
	return completed(c)
}

type FtCreateFieldOptionPhonetic Base

func (c FtCreateFieldOptionPhonetic) Weight(weight float64) FtCreateFieldOptionWeight {
	c.command.append("WEIGHT", strconv.FormatFloat(weight, 'f', -1, 64))
	return FtCreateFieldOptionWeight(c)
}

func (c FtCreateFieldOptionPhonetic) Separator(separator string) FtCreateFieldOptionSeparator {
	c.command.append("SEPARATOR", separator)
	return FtCreateFieldOptionSeparator(c)
}

func (c FtCreateFieldOptionPhonetic) Casesensitive() FtCreateFieldOptionCasesensitive {
	c.command.append("CASESENSITIVE")
	return FtCreateFieldOptionCasesensitive(c)
}

func (c FtCreateFieldOptionPhonetic) Withsuffixtrie() FtCreateFieldOptionWithsuffixtrie {
	c.command.append("WITHSUFFIXTRIE")
	return FtCreateFieldOptionWithsuffixtrie(c)
}

func (c FtCreateFieldOptionPhonetic) Sortable() FtCreateFieldOptionSortableSortable {
	c.command.append("SORTABLE")
	return FtCreateFieldOptionSortableSortable(c)
}

func (c FtCreateFieldOptionPhonetic) Noindex() FtCreateFieldOptionNoindex {
	c.command.append("NOINDEX")
	return FtCreateFieldOptionNoindex(c)
}

func (c FtCreateFieldOptionPhonetic) Nostem() FtCreateFieldOptionNostem {
	c.command.append("NOSTEM")
	return FtCreateFieldOptionNostem(c)
}

func (c FtCreateFieldOptionPhonetic) Phonetic(phonetic string) FtCreateFieldOptionPhonetic {
	c.command.append("PHONETIC", phonetic)
	return c
}

func (c FtCreateFieldOptionPhonetic) FieldName(fieldName string) FtCreateFieldFieldName {
	c.command.append(fieldName)
	return FtCreateFieldFieldName(c)
}

// Return Completed Redis command.
func (c FtCreateFieldOptionPhonetic) Build() Completed {
	return completed(c)
}

type FtCreateFieldOptionSeparator Base

func (c FtCreateFieldOptionSeparator) Casesensitive() FtCreateFieldOptionCasesensitive {
	c.command.append("CASESENSITIVE")
	return FtCreateFieldOptionCasesensitive(c)
}

func (c FtCreateFieldOptionSeparator) Withsuffixtrie() FtCreateFieldOptionWithsuffixtrie {
	c.command.append("WITHSUFFIXTRIE")
	return FtCreateFieldOptionWithsuffixtrie(c)
}

func (c FtCreateFieldOptionSeparator) Sortable() FtCreateFieldOptionSortableSortable {
	c.command.append("SORTABLE")
	return FtCreateFieldOptionSortableSortable(c)
}

func (c FtCreateFieldOptionSeparator) Noindex() FtCreateFieldOptionNoindex {
	c.command.append("NOINDEX")
	return FtCreateFieldOptionNoindex(c)
}

func (c FtCreateFieldOptionSeparator) Nostem() FtCreateFieldOptionNostem {
	c.command.append("NOSTEM")
	return FtCreateFieldOptionNostem(c)
}

func (c FtCreateFieldOptionSeparator) Phonetic(phonetic string) FtCreateFieldOptionPhonetic {
	c.command.append("PHONETIC", phonetic)
	return FtCreateFieldOptionPhonetic(c)
}

func (c FtCreateFieldOptionSeparator) Weight(weight float64) FtCreateFieldOptionWeight {
	c.command.append("WEIGHT", strconv.FormatFloat(weight, 'f', -1, 64))
	return FtCreateFieldOptionWeight(c)
}

func (c FtCreateFieldOptionSeparator) Separator(separator string) FtCreateFieldOptionSeparator {
	c.command.append("SEPARATOR", separator)
	return c
}

func (c FtCreateFieldOptionSeparator) FieldName(fieldName string) FtCreateFieldFieldName {
	c.command.append(fieldName)
	return FtCreateFieldFieldName(c)
}

// Return Completed Redis command.
func (c FtCreateFieldOptionSeparator) Build() Completed {
	return completed(c)
}

type FtCreateFieldOptionSortableSortable Base

func (c FtCreateFieldOptionSortableSortable) Unf() FtCreateFieldOptionSortableUnf {
	c.command.append("UNF")
	return FtCreateFieldOptionSortableUnf(c)
}

func (c FtCreateFieldOptionSortableSortable) Noindex() FtCreateFieldOptionNoindex {
	c.command.append("NOINDEX")
	return FtCreateFieldOptionNoindex(c)
}

func (c FtCreateFieldOptionSortableSortable) Nostem() FtCreateFieldOptionNostem {
	c.command.append("NOSTEM")
	return FtCreateFieldOptionNostem(c)
}

func (c FtCreateFieldOptionSortableSortable) Phonetic(phonetic string) FtCreateFieldOptionPhonetic {
	c.command.append("PHONETIC", phonetic)
	return FtCreateFieldOptionPhonetic(c)
}

func (c FtCreateFieldOptionSortableSortable) Weight(weight float64) FtCreateFieldOptionWeight {
	c.command.append("WEIGHT", strconv.FormatFloat(weight, 'f', -1, 64))
	return FtCreateFieldOptionWeight(c)
}

func (c FtCreateFieldOptionSortableSortable) Separator(separator string) FtCreateFieldOptionSeparator {
	c.command.append("SEPARATOR", separator)
	return FtCreateFieldOptionSeparator(c)
}

func (c FtCreateFieldOptionSortableSortable) Casesensitive() FtCreateFieldOptionCasesensitive {
	c.command.append("CASESENSITIVE")
	return FtCreateFieldOptionCasesensitive(c)
}

func (c FtCreateFieldOptionSortableSortable) Withsuffixtrie() FtCreateFieldOptionWithsuffixtrie {
	c.command.append("WITHSUFFIXTRIE")
	return FtCreateFieldOptionWithsuffixtrie(c)
}

func (c FtCreateFieldOptionSortableSortable) Sortable() FtCreateFieldOptionSortableSortable {
	c.command.append("SORTABLE")
	return c
}

func (c FtCreateFieldOptionSortableSortable) FieldName(fieldName string) FtCreateFieldFieldName {
	c.command.append(fieldName)
	return FtCreateFieldFieldName(c)
}

// Return Completed Redis command.
func (c FtCreateFieldOptionSortableSortable) Build() Completed {
	return completed(c)
}

type FtCreateFieldOptionSortableUnf Base

func (c FtCreateFieldOptionSortableUnf) Noindex() FtCreateFieldOptionNoindex {
	c.command.append("NOINDEX")
	return FtCreateFieldOptionNoindex(c)
}

func (c FtCreateFieldOptionSortableUnf) Nostem() FtCreateFieldOptionNostem {
	c.command.append("NOSTEM")
	return FtCreateFieldOptionNostem(c)
}

func (c FtCreateFieldOptionSortableUnf) Phonetic(phonetic string) FtCreateFieldOptionPhonetic {
	c.command.append("PHONETIC", phonetic)
	return FtCreateFieldOptionPhonetic(c)
}

func (c FtCreateFieldOptionSortableUnf) Weight(weight float64) FtCreateFieldOptionWeight {
	c.command.append("WEIGHT", strconv.FormatFloat(weight, 'f', -1, 64))
	return FtCreateFieldOptionWeight(c)
}

func (c FtCreateFieldOptionSortableUnf) Separator(separator string) FtCreateFieldOptionSeparator {
	c.command.append("SEPARATOR", separator)
	return FtCreateFieldOptionSeparator(c)
}

func (c FtCreateFieldOptionSortableUnf) Casesensitive() FtCreateFieldOptionCasesensitive {
	c.command.append("CASESENSITIVE")
	return FtCreateFieldOptionCasesensitive(c)
}

func (c FtCreateFieldOptionSortableUnf) Withsuffixtrie() FtCreateFieldOptionWithsuffixtrie {
	c.command.append("WITHSUFFIXTRIE")
	return FtCreateFieldOptionWithsuffixtrie(c)
}

func (c FtCreateFieldOptionSortableUnf) Sortable() FtCreateFieldOptionSortableSortable {
	c.command.append("SORTABLE")
	return FtCreateFieldOptionSortableSortable(c)
}

func (c FtCreateFieldOptionSortableUnf) FieldName(fieldName string) FtCreateFieldFieldName {
	c.command.append(fieldName)
	return FtCreateFieldFieldName(c)
}

// Return Completed Redis command.
func (c FtCreateFieldOptionSortableUnf) Build() Completed {
	return completed(c)
}

type FtCreateFieldOptionWeight Base

func (c FtCreateFieldOptionWeight) Separator(separator string) FtCreateFieldOptionSeparator {
	c.command.append("SEPARATOR", separator)
	return FtCreateFieldOptionSeparator(c)
}

func (c FtCreateFieldOptionWeight) Casesensitive() FtCreateFieldOptionCasesensitive {
	c.command.append("CASESENSITIVE")
	return FtCreateFieldOptionCasesensitive(c)
}

func (c FtCreateFieldOptionWeight) Withsuffixtrie() FtCreateFieldOptionWithsuffixtrie {
	c.command.append("WITHSUFFIXTRIE")
	return FtCreateFieldOptionWithsuffixtrie(c)
}

func (c FtCreateFieldOptionWeight) Sortable() FtCreateFieldOptionSortableSortable {
	c.command.append("SORTABLE")
	return FtCreateFieldOptionSortableSortable(c)
}

func (c FtCreateFieldOptionWeight) Noindex() FtCreateFieldOptionNoindex {
	c.command.append("NOINDEX")
	return FtCreateFieldOptionNoindex(c)
}

func (c FtCreateFieldOptionWeight) Nostem() FtCreateFieldOptionNostem {
	c.command.append("NOSTEM")
	return FtCreateFieldOptionNostem(c)
}

func (c FtCreateFieldOptionWeight) Phonetic(phonetic string) FtCreateFieldOptionPhonetic {
	c.command.append("PHONETIC", phonetic)
	return FtCreateFieldOptionPhonetic(c)
}

func (c FtCreateFieldOptionWeight) Weight(weight float64) FtCreateFieldOptionWeight {
	c.command.append("WEIGHT", strconv.FormatFloat(weight, 'f', -1, 64))
	return c
}

func (c FtCreateFieldOptionWeight) FieldName(fieldName string) FtCreateFieldFieldName {
	c.command.append(fieldName)
	return FtCreateFieldFieldName(c)
}

// Return Completed Redis command.
func (c FtCreateFieldOptionWeight) Build() Completed {
	return completed(c)
}

type FtCreateFieldOptionWithsuffixtrie Base

func (c FtCreateFieldOptionWithsuffixtrie) Sortable() FtCreateFieldOptionSortableSortable {
	c.command.append("SORTABLE")
	return FtCreateFieldOptionSortableSortable(c)
}

func (c FtCreateFieldOptionWithsuffixtrie) Noindex() FtCreateFieldOptionNoindex {
	c.command.append("NOINDEX")
	return FtCreateFieldOptionNoindex(c)
}

func (c FtCreateFieldOptionWithsuffixtrie) Nostem() FtCreateFieldOptionNostem {
	c.command.append("NOSTEM")
	return FtCreateFieldOptionNostem(c)
}

func (c FtCreateFieldOptionWithsuffixtrie) Phonetic(phonetic string) FtCreateFieldOptionPhonetic {
	c.command.append("PHONETIC", phonetic)
	return FtCreateFieldOptionPhonetic(c)
}

func (c FtCreateFieldOptionWithsuffixtrie) Weight(weight float64) FtCreateFieldOptionWeight {
	c.command.append("WEIGHT", strconv.FormatFloat(weight, 'f', -1, 64))
	return FtCreateFieldOptionWeight(c)
}

func (c FtCreateFieldOptionWithsuffixtrie) Separator(separator string) FtCreateFieldOptionSeparator {
	c.command.append("SEPARATOR", separator)
	return FtCreateFieldOptionSeparator(c)
}

func (c FtCreateFieldOptionWithsuffixtrie) Casesensitive() FtCreateFieldOptionCasesensitive {
	c.command.append("CASESENSITIVE")
	return FtCreateFieldOptionCasesensitive(c)
}

func (c FtCreateFieldOptionWithsuffixtrie) Withsuffixtrie() FtCreateFieldOptionWithsuffixtrie {
	c.command.append("WITHSUFFIXTRIE")
	return c
}

func (c FtCreateFieldOptionWithsuffixtrie) FieldName(fieldName string) FtCreateFieldFieldName {
	c.command.append(fieldName)
	return FtCreateFieldFieldName(c)
}

// Return Completed Redis command.
func (c FtCreateFieldOptionWithsuffixtrie) Build() Completed {
	return completed(c)
}

type FtCreateFilter Base

func (c FtCreateFilter) Language(defaultLang string) FtCreateLanguage {
	c.command.append("LANGUAGE", defaultLang)
	return FtCreateLanguage(c)
}

func (c FtCreateFilter) LanguageField(langAttribute string) FtCreateLanguageField {
	c.command.append("LANGUAGE_FIELD", langAttribute)
	return FtCreateLanguageField(c)
}

func (c FtCreateFilter) Score(defaultScore float64) FtCreateScore {
	c.command.append("SCORE", strconv.FormatFloat(defaultScore, 'f', -1, 64))
	return FtCreateScore(c)
}

func (c FtCreateFilter) ScoreField(scoreAttribute string) FtCreateScoreField {
	c.command.append("SCORE_FIELD", scoreAttribute)
	return FtCreateScoreField(c)
}

func (c FtCreateFilter) PayloadField(payloadAttribute string) FtCreatePayloadField {
	c.command.append("PAYLOAD_FIELD", payloadAttribute)
	return FtCreatePayloadField(c)
}

func (c FtCreateFilter) Maxtextfields() FtCreateMaxtextfields {
	c.command.append("MAXTEXTFIELDS")
	return FtCreateMaxtextfields(c)
}

func (c FtCreateFilter) Temporary(seconds float64) FtCreateTemporary {
	c.command.append("TEMPORARY", strconv.FormatFloat(seconds, 'f', -1, 64))
	return FtCreateTemporary(c)
}

func (c FtCreateFilter) Nooffsets() FtCreateNooffsets {
	c.command.append("NOOFFSETS")
	return FtCreateNooffsets(c)
}

func (c FtCreateFilter) Nohl() FtCreateNohl {
	c.command.append("NOHL")
	return FtCreateNohl(c)
}

func (c FtCreateFilter) Nofields() FtCreateNofields {
	c.command.append("NOFIELDS")
	return FtCreateNofields(c)
}

func (c FtCreateFilter) Nofreqs() FtCreateNofreqs {
	c.command.append("NOFREQS")
	return FtCreateNofreqs(c)
}

func (c FtCreateFilter) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreateFilter) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateFilter) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateIndex Base

func (c FtCreateIndex) OnHash() FtCreateOnHash {
	c.command.append("ON", "HASH")
	return FtCreateOnHash(c)
}

func (c FtCreateIndex) OnJson() FtCreateOnJson {
	c.command.append("ON", "JSON")
	return FtCreateOnJson(c)
}

func (c FtCreateIndex) Prefix(count int64) FtCreatePrefixCount {
	c.command.append("PREFIX", strconv.FormatInt(count, 10))
	return FtCreatePrefixCount(c)
}

func (c FtCreateIndex) Filter(filter string) FtCreateFilter {
	c.command.append("FILTER", filter)
	return FtCreateFilter(c)
}

func (c FtCreateIndex) Language(defaultLang string) FtCreateLanguage {
	c.command.append("LANGUAGE", defaultLang)
	return FtCreateLanguage(c)
}

func (c FtCreateIndex) LanguageField(langAttribute string) FtCreateLanguageField {
	c.command.append("LANGUAGE_FIELD", langAttribute)
	return FtCreateLanguageField(c)
}

func (c FtCreateIndex) Score(defaultScore float64) FtCreateScore {
	c.command.append("SCORE", strconv.FormatFloat(defaultScore, 'f', -1, 64))
	return FtCreateScore(c)
}

func (c FtCreateIndex) ScoreField(scoreAttribute string) FtCreateScoreField {
	c.command.append("SCORE_FIELD", scoreAttribute)
	return FtCreateScoreField(c)
}

func (c FtCreateIndex) PayloadField(payloadAttribute string) FtCreatePayloadField {
	c.command.append("PAYLOAD_FIELD", payloadAttribute)
	return FtCreatePayloadField(c)
}

func (c FtCreateIndex) Maxtextfields() FtCreateMaxtextfields {
	c.command.append("MAXTEXTFIELDS")
	return FtCreateMaxtextfields(c)
}

func (c FtCreateIndex) Temporary(seconds float64) FtCreateTemporary {
	c.command.append("TEMPORARY", strconv.FormatFloat(seconds, 'f', -1, 64))
	return FtCreateTemporary(c)
}

func (c FtCreateIndex) Nooffsets() FtCreateNooffsets {
	c.command.append("NOOFFSETS")
	return FtCreateNooffsets(c)
}

func (c FtCreateIndex) Nohl() FtCreateNohl {
	c.command.append("NOHL")
	return FtCreateNohl(c)
}

func (c FtCreateIndex) Nofields() FtCreateNofields {
	c.command.append("NOFIELDS")
	return FtCreateNofields(c)
}

func (c FtCreateIndex) Nofreqs() FtCreateNofreqs {
	c.command.append("NOFREQS")
	return FtCreateNofreqs(c)
}

func (c FtCreateIndex) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreateIndex) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateIndex) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateLanguage Base

func (c FtCreateLanguage) LanguageField(langAttribute string) FtCreateLanguageField {
	c.command.append("LANGUAGE_FIELD", langAttribute)
	return FtCreateLanguageField(c)
}

func (c FtCreateLanguage) Score(defaultScore float64) FtCreateScore {
	c.command.append("SCORE", strconv.FormatFloat(defaultScore, 'f', -1, 64))
	return FtCreateScore(c)
}

func (c FtCreateLanguage) ScoreField(scoreAttribute string) FtCreateScoreField {
	c.command.append("SCORE_FIELD", scoreAttribute)
	return FtCreateScoreField(c)
}

func (c FtCreateLanguage) PayloadField(payloadAttribute string) FtCreatePayloadField {
	c.command.append("PAYLOAD_FIELD", payloadAttribute)
	return FtCreatePayloadField(c)
}

func (c FtCreateLanguage) Maxtextfields() FtCreateMaxtextfields {
	c.command.append("MAXTEXTFIELDS")
	return FtCreateMaxtextfields(c)
}

func (c FtCreateLanguage) Temporary(seconds float64) FtCreateTemporary {
	c.command.append("TEMPORARY", strconv.FormatFloat(seconds, 'f', -1, 64))
	return FtCreateTemporary(c)
}

func (c FtCreateLanguage) Nooffsets() FtCreateNooffsets {
	c.command.append("NOOFFSETS")
	return FtCreateNooffsets(c)
}

func (c FtCreateLanguage) Nohl() FtCreateNohl {
	c.command.append("NOHL")
	return FtCreateNohl(c)
}

func (c FtCreateLanguage) Nofields() FtCreateNofields {
	c.command.append("NOFIELDS")
	return FtCreateNofields(c)
}

func (c FtCreateLanguage) Nofreqs() FtCreateNofreqs {
	c.command.append("NOFREQS")
	return FtCreateNofreqs(c)
}

func (c FtCreateLanguage) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreateLanguage) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateLanguage) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateLanguageField Base

func (c FtCreateLanguageField) Score(defaultScore float64) FtCreateScore {
	c.command.append("SCORE", strconv.FormatFloat(defaultScore, 'f', -1, 64))
	return FtCreateScore(c)
}

func (c FtCreateLanguageField) ScoreField(scoreAttribute string) FtCreateScoreField {
	c.command.append("SCORE_FIELD", scoreAttribute)
	return FtCreateScoreField(c)
}

func (c FtCreateLanguageField) PayloadField(payloadAttribute string) FtCreatePayloadField {
	c.command.append("PAYLOAD_FIELD", payloadAttribute)
	return FtCreatePayloadField(c)
}

func (c FtCreateLanguageField) Maxtextfields() FtCreateMaxtextfields {
	c.command.append("MAXTEXTFIELDS")
	return FtCreateMaxtextfields(c)
}

func (c FtCreateLanguageField) Temporary(seconds float64) FtCreateTemporary {
	c.command.append("TEMPORARY", strconv.FormatFloat(seconds, 'f', -1, 64))
	return FtCreateTemporary(c)
}

func (c FtCreateLanguageField) Nooffsets() FtCreateNooffsets {
	c.command.append("NOOFFSETS")
	return FtCreateNooffsets(c)
}

func (c FtCreateLanguageField) Nohl() FtCreateNohl {
	c.command.append("NOHL")
	return FtCreateNohl(c)
}

func (c FtCreateLanguageField) Nofields() FtCreateNofields {
	c.command.append("NOFIELDS")
	return FtCreateNofields(c)
}

func (c FtCreateLanguageField) Nofreqs() FtCreateNofreqs {
	c.command.append("NOFREQS")
	return FtCreateNofreqs(c)
}

func (c FtCreateLanguageField) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreateLanguageField) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateLanguageField) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateMaxtextfields Base

func (c FtCreateMaxtextfields) Temporary(seconds float64) FtCreateTemporary {
	c.command.append("TEMPORARY", strconv.FormatFloat(seconds, 'f', -1, 64))
	return FtCreateTemporary(c)
}

func (c FtCreateMaxtextfields) Nooffsets() FtCreateNooffsets {
	c.command.append("NOOFFSETS")
	return FtCreateNooffsets(c)
}

func (c FtCreateMaxtextfields) Nohl() FtCreateNohl {
	c.command.append("NOHL")
	return FtCreateNohl(c)
}

func (c FtCreateMaxtextfields) Nofields() FtCreateNofields {
	c.command.append("NOFIELDS")
	return FtCreateNofields(c)
}

func (c FtCreateMaxtextfields) Nofreqs() FtCreateNofreqs {
	c.command.append("NOFREQS")
	return FtCreateNofreqs(c)
}

func (c FtCreateMaxtextfields) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreateMaxtextfields) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateMaxtextfields) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateNofields Base

func (c FtCreateNofields) Nofreqs() FtCreateNofreqs {
	c.command.append("NOFREQS")
	return FtCreateNofreqs(c)
}

func (c FtCreateNofields) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreateNofields) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateNofields) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateNofreqs Base

func (c FtCreateNofreqs) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreateNofreqs) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateNofreqs) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateNohl Base

func (c FtCreateNohl) Nofields() FtCreateNofields {
	c.command.append("NOFIELDS")
	return FtCreateNofields(c)
}

func (c FtCreateNohl) Nofreqs() FtCreateNofreqs {
	c.command.append("NOFREQS")
	return FtCreateNofreqs(c)
}

func (c FtCreateNohl) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreateNohl) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateNohl) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateNooffsets Base

func (c FtCreateNooffsets) Nohl() FtCreateNohl {
	c.command.append("NOHL")
	return FtCreateNohl(c)
}

func (c FtCreateNooffsets) Nofields() FtCreateNofields {
	c.command.append("NOFIELDS")
	return FtCreateNofields(c)
}

func (c FtCreateNooffsets) Nofreqs() FtCreateNofreqs {
	c.command.append("NOFREQS")
	return FtCreateNofreqs(c)
}

func (c FtCreateNooffsets) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreateNooffsets) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateNooffsets) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateOnHash Base

func (c FtCreateOnHash) Prefix(count int64) FtCreatePrefixCount {
	c.command.append("PREFIX", strconv.FormatInt(count, 10))
	return FtCreatePrefixCount(c)
}

func (c FtCreateOnHash) Filter(filter string) FtCreateFilter {
	c.command.append("FILTER", filter)
	return FtCreateFilter(c)
}

func (c FtCreateOnHash) Language(defaultLang string) FtCreateLanguage {
	c.command.append("LANGUAGE", defaultLang)
	return FtCreateLanguage(c)
}

func (c FtCreateOnHash) LanguageField(langAttribute string) FtCreateLanguageField {
	c.command.append("LANGUAGE_FIELD", langAttribute)
	return FtCreateLanguageField(c)
}

func (c FtCreateOnHash) Score(defaultScore float64) FtCreateScore {
	c.command.append("SCORE", strconv.FormatFloat(defaultScore, 'f', -1, 64))
	return FtCreateScore(c)
}

func (c FtCreateOnHash) ScoreField(scoreAttribute string) FtCreateScoreField {
	c.command.append("SCORE_FIELD", scoreAttribute)
	return FtCreateScoreField(c)
}

func (c FtCreateOnHash) PayloadField(payloadAttribute string) FtCreatePayloadField {
	c.command.append("PAYLOAD_FIELD", payloadAttribute)
	return FtCreatePayloadField(c)
}

func (c FtCreateOnHash) Maxtextfields() FtCreateMaxtextfields {
	c.command.append("MAXTEXTFIELDS")
	return FtCreateMaxtextfields(c)
}

func (c FtCreateOnHash) Temporary(seconds float64) FtCreateTemporary {
	c.command.append("TEMPORARY", strconv.FormatFloat(seconds, 'f', -1, 64))
	return FtCreateTemporary(c)
}

func (c FtCreateOnHash) Nooffsets() FtCreateNooffsets {
	c.command.append("NOOFFSETS")
	return FtCreateNooffsets(c)
}

func (c FtCreateOnHash) Nohl() FtCreateNohl {
	c.command.append("NOHL")
	return FtCreateNohl(c)
}

func (c FtCreateOnHash) Nofields() FtCreateNofields {
	c.command.append("NOFIELDS")
	return FtCreateNofields(c)
}

func (c FtCreateOnHash) Nofreqs() FtCreateNofreqs {
	c.command.append("NOFREQS")
	return FtCreateNofreqs(c)
}

func (c FtCreateOnHash) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreateOnHash) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateOnHash) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateOnJson Base

func (c FtCreateOnJson) Prefix(count int64) FtCreatePrefixCount {
	c.command.append("PREFIX", strconv.FormatInt(count, 10))
	return FtCreatePrefixCount(c)
}

func (c FtCreateOnJson) Filter(filter string) FtCreateFilter {
	c.command.append("FILTER", filter)
	return FtCreateFilter(c)
}

func (c FtCreateOnJson) Language(defaultLang string) FtCreateLanguage {
	c.command.append("LANGUAGE", defaultLang)
	return FtCreateLanguage(c)
}

func (c FtCreateOnJson) LanguageField(langAttribute string) FtCreateLanguageField {
	c.command.append("LANGUAGE_FIELD", langAttribute)
	return FtCreateLanguageField(c)
}

func (c FtCreateOnJson) Score(defaultScore float64) FtCreateScore {
	c.command.append("SCORE", strconv.FormatFloat(defaultScore, 'f', -1, 64))
	return FtCreateScore(c)
}

func (c FtCreateOnJson) ScoreField(scoreAttribute string) FtCreateScoreField {
	c.command.append("SCORE_FIELD", scoreAttribute)
	return FtCreateScoreField(c)
}

func (c FtCreateOnJson) PayloadField(payloadAttribute string) FtCreatePayloadField {
	c.command.append("PAYLOAD_FIELD", payloadAttribute)
	return FtCreatePayloadField(c)
}

func (c FtCreateOnJson) Maxtextfields() FtCreateMaxtextfields {
	c.command.append("MAXTEXTFIELDS")
	return FtCreateMaxtextfields(c)
}

func (c FtCreateOnJson) Temporary(seconds float64) FtCreateTemporary {
	c.command.append("TEMPORARY", strconv.FormatFloat(seconds, 'f', -1, 64))
	return FtCreateTemporary(c)
}

func (c FtCreateOnJson) Nooffsets() FtCreateNooffsets {
	c.command.append("NOOFFSETS")
	return FtCreateNooffsets(c)
}

func (c FtCreateOnJson) Nohl() FtCreateNohl {
	c.command.append("NOHL")
	return FtCreateNohl(c)
}

func (c FtCreateOnJson) Nofields() FtCreateNofields {
	c.command.append("NOFIELDS")
	return FtCreateNofields(c)
}

func (c FtCreateOnJson) Nofreqs() FtCreateNofreqs {
	c.command.append("NOFREQS")
	return FtCreateNofreqs(c)
}

func (c FtCreateOnJson) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreateOnJson) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateOnJson) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreatePayloadField Base

func (c FtCreatePayloadField) Maxtextfields() FtCreateMaxtextfields {
	c.command.append("MAXTEXTFIELDS")
	return FtCreateMaxtextfields(c)
}

func (c FtCreatePayloadField) Temporary(seconds float64) FtCreateTemporary {
	c.command.append("TEMPORARY", strconv.FormatFloat(seconds, 'f', -1, 64))
	return FtCreateTemporary(c)
}

func (c FtCreatePayloadField) Nooffsets() FtCreateNooffsets {
	c.command.append("NOOFFSETS")
	return FtCreateNooffsets(c)
}

func (c FtCreatePayloadField) Nohl() FtCreateNohl {
	c.command.append("NOHL")
	return FtCreateNohl(c)
}

func (c FtCreatePayloadField) Nofields() FtCreateNofields {
	c.command.append("NOFIELDS")
	return FtCreateNofields(c)
}

func (c FtCreatePayloadField) Nofreqs() FtCreateNofreqs {
	c.command.append("NOFREQS")
	return FtCreateNofreqs(c)
}

func (c FtCreatePayloadField) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreatePayloadField) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreatePayloadField) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreatePrefixCount Base

func (c FtCreatePrefixCount) Prefix(prefix ...string) FtCreatePrefixPrefix {
	c.command.append(prefix...)
	return FtCreatePrefixPrefix(c)
}

type FtCreatePrefixPrefix Base

func (c FtCreatePrefixPrefix) Prefix(prefix ...string) FtCreatePrefixPrefix {
	c.command.append(prefix...)
	return c
}

func (c FtCreatePrefixPrefix) Filter(filter string) FtCreateFilter {
	c.command.append("FILTER", filter)
	return FtCreateFilter(c)
}

func (c FtCreatePrefixPrefix) Language(defaultLang string) FtCreateLanguage {
	c.command.append("LANGUAGE", defaultLang)
	return FtCreateLanguage(c)
}

func (c FtCreatePrefixPrefix) LanguageField(langAttribute string) FtCreateLanguageField {
	c.command.append("LANGUAGE_FIELD", langAttribute)
	return FtCreateLanguageField(c)
}

func (c FtCreatePrefixPrefix) Score(defaultScore float64) FtCreateScore {
	c.command.append("SCORE", strconv.FormatFloat(defaultScore, 'f', -1, 64))
	return FtCreateScore(c)
}

func (c FtCreatePrefixPrefix) ScoreField(scoreAttribute string) FtCreateScoreField {
	c.command.append("SCORE_FIELD", scoreAttribute)
	return FtCreateScoreField(c)
}

func (c FtCreatePrefixPrefix) PayloadField(payloadAttribute string) FtCreatePayloadField {
	c.command.append("PAYLOAD_FIELD", payloadAttribute)
	return FtCreatePayloadField(c)
}

func (c FtCreatePrefixPrefix) Maxtextfields() FtCreateMaxtextfields {
	c.command.append("MAXTEXTFIELDS")
	return FtCreateMaxtextfields(c)
}

func (c FtCreatePrefixPrefix) Temporary(seconds float64) FtCreateTemporary {
	c.command.append("TEMPORARY", strconv.FormatFloat(seconds, 'f', -1, 64))
	return FtCreateTemporary(c)
}

func (c FtCreatePrefixPrefix) Nooffsets() FtCreateNooffsets {
	c.command.append("NOOFFSETS")
	return FtCreateNooffsets(c)
}

func (c FtCreatePrefixPrefix) Nohl() FtCreateNohl {
	c.command.append("NOHL")
	return FtCreateNohl(c)
}

func (c FtCreatePrefixPrefix) Nofields() FtCreateNofields {
	c.command.append("NOFIELDS")
	return FtCreateNofields(c)
}

func (c FtCreatePrefixPrefix) Nofreqs() FtCreateNofreqs {
	c.command.append("NOFREQS")
	return FtCreateNofreqs(c)
}

func (c FtCreatePrefixPrefix) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreatePrefixPrefix) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreatePrefixPrefix) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateSchema Base

func (c FtCreateSchema) FieldName(fieldName string) FtCreateFieldFieldName {
	c.command.append(fieldName)
	return FtCreateFieldFieldName(c)
}

type FtCreateScore Base

func (c FtCreateScore) ScoreField(scoreAttribute string) FtCreateScoreField {
	c.command.append("SCORE_FIELD", scoreAttribute)
	return FtCreateScoreField(c)
}

func (c FtCreateScore) PayloadField(payloadAttribute string) FtCreatePayloadField {
	c.command.append("PAYLOAD_FIELD", payloadAttribute)
	return FtCreatePayloadField(c)
}

func (c FtCreateScore) Maxtextfields() FtCreateMaxtextfields {
	c.command.append("MAXTEXTFIELDS")
	return FtCreateMaxtextfields(c)
}

func (c FtCreateScore) Temporary(seconds float64) FtCreateTemporary {
	c.command.append("TEMPORARY", strconv.FormatFloat(seconds, 'f', -1, 64))
	return FtCreateTemporary(c)
}

func (c FtCreateScore) Nooffsets() FtCreateNooffsets {
	c.command.append("NOOFFSETS")
	return FtCreateNooffsets(c)
}

func (c FtCreateScore) Nohl() FtCreateNohl {
	c.command.append("NOHL")
	return FtCreateNohl(c)
}

func (c FtCreateScore) Nofields() FtCreateNofields {
	c.command.append("NOFIELDS")
	return FtCreateNofields(c)
}

func (c FtCreateScore) Nofreqs() FtCreateNofreqs {
	c.command.append("NOFREQS")
	return FtCreateNofreqs(c)
}

func (c FtCreateScore) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreateScore) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateScore) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateScoreField Base

func (c FtCreateScoreField) PayloadField(payloadAttribute string) FtCreatePayloadField {
	c.command.append("PAYLOAD_FIELD", payloadAttribute)
	return FtCreatePayloadField(c)
}

func (c FtCreateScoreField) Maxtextfields() FtCreateMaxtextfields {
	c.command.append("MAXTEXTFIELDS")
	return FtCreateMaxtextfields(c)
}

func (c FtCreateScoreField) Temporary(seconds float64) FtCreateTemporary {
	c.command.append("TEMPORARY", strconv.FormatFloat(seconds, 'f', -1, 64))
	return FtCreateTemporary(c)
}

func (c FtCreateScoreField) Nooffsets() FtCreateNooffsets {
	c.command.append("NOOFFSETS")
	return FtCreateNooffsets(c)
}

func (c FtCreateScoreField) Nohl() FtCreateNohl {
	c.command.append("NOHL")
	return FtCreateNohl(c)
}

func (c FtCreateScoreField) Nofields() FtCreateNofields {
	c.command.append("NOFIELDS")
	return FtCreateNofields(c)
}

func (c FtCreateScoreField) Nofreqs() FtCreateNofreqs {
	c.command.append("NOFREQS")
	return FtCreateNofreqs(c)
}

func (c FtCreateScoreField) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreateScoreField) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateScoreField) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateSkipinitialscan Base

func (c FtCreateSkipinitialscan) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateStopwordsStopword Base

func (c FtCreateStopwordsStopword) Stopword(stopword ...string) FtCreateStopwordsStopword {
	c.command.append(stopword...)
	return c
}

func (c FtCreateStopwordsStopword) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateStopwordsStopword) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateStopwordsStopwords Base

func (c FtCreateStopwordsStopwords) Stopword(stopword ...string) FtCreateStopwordsStopword {
	c.command.append(stopword...)
	return FtCreateStopwordsStopword(c)
}

func (c FtCreateStopwordsStopwords) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateStopwordsStopwords) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

type FtCreateTemporary Base

func (c FtCreateTemporary) Nooffsets() FtCreateNooffsets {
	c.command.append("NOOFFSETS")
	return FtCreateNooffsets(c)
}

func (c FtCreateTemporary) Nohl() FtCreateNohl {
	c.command.append("NOHL")
	return FtCreateNohl(c)
}

func (c FtCreateTemporary) Nofields() FtCreateNofields {
	c.command.append("NOFIELDS")
	return FtCreateNofields(c)
}

func (c FtCreateTemporary) Nofreqs() FtCreateNofreqs {
	c.command.append("NOFREQS")
	return FtCreateNofreqs(c)
}

func (c FtCreateTemporary) Stopwords(count int64) FtCreateStopwordsStopwords {
	c.command.append("STOPWORDS", strconv.FormatInt(count, 10))
	return FtCreateStopwordsStopwords(c)
}

func (c FtCreateTemporary) Skipinitialscan() FtCreateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtCreateSkipinitialscan(c)
}

func (c FtCreateTemporary) Schema() FtCreateSchema {
	c.command.append("SCHEMA")
	return FtCreateSchema(c)
}

// Deletes a cursor.
//
// Time complexity: O(1)
type FtCursorDel Base

// Deletes a cursor
//
// Command: FT.CURSOR DEL.
//
// Time complexity: O(1)
func (b Builder) FtCursorDel() FtCursorDel {
	c := FtCursorDel{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.CURSOR", "DEL")
	return c
}

func (c FtCursorDel) Index(index string) FtCursorDelIndex {
	c.command.append(index)
	return FtCursorDelIndex(c)
}

type FtCursorDelCursorId Base

// Return Completed Redis command.
func (c FtCursorDelCursorId) Build() Completed {
	return completed(c)
}

type FtCursorDelIndex Base

func (c FtCursorDelIndex) CursorId(cursorId int64) FtCursorDelCursorId {
	c.command.append(strconv.FormatInt(cursorId, 10))
	return FtCursorDelCursorId(c)
}

// Reads from a cursor.
//
// Time complexity: O(1)
type FtCursorRead Base

// Reads from a cursor
//
// Command: FT.CURSOR READ.
//
// Time complexity: O(1)
func (b Builder) FtCursorRead() FtCursorRead {
	c := FtCursorRead{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.CURSOR", "READ")
	return c
}

func (c FtCursorRead) Index(index string) FtCursorReadIndex {
	c.command.append(index)
	return FtCursorReadIndex(c)
}

type FtCursorReadCount Base

// Return Completed Redis command.
func (c FtCursorReadCount) Build() Completed {
	return completed(c)
}

type FtCursorReadCursorId Base

func (c FtCursorReadCursorId) Count(readSize int64) FtCursorReadCount {
	c.command.append("COUNT", strconv.FormatInt(readSize, 10))
	return FtCursorReadCount(c)
}

// Return Completed Redis command.
func (c FtCursorReadCursorId) Build() Completed {
	return completed(c)
}

type FtCursorReadIndex Base

func (c FtCursorReadIndex) CursorId(cursorId int64) FtCursorReadCursorId {
	c.command.append(strconv.FormatInt(cursorId, 10))
	return FtCursorReadCursorId(c)
}

// Adds terms to a dictionary.
//
// Time complexity: O(1)
type FtDictadd Base

// Adds terms to a dictionary
//
// Command: FT.DICTADD.
//
// Time complexity: O(1)
func (b Builder) FtDictadd() FtDictadd {
	c := FtDictadd{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.DICTADD")
	return c
}

func (c FtDictadd) Dict(dict string) FtDictaddDict {
	c.command.append(dict)
	return FtDictaddDict(c)
}

type FtDictaddDict Base

func (c FtDictaddDict) Term(term ...string) FtDictaddTerm {
	c.command.append(term...)
	return FtDictaddTerm(c)
}

type FtDictaddTerm Base

func (c FtDictaddTerm) Term(term ...string) FtDictaddTerm {
	c.command.append(term...)
	return c
}

// Return Completed Redis command.
func (c FtDictaddTerm) Build() Completed {
	return completed(c)
}

// Deletes terms from a dictionary.
//
// Time complexity: O(1)
type FtDictdel Base

// Deletes terms from a dictionary
//
// Command: FT.DICTDEL.
//
// Time complexity: O(1)
func (b Builder) FtDictdel() FtDictdel {
	c := FtDictdel{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.DICTDEL")
	return c
}

func (c FtDictdel) Dict(dict string) FtDictdelDict {
	c.command.append(dict)
	return FtDictdelDict(c)
}

type FtDictdelDict Base

func (c FtDictdelDict) Term(term ...string) FtDictdelTerm {
	c.command.append(term...)
	return FtDictdelTerm(c)
}

type FtDictdelTerm Base

func (c FtDictdelTerm) Term(term ...string) FtDictdelTerm {
	c.command.append(term...)
	return c
}

// Return Completed Redis command.
func (c FtDictdelTerm) Build() Completed {
	return completed(c)
}

// Dumps all terms in the given dictionary.
//
// Time complexity: O(N), where N is the size of the dictionary
type FtDictdump Base

// Dumps all terms in the given dictionary
//
// Command: FT.DICTDUMP.
//
// Time complexity: O(N), where N is the size of the dictionary
func (b Builder) FtDictdump() FtDictdump {
	c := FtDictdump{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.DICTDUMP")
	return c
}

func (c FtDictdump) Dict(dict string) FtDictdumpDict {
	c.command.append(dict)
	return FtDictdumpDict(c)
}

type FtDictdumpDict Base

// Return Completed Redis command.
func (c FtDictdumpDict) Build() Completed {
	return completed(c)
}

// Deletes the index.
//
// Time complexity: O(1) or O(N) if documents are deleted, where N is the number of keys in the keyspace
type FtDropindex Base

// Deletes the index
//
// Command: FT.DROPINDEX.
//
// Time complexity: O(1) or O(N) if documents are deleted, where N is the number of keys in the keyspace
func (b Builder) FtDropindex() FtDropindex {
	c := FtDropindex{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.DROPINDEX")
	return c
}

func (c FtDropindex) Index(index string) FtDropindexIndex {
	c.command.append(index)
	return FtDropindexIndex(c)
}

type FtDropindexDeleteDocsDd Base

// Return Completed Redis command.
func (c FtDropindexDeleteDocsDd) Build() Completed {
	return completed(c)
}

type FtDropindexIndex Base

func (c FtDropindexIndex) Dd() FtDropindexDeleteDocsDd {
	c.command.append("DD")
	return FtDropindexDeleteDocsDd(c)
}

// Return Completed Redis command.
func (c FtDropindexIndex) Build() Completed {
	return completed(c)
}

// Returns the execution plan for a complex query.
//
// Time complexity: O(1)
type FtExplain Base

// Returns the execution plan for a complex query
//
// Command: FT.EXPLAIN.
//
// Time complexity: O(1)
func (b Builder) FtExplain() FtExplain {
	c := FtExplain{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.EXPLAIN")
	return c
}

func (c FtExplain) Index(index string) FtExplainIndex {
	c.command.append(index)
	return FtExplainIndex(c)
}

type FtExplainDialect Base

// Return Completed Redis command.
func (c FtExplainDialect) Build() Completed {
	return completed(c)
}

type FtExplainIndex Base

func (c FtExplainIndex) Query(query string) FtExplainQuery {
	c.command.append(query)
	return FtExplainQuery(c)
}

type FtExplainQuery Base

func (c FtExplainQuery) Dialect(dialect int64) FtExplainDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtExplainDialect(c)
}

// Return Completed Redis command.
func (c FtExplainQuery) Build() Completed {
	return completed(c)
}

// Returns the execution plan for a complex query.
//
// Time complexity: O(1)
type FtExplaincli Base

// Returns the execution plan for a complex query
//
// Command: FT.EXPLAINCLI.
//
// Time complexity: O(1)
func (b Builder) FtExplaincli() FtExplaincli {
	c := FtExplaincli{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.EXPLAINCLI")
	return c
}

func (c FtExplaincli) Index(index string) FtExplaincliIndex {
	c.command.append(index)
	return FtExplaincliIndex(c)
}

type FtExplaincliDialect Base

// Return Completed Redis command.
func (c FtExplaincliDialect) Build() Completed {
	return completed(c)
}

type FtExplaincliIndex Base

func (c FtExplaincliIndex) Query(query string) FtExplaincliQuery {
	c.command.append(query)
	return FtExplaincliQuery(c)
}

type FtExplaincliQuery Base

func (c FtExplaincliQuery) Dialect(dialect int64) FtExplaincliDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtExplaincliDialect(c)
}

// Return Completed Redis command.
func (c FtExplaincliQuery) Build() Completed {
	return completed(c)
}

// Returns information and statistics on the index.
//
// Time complexity: O(1)
type FtInfo Base

// Returns information and statistics on the index
//
// Command: FT.INFO.
//
// Time complexity: O(1)
func (b Builder) FtInfo() FtInfo {
	c := FtInfo{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.INFO")
	return c
}

func (c FtInfo) Index(index string) FtInfoIndex {
	c.command.append(index)
	return FtInfoIndex(c)
}

type FtInfoIndex Base

// Return Completed Redis command.
func (c FtInfoIndex) Build() Completed {
	return completed(c)
}

// Returns a list of all existing indexes.
//
// Time complexity: O(1)
type FtList Base

// Returns a list of all existing indexes
//
// Command: FT._LIST.
//
// Time complexity: O(1)
func (b Builder) FtList() FtList {
	c := FtList{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT._LIST")
	return c
}

// Return Completed Redis command.
func (c FtList) Build() Completed {
	return completed(c)
}

type FtProfile Base

// Command: FT.PROFILE.
func (b Builder) FtProfile() FtProfile {
	c := FtProfile{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.PROFILE")
	return c
}

func (c FtProfile) Index(index string) FtProfileIndex {
	c.command.append(index)
	return FtProfileIndex(c)
}

type FtProfileIndex Base

func (c FtProfileIndex) Search() FtProfileQuerytypeSearch {
	c.command.append("SEARCH")
	return FtProfileQuerytypeSearch(c)
}

func (c FtProfileIndex) Aggregate() FtProfileQuerytypeAggregate {
	c.command.append("AGGREGATE")
	return FtProfileQuerytypeAggregate(c)
}

type FtProfileLimited Base

func (c FtProfileLimited) Query(query string) FtProfileQuery {
	c.command.append("QUERY", query)
	return FtProfileQuery(c)
}

type FtProfileQuery Base

// Return Completed Redis command.
func (c FtProfileQuery) Build() Completed {
	return completed(c)
}

type FtProfileQuerytypeAggregate Base

func (c FtProfileQuerytypeAggregate) Limited() FtProfileLimited {
	c.command.append("LIMITED")
	return FtProfileLimited(c)
}

func (c FtProfileQuerytypeAggregate) Query(query string) FtProfileQuery {
	c.command.append("QUERY", query)
	return FtProfileQuery(c)
}

type FtProfileQuerytypeSearch Base

func (c FtProfileQuerytypeSearch) Limited() FtProfileLimited {
	c.command.append("LIMITED")
	return FtProfileLimited(c)
}

func (c FtProfileQuerytypeSearch) Query(query string) FtProfileQuery {
	c.command.append("QUERY", query)
	return FtProfileQuery(c)
}

// Searches the index with a textual query, returning either documents or just ids.
//
// Time complexity: O(N)
type FtSearch Base

// Searches the index with a textual query, returning either documents or just ids
//
// Command: FT.SEARCH.
//
// Time complexity: O(N)
func (b Builder) FtSearch() FtSearch {
	c := FtSearch{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.SEARCH")
	return c
}

func (c FtSearch) Index(index string) FtSearchIndex {
	c.command.append(index)
	return FtSearchIndex(c)
}

type FtSearchDialect Base

// Return Completed Redis command.
func (c FtSearchDialect) Build() Completed {
	return completed(c)
}

type FtSearchExpander Base

func (c FtSearchExpander) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchExpander) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchExpander) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchExpander) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchExpander) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchExpander) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchExpander) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchExpander) Build() Completed {
	return completed(c)
}

type FtSearchExplainscore Base

func (c FtSearchExplainscore) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchExplainscore) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchExplainscore) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchExplainscore) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchExplainscore) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchExplainscore) Build() Completed {
	return completed(c)
}

type FtSearchFilterFilter Base

func (c FtSearchFilterFilter) Min(min float64) FtSearchFilterMin {
	c.command.append(strconv.FormatFloat(min, 'f', -1, 64))
	return FtSearchFilterMin(c)
}

type FtSearchFilterMax Base

func (c FtSearchFilterMax) Filter(numericField string) FtSearchFilterFilter {
	c.command.append("FILTER", numericField)
	return FtSearchFilterFilter(c)
}

func (c FtSearchFilterMax) Geofilter(geoField string) FtSearchGeoFilterGeofilter {
	c.command.append("GEOFILTER", geoField)
	return FtSearchGeoFilterGeofilter(c)
}

func (c FtSearchFilterMax) Inkeys(count string) FtSearchInKeysInkeys {
	c.command.append("INKEYS", count)
	return FtSearchInKeysInkeys(c)
}

func (c FtSearchFilterMax) Infields(count string) FtSearchInFieldsInfields {
	c.command.append("INFIELDS", count)
	return FtSearchInFieldsInfields(c)
}

func (c FtSearchFilterMax) Return(count string) FtSearchReturnReturn {
	c.command.append("RETURN", count)
	return FtSearchReturnReturn(c)
}

func (c FtSearchFilterMax) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchFilterMax) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchFilterMax) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchFilterMax) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchFilterMax) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchFilterMax) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchFilterMax) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchFilterMax) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchFilterMax) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchFilterMax) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchFilterMax) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchFilterMax) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchFilterMax) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchFilterMax) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchFilterMax) Build() Completed {
	return completed(c)
}

type FtSearchFilterMin Base

func (c FtSearchFilterMin) Max(max float64) FtSearchFilterMax {
	c.command.append(strconv.FormatFloat(max, 'f', -1, 64))
	return FtSearchFilterMax(c)
}

type FtSearchGeoFilterGeofilter Base

func (c FtSearchGeoFilterGeofilter) Lon(lon float64) FtSearchGeoFilterLon {
	c.command.append(strconv.FormatFloat(lon, 'f', -1, 64))
	return FtSearchGeoFilterLon(c)
}

type FtSearchGeoFilterLat Base

func (c FtSearchGeoFilterLat) Radius(radius float64) FtSearchGeoFilterRadius {
	c.command.append(strconv.FormatFloat(radius, 'f', -1, 64))
	return FtSearchGeoFilterRadius(c)
}

type FtSearchGeoFilterLon Base

func (c FtSearchGeoFilterLon) Lat(lat float64) FtSearchGeoFilterLat {
	c.command.append(strconv.FormatFloat(lat, 'f', -1, 64))
	return FtSearchGeoFilterLat(c)
}

type FtSearchGeoFilterRadius Base

func (c FtSearchGeoFilterRadius) M() FtSearchGeoFilterRadiusTypeM {
	c.command.append("m")
	return FtSearchGeoFilterRadiusTypeM(c)
}

func (c FtSearchGeoFilterRadius) Km() FtSearchGeoFilterRadiusTypeKm {
	c.command.append("km")
	return FtSearchGeoFilterRadiusTypeKm(c)
}

func (c FtSearchGeoFilterRadius) Mi() FtSearchGeoFilterRadiusTypeMi {
	c.command.append("mi")
	return FtSearchGeoFilterRadiusTypeMi(c)
}

func (c FtSearchGeoFilterRadius) Ft() FtSearchGeoFilterRadiusTypeFt {
	c.command.append("ft")
	return FtSearchGeoFilterRadiusTypeFt(c)
}

type FtSearchGeoFilterRadiusTypeFt Base

func (c FtSearchGeoFilterRadiusTypeFt) Geofilter(geoField string) FtSearchGeoFilterGeofilter {
	c.command.append("GEOFILTER", geoField)
	return FtSearchGeoFilterGeofilter(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Inkeys(count string) FtSearchInKeysInkeys {
	c.command.append("INKEYS", count)
	return FtSearchInKeysInkeys(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Infields(count string) FtSearchInFieldsInfields {
	c.command.append("INFIELDS", count)
	return FtSearchInFieldsInfields(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Return(count string) FtSearchReturnReturn {
	c.command.append("RETURN", count)
	return FtSearchReturnReturn(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchGeoFilterRadiusTypeFt) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchGeoFilterRadiusTypeFt) Build() Completed {
	return completed(c)
}

type FtSearchGeoFilterRadiusTypeKm Base

func (c FtSearchGeoFilterRadiusTypeKm) Geofilter(geoField string) FtSearchGeoFilterGeofilter {
	c.command.append("GEOFILTER", geoField)
	return FtSearchGeoFilterGeofilter(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Inkeys(count string) FtSearchInKeysInkeys {
	c.command.append("INKEYS", count)
	return FtSearchInKeysInkeys(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Infields(count string) FtSearchInFieldsInfields {
	c.command.append("INFIELDS", count)
	return FtSearchInFieldsInfields(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Return(count string) FtSearchReturnReturn {
	c.command.append("RETURN", count)
	return FtSearchReturnReturn(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchGeoFilterRadiusTypeKm) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchGeoFilterRadiusTypeKm) Build() Completed {
	return completed(c)
}

type FtSearchGeoFilterRadiusTypeM Base

func (c FtSearchGeoFilterRadiusTypeM) Geofilter(geoField string) FtSearchGeoFilterGeofilter {
	c.command.append("GEOFILTER", geoField)
	return FtSearchGeoFilterGeofilter(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Inkeys(count string) FtSearchInKeysInkeys {
	c.command.append("INKEYS", count)
	return FtSearchInKeysInkeys(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Infields(count string) FtSearchInFieldsInfields {
	c.command.append("INFIELDS", count)
	return FtSearchInFieldsInfields(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Return(count string) FtSearchReturnReturn {
	c.command.append("RETURN", count)
	return FtSearchReturnReturn(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchGeoFilterRadiusTypeM) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchGeoFilterRadiusTypeM) Build() Completed {
	return completed(c)
}

type FtSearchGeoFilterRadiusTypeMi Base

func (c FtSearchGeoFilterRadiusTypeMi) Geofilter(geoField string) FtSearchGeoFilterGeofilter {
	c.command.append("GEOFILTER", geoField)
	return FtSearchGeoFilterGeofilter(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Inkeys(count string) FtSearchInKeysInkeys {
	c.command.append("INKEYS", count)
	return FtSearchInKeysInkeys(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Infields(count string) FtSearchInFieldsInfields {
	c.command.append("INFIELDS", count)
	return FtSearchInFieldsInfields(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Return(count string) FtSearchReturnReturn {
	c.command.append("RETURN", count)
	return FtSearchReturnReturn(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchGeoFilterRadiusTypeMi) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchGeoFilterRadiusTypeMi) Build() Completed {
	return completed(c)
}

type FtSearchHighlightFieldsField Base

func (c FtSearchHighlightFieldsField) Field(field ...string) FtSearchHighlightFieldsField {
	c.command.append(field...)
	return c
}

func (c FtSearchHighlightFieldsField) Tags() FtSearchHighlightTagsTags {
	c.command.append("TAGS")
	return FtSearchHighlightTagsTags(c)
}

func (c FtSearchHighlightFieldsField) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchHighlightFieldsField) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchHighlightFieldsField) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchHighlightFieldsField) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchHighlightFieldsField) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchHighlightFieldsField) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchHighlightFieldsField) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchHighlightFieldsField) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchHighlightFieldsField) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchHighlightFieldsField) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchHighlightFieldsField) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchHighlightFieldsField) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchHighlightFieldsField) Build() Completed {
	return completed(c)
}

type FtSearchHighlightFieldsFields Base

func (c FtSearchHighlightFieldsFields) Field(field ...string) FtSearchHighlightFieldsField {
	c.command.append(field...)
	return FtSearchHighlightFieldsField(c)
}

type FtSearchHighlightHighlight Base

func (c FtSearchHighlightHighlight) Fields(count string) FtSearchHighlightFieldsFields {
	c.command.append("FIELDS", count)
	return FtSearchHighlightFieldsFields(c)
}

func (c FtSearchHighlightHighlight) Tags() FtSearchHighlightTagsTags {
	c.command.append("TAGS")
	return FtSearchHighlightTagsTags(c)
}

func (c FtSearchHighlightHighlight) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchHighlightHighlight) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchHighlightHighlight) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchHighlightHighlight) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchHighlightHighlight) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchHighlightHighlight) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchHighlightHighlight) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchHighlightHighlight) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchHighlightHighlight) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchHighlightHighlight) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchHighlightHighlight) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchHighlightHighlight) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchHighlightHighlight) Build() Completed {
	return completed(c)
}

type FtSearchHighlightTagsOpenClose Base

func (c FtSearchHighlightTagsOpenClose) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchHighlightTagsOpenClose) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchHighlightTagsOpenClose) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchHighlightTagsOpenClose) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchHighlightTagsOpenClose) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchHighlightTagsOpenClose) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchHighlightTagsOpenClose) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchHighlightTagsOpenClose) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchHighlightTagsOpenClose) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchHighlightTagsOpenClose) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchHighlightTagsOpenClose) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchHighlightTagsOpenClose) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchHighlightTagsOpenClose) Build() Completed {
	return completed(c)
}

type FtSearchHighlightTagsTags Base

func (c FtSearchHighlightTagsTags) OpenClose(open string, close string) FtSearchHighlightTagsOpenClose {
	c.command.append(open, close)
	return FtSearchHighlightTagsOpenClose(c)
}

type FtSearchInFieldsField Base

func (c FtSearchInFieldsField) Field(field ...string) FtSearchInFieldsField {
	c.command.append(field...)
	return c
}

func (c FtSearchInFieldsField) Return(count string) FtSearchReturnReturn {
	c.command.append("RETURN", count)
	return FtSearchReturnReturn(c)
}

func (c FtSearchInFieldsField) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchInFieldsField) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchInFieldsField) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchInFieldsField) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchInFieldsField) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchInFieldsField) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchInFieldsField) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchInFieldsField) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchInFieldsField) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchInFieldsField) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchInFieldsField) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchInFieldsField) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchInFieldsField) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchInFieldsField) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchInFieldsField) Build() Completed {
	return completed(c)
}

type FtSearchInFieldsInfields Base

func (c FtSearchInFieldsInfields) Field(field ...string) FtSearchInFieldsField {
	c.command.append(field...)
	return FtSearchInFieldsField(c)
}

type FtSearchInKeysInkeys Base

func (c FtSearchInKeysInkeys) Key(key ...string) FtSearchInKeysKey {
	c.command.append(key...)
	return FtSearchInKeysKey(c)
}

type FtSearchInKeysKey Base

func (c FtSearchInKeysKey) Key(key ...string) FtSearchInKeysKey {
	c.command.append(key...)
	return c
}

func (c FtSearchInKeysKey) Infields(count string) FtSearchInFieldsInfields {
	c.command.append("INFIELDS", count)
	return FtSearchInFieldsInfields(c)
}

func (c FtSearchInKeysKey) Return(count string) FtSearchReturnReturn {
	c.command.append("RETURN", count)
	return FtSearchReturnReturn(c)
}

func (c FtSearchInKeysKey) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchInKeysKey) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchInKeysKey) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchInKeysKey) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchInKeysKey) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchInKeysKey) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchInKeysKey) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchInKeysKey) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchInKeysKey) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchInKeysKey) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchInKeysKey) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchInKeysKey) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchInKeysKey) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchInKeysKey) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchInKeysKey) Build() Completed {
	return completed(c)
}

type FtSearchIndex Base

func (c FtSearchIndex) Query(query string) FtSearchQuery {
	c.command.append(query)
	return FtSearchQuery(c)
}

type FtSearchLanguage Base

func (c FtSearchLanguage) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchLanguage) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchLanguage) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchLanguage) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchLanguage) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchLanguage) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchLanguage) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchLanguage) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchLanguage) Build() Completed {
	return completed(c)
}

type FtSearchLimitLimit Base

func (c FtSearchLimitLimit) OffsetNum(offset int64, num int64) FtSearchLimitOffsetNum {
	c.command.append(strconv.FormatInt(offset, 10), strconv.FormatInt(num, 10))
	return FtSearchLimitOffsetNum(c)
}

type FtSearchLimitOffsetNum Base

func (c FtSearchLimitOffsetNum) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchLimitOffsetNum) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchLimitOffsetNum) Build() Completed {
	return completed(c)
}

type FtSearchNocontent Base

func (c FtSearchNocontent) Verbatim() FtSearchVerbatim {
	c.command.append("VERBATIM")
	return FtSearchVerbatim(c)
}

func (c FtSearchNocontent) Nostopwords() FtSearchNostopwords {
	c.command.append("NOSTOPWORDS")
	return FtSearchNostopwords(c)
}

func (c FtSearchNocontent) Withscores() FtSearchWithscores {
	c.command.append("WITHSCORES")
	return FtSearchWithscores(c)
}

func (c FtSearchNocontent) Withpayloads() FtSearchWithpayloads {
	c.command.append("WITHPAYLOADS")
	return FtSearchWithpayloads(c)
}

func (c FtSearchNocontent) Withsortkeys() FtSearchWithsortkeys {
	c.command.append("WITHSORTKEYS")
	return FtSearchWithsortkeys(c)
}

func (c FtSearchNocontent) Filter(numericField string) FtSearchFilterFilter {
	c.command.append("FILTER", numericField)
	return FtSearchFilterFilter(c)
}

func (c FtSearchNocontent) Geofilter(geoField string) FtSearchGeoFilterGeofilter {
	c.command.append("GEOFILTER", geoField)
	return FtSearchGeoFilterGeofilter(c)
}

func (c FtSearchNocontent) Inkeys(count string) FtSearchInKeysInkeys {
	c.command.append("INKEYS", count)
	return FtSearchInKeysInkeys(c)
}

func (c FtSearchNocontent) Infields(count string) FtSearchInFieldsInfields {
	c.command.append("INFIELDS", count)
	return FtSearchInFieldsInfields(c)
}

func (c FtSearchNocontent) Return(count string) FtSearchReturnReturn {
	c.command.append("RETURN", count)
	return FtSearchReturnReturn(c)
}

func (c FtSearchNocontent) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchNocontent) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchNocontent) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchNocontent) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchNocontent) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchNocontent) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchNocontent) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchNocontent) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchNocontent) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchNocontent) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchNocontent) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchNocontent) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchNocontent) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchNocontent) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchNocontent) Build() Completed {
	return completed(c)
}

type FtSearchNostopwords Base

func (c FtSearchNostopwords) Withscores() FtSearchWithscores {
	c.command.append("WITHSCORES")
	return FtSearchWithscores(c)
}

func (c FtSearchNostopwords) Withpayloads() FtSearchWithpayloads {
	c.command.append("WITHPAYLOADS")
	return FtSearchWithpayloads(c)
}

func (c FtSearchNostopwords) Withsortkeys() FtSearchWithsortkeys {
	c.command.append("WITHSORTKEYS")
	return FtSearchWithsortkeys(c)
}

func (c FtSearchNostopwords) Filter(numericField string) FtSearchFilterFilter {
	c.command.append("FILTER", numericField)
	return FtSearchFilterFilter(c)
}

func (c FtSearchNostopwords) Geofilter(geoField string) FtSearchGeoFilterGeofilter {
	c.command.append("GEOFILTER", geoField)
	return FtSearchGeoFilterGeofilter(c)
}

func (c FtSearchNostopwords) Inkeys(count string) FtSearchInKeysInkeys {
	c.command.append("INKEYS", count)
	return FtSearchInKeysInkeys(c)
}

func (c FtSearchNostopwords) Infields(count string) FtSearchInFieldsInfields {
	c.command.append("INFIELDS", count)
	return FtSearchInFieldsInfields(c)
}

func (c FtSearchNostopwords) Return(count string) FtSearchReturnReturn {
	c.command.append("RETURN", count)
	return FtSearchReturnReturn(c)
}

func (c FtSearchNostopwords) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchNostopwords) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchNostopwords) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchNostopwords) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchNostopwords) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchNostopwords) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchNostopwords) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchNostopwords) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchNostopwords) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchNostopwords) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchNostopwords) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchNostopwords) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchNostopwords) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchNostopwords) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchNostopwords) Build() Completed {
	return completed(c)
}

type FtSearchParamsNameValue Base

func (c FtSearchParamsNameValue) NameValue(name string, value string) FtSearchParamsNameValue {
	c.command.append(name, value)
	return c
}

func (c FtSearchParamsNameValue) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchParamsNameValue) Build() Completed {
	return completed(c)
}

type FtSearchParamsNargs Base

func (c FtSearchParamsNargs) NameValue() FtSearchParamsNameValue {
	return FtSearchParamsNameValue(c)
}

type FtSearchParamsParams Base

func (c FtSearchParamsParams) Nargs(nargs int64) FtSearchParamsNargs {
	c.command.append(strconv.FormatInt(nargs, 10))
	return FtSearchParamsNargs(c)
}

type FtSearchPayload Base

func (c FtSearchPayload) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchPayload) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchPayload) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchPayload) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchPayload) Build() Completed {
	return completed(c)
}

type FtSearchQuery Base

func (c FtSearchQuery) Nocontent() FtSearchNocontent {
	c.command.append("NOCONTENT")
	return FtSearchNocontent(c)
}

func (c FtSearchQuery) Verbatim() FtSearchVerbatim {
	c.command.append("VERBATIM")
	return FtSearchVerbatim(c)
}

func (c FtSearchQuery) Nostopwords() FtSearchNostopwords {
	c.command.append("NOSTOPWORDS")
	return FtSearchNostopwords(c)
}

func (c FtSearchQuery) Withscores() FtSearchWithscores {
	c.command.append("WITHSCORES")
	return FtSearchWithscores(c)
}

func (c FtSearchQuery) Withpayloads() FtSearchWithpayloads {
	c.command.append("WITHPAYLOADS")
	return FtSearchWithpayloads(c)
}

func (c FtSearchQuery) Withsortkeys() FtSearchWithsortkeys {
	c.command.append("WITHSORTKEYS")
	return FtSearchWithsortkeys(c)
}

func (c FtSearchQuery) Filter(numericField string) FtSearchFilterFilter {
	c.command.append("FILTER", numericField)
	return FtSearchFilterFilter(c)
}

func (c FtSearchQuery) Geofilter(geoField string) FtSearchGeoFilterGeofilter {
	c.command.append("GEOFILTER", geoField)
	return FtSearchGeoFilterGeofilter(c)
}

func (c FtSearchQuery) Inkeys(count string) FtSearchInKeysInkeys {
	c.command.append("INKEYS", count)
	return FtSearchInKeysInkeys(c)
}

func (c FtSearchQuery) Infields(count string) FtSearchInFieldsInfields {
	c.command.append("INFIELDS", count)
	return FtSearchInFieldsInfields(c)
}

func (c FtSearchQuery) Return(count string) FtSearchReturnReturn {
	c.command.append("RETURN", count)
	return FtSearchReturnReturn(c)
}

func (c FtSearchQuery) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchQuery) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchQuery) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchQuery) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchQuery) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchQuery) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchQuery) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchQuery) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchQuery) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchQuery) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchQuery) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchQuery) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchQuery) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchQuery) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchQuery) Build() Completed {
	return completed(c)
}

type FtSearchReturnIdentifiersAs Base

func (c FtSearchReturnIdentifiersAs) Identifier(identifier string) FtSearchReturnIdentifiersIdentifier {
	c.command.append(identifier)
	return FtSearchReturnIdentifiersIdentifier(c)
}

func (c FtSearchReturnIdentifiersAs) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchReturnIdentifiersAs) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchReturnIdentifiersAs) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchReturnIdentifiersAs) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchReturnIdentifiersAs) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchReturnIdentifiersAs) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchReturnIdentifiersAs) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchReturnIdentifiersAs) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchReturnIdentifiersAs) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchReturnIdentifiersAs) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchReturnIdentifiersAs) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchReturnIdentifiersAs) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchReturnIdentifiersAs) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchReturnIdentifiersAs) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchReturnIdentifiersAs) Build() Completed {
	return completed(c)
}

type FtSearchReturnIdentifiersIdentifier Base

func (c FtSearchReturnIdentifiersIdentifier) As(property string) FtSearchReturnIdentifiersAs {
	c.command.append("AS", property)
	return FtSearchReturnIdentifiersAs(c)
}

func (c FtSearchReturnIdentifiersIdentifier) Identifier(identifier string) FtSearchReturnIdentifiersIdentifier {
	c.command.append(identifier)
	return c
}

func (c FtSearchReturnIdentifiersIdentifier) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchReturnIdentifiersIdentifier) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchReturnIdentifiersIdentifier) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchReturnIdentifiersIdentifier) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchReturnIdentifiersIdentifier) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchReturnIdentifiersIdentifier) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchReturnIdentifiersIdentifier) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchReturnIdentifiersIdentifier) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchReturnIdentifiersIdentifier) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchReturnIdentifiersIdentifier) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchReturnIdentifiersIdentifier) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchReturnIdentifiersIdentifier) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchReturnIdentifiersIdentifier) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchReturnIdentifiersIdentifier) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchReturnIdentifiersIdentifier) Build() Completed {
	return completed(c)
}

type FtSearchReturnReturn Base

func (c FtSearchReturnReturn) Identifier(identifier string) FtSearchReturnIdentifiersIdentifier {
	c.command.append(identifier)
	return FtSearchReturnIdentifiersIdentifier(c)
}

type FtSearchScorer Base

func (c FtSearchScorer) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchScorer) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchScorer) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchScorer) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchScorer) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchScorer) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchScorer) Build() Completed {
	return completed(c)
}

type FtSearchSlop Base

func (c FtSearchSlop) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchSlop) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchSlop) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchSlop) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchSlop) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchSlop) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchSlop) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchSlop) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchSlop) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchSlop) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchSlop) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchSlop) Build() Completed {
	return completed(c)
}

type FtSearchSortbyOrderAsc Base

func (c FtSearchSortbyOrderAsc) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchSortbyOrderAsc) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchSortbyOrderAsc) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchSortbyOrderAsc) Build() Completed {
	return completed(c)
}

type FtSearchSortbyOrderDesc Base

func (c FtSearchSortbyOrderDesc) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchSortbyOrderDesc) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchSortbyOrderDesc) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchSortbyOrderDesc) Build() Completed {
	return completed(c)
}

type FtSearchSortbySortby Base

func (c FtSearchSortbySortby) Asc() FtSearchSortbyOrderAsc {
	c.command.append("ASC")
	return FtSearchSortbyOrderAsc(c)
}

func (c FtSearchSortbySortby) Desc() FtSearchSortbyOrderDesc {
	c.command.append("DESC")
	return FtSearchSortbyOrderDesc(c)
}

func (c FtSearchSortbySortby) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchSortbySortby) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchSortbySortby) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchSortbySortby) Build() Completed {
	return completed(c)
}

type FtSearchSummarizeFieldsField Base

func (c FtSearchSummarizeFieldsField) Field(field ...string) FtSearchSummarizeFieldsField {
	c.command.append(field...)
	return c
}

func (c FtSearchSummarizeFieldsField) Frags(num int64) FtSearchSummarizeFrags {
	c.command.append("FRAGS", strconv.FormatInt(num, 10))
	return FtSearchSummarizeFrags(c)
}

func (c FtSearchSummarizeFieldsField) Len(fragsize int64) FtSearchSummarizeLen {
	c.command.append("LEN", strconv.FormatInt(fragsize, 10))
	return FtSearchSummarizeLen(c)
}

func (c FtSearchSummarizeFieldsField) Separator(separator string) FtSearchSummarizeSeparator {
	c.command.append("SEPARATOR", separator)
	return FtSearchSummarizeSeparator(c)
}

func (c FtSearchSummarizeFieldsField) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchSummarizeFieldsField) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchSummarizeFieldsField) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchSummarizeFieldsField) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchSummarizeFieldsField) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchSummarizeFieldsField) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchSummarizeFieldsField) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchSummarizeFieldsField) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchSummarizeFieldsField) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchSummarizeFieldsField) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchSummarizeFieldsField) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchSummarizeFieldsField) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchSummarizeFieldsField) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchSummarizeFieldsField) Build() Completed {
	return completed(c)
}

type FtSearchSummarizeFieldsFields Base

func (c FtSearchSummarizeFieldsFields) Field(field ...string) FtSearchSummarizeFieldsField {
	c.command.append(field...)
	return FtSearchSummarizeFieldsField(c)
}

type FtSearchSummarizeFrags Base

func (c FtSearchSummarizeFrags) Len(fragsize int64) FtSearchSummarizeLen {
	c.command.append("LEN", strconv.FormatInt(fragsize, 10))
	return FtSearchSummarizeLen(c)
}

func (c FtSearchSummarizeFrags) Separator(separator string) FtSearchSummarizeSeparator {
	c.command.append("SEPARATOR", separator)
	return FtSearchSummarizeSeparator(c)
}

func (c FtSearchSummarizeFrags) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchSummarizeFrags) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchSummarizeFrags) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchSummarizeFrags) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchSummarizeFrags) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchSummarizeFrags) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchSummarizeFrags) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchSummarizeFrags) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchSummarizeFrags) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchSummarizeFrags) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchSummarizeFrags) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchSummarizeFrags) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchSummarizeFrags) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchSummarizeFrags) Build() Completed {
	return completed(c)
}

type FtSearchSummarizeLen Base

func (c FtSearchSummarizeLen) Separator(separator string) FtSearchSummarizeSeparator {
	c.command.append("SEPARATOR", separator)
	return FtSearchSummarizeSeparator(c)
}

func (c FtSearchSummarizeLen) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchSummarizeLen) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchSummarizeLen) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchSummarizeLen) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchSummarizeLen) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchSummarizeLen) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchSummarizeLen) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchSummarizeLen) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchSummarizeLen) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchSummarizeLen) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchSummarizeLen) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchSummarizeLen) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchSummarizeLen) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchSummarizeLen) Build() Completed {
	return completed(c)
}

type FtSearchSummarizeSeparator Base

func (c FtSearchSummarizeSeparator) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchSummarizeSeparator) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchSummarizeSeparator) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchSummarizeSeparator) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchSummarizeSeparator) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchSummarizeSeparator) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchSummarizeSeparator) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchSummarizeSeparator) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchSummarizeSeparator) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchSummarizeSeparator) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchSummarizeSeparator) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchSummarizeSeparator) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchSummarizeSeparator) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchSummarizeSeparator) Build() Completed {
	return completed(c)
}

type FtSearchSummarizeSummarize Base

func (c FtSearchSummarizeSummarize) Fields(count string) FtSearchSummarizeFieldsFields {
	c.command.append("FIELDS", count)
	return FtSearchSummarizeFieldsFields(c)
}

func (c FtSearchSummarizeSummarize) Frags(num int64) FtSearchSummarizeFrags {
	c.command.append("FRAGS", strconv.FormatInt(num, 10))
	return FtSearchSummarizeFrags(c)
}

func (c FtSearchSummarizeSummarize) Len(fragsize int64) FtSearchSummarizeLen {
	c.command.append("LEN", strconv.FormatInt(fragsize, 10))
	return FtSearchSummarizeLen(c)
}

func (c FtSearchSummarizeSummarize) Separator(separator string) FtSearchSummarizeSeparator {
	c.command.append("SEPARATOR", separator)
	return FtSearchSummarizeSeparator(c)
}

func (c FtSearchSummarizeSummarize) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchSummarizeSummarize) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchSummarizeSummarize) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchSummarizeSummarize) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchSummarizeSummarize) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchSummarizeSummarize) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchSummarizeSummarize) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchSummarizeSummarize) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchSummarizeSummarize) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchSummarizeSummarize) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchSummarizeSummarize) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchSummarizeSummarize) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchSummarizeSummarize) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchSummarizeSummarize) Build() Completed {
	return completed(c)
}

type FtSearchTagsInorder Base

func (c FtSearchTagsInorder) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchTagsInorder) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchTagsInorder) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchTagsInorder) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchTagsInorder) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchTagsInorder) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchTagsInorder) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchTagsInorder) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchTagsInorder) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchTagsInorder) Build() Completed {
	return completed(c)
}

type FtSearchTimeout Base

func (c FtSearchTimeout) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchTimeout) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchTimeout) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchTimeout) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchTimeout) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchTimeout) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchTimeout) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchTimeout) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchTimeout) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchTimeout) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchTimeout) Build() Completed {
	return completed(c)
}

type FtSearchVerbatim Base

func (c FtSearchVerbatim) Nostopwords() FtSearchNostopwords {
	c.command.append("NOSTOPWORDS")
	return FtSearchNostopwords(c)
}

func (c FtSearchVerbatim) Withscores() FtSearchWithscores {
	c.command.append("WITHSCORES")
	return FtSearchWithscores(c)
}

func (c FtSearchVerbatim) Withpayloads() FtSearchWithpayloads {
	c.command.append("WITHPAYLOADS")
	return FtSearchWithpayloads(c)
}

func (c FtSearchVerbatim) Withsortkeys() FtSearchWithsortkeys {
	c.command.append("WITHSORTKEYS")
	return FtSearchWithsortkeys(c)
}

func (c FtSearchVerbatim) Filter(numericField string) FtSearchFilterFilter {
	c.command.append("FILTER", numericField)
	return FtSearchFilterFilter(c)
}

func (c FtSearchVerbatim) Geofilter(geoField string) FtSearchGeoFilterGeofilter {
	c.command.append("GEOFILTER", geoField)
	return FtSearchGeoFilterGeofilter(c)
}

func (c FtSearchVerbatim) Inkeys(count string) FtSearchInKeysInkeys {
	c.command.append("INKEYS", count)
	return FtSearchInKeysInkeys(c)
}

func (c FtSearchVerbatim) Infields(count string) FtSearchInFieldsInfields {
	c.command.append("INFIELDS", count)
	return FtSearchInFieldsInfields(c)
}

func (c FtSearchVerbatim) Return(count string) FtSearchReturnReturn {
	c.command.append("RETURN", count)
	return FtSearchReturnReturn(c)
}

func (c FtSearchVerbatim) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchVerbatim) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchVerbatim) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchVerbatim) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchVerbatim) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchVerbatim) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchVerbatim) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchVerbatim) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchVerbatim) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchVerbatim) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchVerbatim) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchVerbatim) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchVerbatim) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchVerbatim) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchVerbatim) Build() Completed {
	return completed(c)
}

type FtSearchWithpayloads Base

func (c FtSearchWithpayloads) Withsortkeys() FtSearchWithsortkeys {
	c.command.append("WITHSORTKEYS")
	return FtSearchWithsortkeys(c)
}

func (c FtSearchWithpayloads) Filter(numericField string) FtSearchFilterFilter {
	c.command.append("FILTER", numericField)
	return FtSearchFilterFilter(c)
}

func (c FtSearchWithpayloads) Geofilter(geoField string) FtSearchGeoFilterGeofilter {
	c.command.append("GEOFILTER", geoField)
	return FtSearchGeoFilterGeofilter(c)
}

func (c FtSearchWithpayloads) Inkeys(count string) FtSearchInKeysInkeys {
	c.command.append("INKEYS", count)
	return FtSearchInKeysInkeys(c)
}

func (c FtSearchWithpayloads) Infields(count string) FtSearchInFieldsInfields {
	c.command.append("INFIELDS", count)
	return FtSearchInFieldsInfields(c)
}

func (c FtSearchWithpayloads) Return(count string) FtSearchReturnReturn {
	c.command.append("RETURN", count)
	return FtSearchReturnReturn(c)
}

func (c FtSearchWithpayloads) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchWithpayloads) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchWithpayloads) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchWithpayloads) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchWithpayloads) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchWithpayloads) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchWithpayloads) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchWithpayloads) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchWithpayloads) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchWithpayloads) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchWithpayloads) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchWithpayloads) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchWithpayloads) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchWithpayloads) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchWithpayloads) Build() Completed {
	return completed(c)
}

type FtSearchWithscores Base

func (c FtSearchWithscores) Withpayloads() FtSearchWithpayloads {
	c.command.append("WITHPAYLOADS")
	return FtSearchWithpayloads(c)
}

func (c FtSearchWithscores) Withsortkeys() FtSearchWithsortkeys {
	c.command.append("WITHSORTKEYS")
	return FtSearchWithsortkeys(c)
}

func (c FtSearchWithscores) Filter(numericField string) FtSearchFilterFilter {
	c.command.append("FILTER", numericField)
	return FtSearchFilterFilter(c)
}

func (c FtSearchWithscores) Geofilter(geoField string) FtSearchGeoFilterGeofilter {
	c.command.append("GEOFILTER", geoField)
	return FtSearchGeoFilterGeofilter(c)
}

func (c FtSearchWithscores) Inkeys(count string) FtSearchInKeysInkeys {
	c.command.append("INKEYS", count)
	return FtSearchInKeysInkeys(c)
}

func (c FtSearchWithscores) Infields(count string) FtSearchInFieldsInfields {
	c.command.append("INFIELDS", count)
	return FtSearchInFieldsInfields(c)
}

func (c FtSearchWithscores) Return(count string) FtSearchReturnReturn {
	c.command.append("RETURN", count)
	return FtSearchReturnReturn(c)
}

func (c FtSearchWithscores) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchWithscores) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchWithscores) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchWithscores) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchWithscores) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchWithscores) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchWithscores) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchWithscores) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchWithscores) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchWithscores) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchWithscores) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchWithscores) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchWithscores) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchWithscores) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchWithscores) Build() Completed {
	return completed(c)
}

type FtSearchWithsortkeys Base

func (c FtSearchWithsortkeys) Filter(numericField string) FtSearchFilterFilter {
	c.command.append("FILTER", numericField)
	return FtSearchFilterFilter(c)
}

func (c FtSearchWithsortkeys) Geofilter(geoField string) FtSearchGeoFilterGeofilter {
	c.command.append("GEOFILTER", geoField)
	return FtSearchGeoFilterGeofilter(c)
}

func (c FtSearchWithsortkeys) Inkeys(count string) FtSearchInKeysInkeys {
	c.command.append("INKEYS", count)
	return FtSearchInKeysInkeys(c)
}

func (c FtSearchWithsortkeys) Infields(count string) FtSearchInFieldsInfields {
	c.command.append("INFIELDS", count)
	return FtSearchInFieldsInfields(c)
}

func (c FtSearchWithsortkeys) Return(count string) FtSearchReturnReturn {
	c.command.append("RETURN", count)
	return FtSearchReturnReturn(c)
}

func (c FtSearchWithsortkeys) Summarize() FtSearchSummarizeSummarize {
	c.command.append("SUMMARIZE")
	return FtSearchSummarizeSummarize(c)
}

func (c FtSearchWithsortkeys) Highlight() FtSearchHighlightHighlight {
	c.command.append("HIGHLIGHT")
	return FtSearchHighlightHighlight(c)
}

func (c FtSearchWithsortkeys) Slop(slop int64) FtSearchSlop {
	c.command.append("SLOP", strconv.FormatInt(slop, 10))
	return FtSearchSlop(c)
}

func (c FtSearchWithsortkeys) Timeout(timeout int64) FtSearchTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return FtSearchTimeout(c)
}

func (c FtSearchWithsortkeys) Inorder() FtSearchTagsInorder {
	c.command.append("INORDER")
	return FtSearchTagsInorder(c)
}

func (c FtSearchWithsortkeys) Language(language string) FtSearchLanguage {
	c.command.append("LANGUAGE", language)
	return FtSearchLanguage(c)
}

func (c FtSearchWithsortkeys) Expander(expander string) FtSearchExpander {
	c.command.append("EXPANDER", expander)
	return FtSearchExpander(c)
}

func (c FtSearchWithsortkeys) Scorer(scorer string) FtSearchScorer {
	c.command.append("SCORER", scorer)
	return FtSearchScorer(c)
}

func (c FtSearchWithsortkeys) Explainscore() FtSearchExplainscore {
	c.command.append("EXPLAINSCORE")
	return FtSearchExplainscore(c)
}

func (c FtSearchWithsortkeys) Payload(payload string) FtSearchPayload {
	c.command.append("PAYLOAD", payload)
	return FtSearchPayload(c)
}

func (c FtSearchWithsortkeys) Sortby(sortby string) FtSearchSortbySortby {
	c.command.append("SORTBY", sortby)
	return FtSearchSortbySortby(c)
}

func (c FtSearchWithsortkeys) Limit() FtSearchLimitLimit {
	c.command.append("LIMIT")
	return FtSearchLimitLimit(c)
}

func (c FtSearchWithsortkeys) Params() FtSearchParamsParams {
	c.command.append("PARAMS")
	return FtSearchParamsParams(c)
}

func (c FtSearchWithsortkeys) Dialect(dialect int64) FtSearchDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSearchDialect(c)
}

// Return Completed Redis command.
func (c FtSearchWithsortkeys) Build() Completed {
	return completed(c)
}

// Performs spelling correction on a query, returning suggestions for misspelled terms.
//
// Time complexity: O(1)
type FtSpellcheck Base

// Performs spelling correction on a query, returning suggestions for misspelled terms
//
// Command: FT.SPELLCHECK.
//
// Time complexity: O(1)
func (b Builder) FtSpellcheck() FtSpellcheck {
	c := FtSpellcheck{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.SPELLCHECK")
	return c
}

func (c FtSpellcheck) Index(index string) FtSpellcheckIndex {
	c.command.append(index)
	return FtSpellcheckIndex(c)
}

type FtSpellcheckDialect Base

// Return Completed Redis command.
func (c FtSpellcheckDialect) Build() Completed {
	return completed(c)
}

type FtSpellcheckDistance Base

func (c FtSpellcheckDistance) TermsInclude() FtSpellcheckTermsTermsInclude {
	c.command.append("TERMS", "INCLUDE")
	return FtSpellcheckTermsTermsInclude(c)
}

func (c FtSpellcheckDistance) TermsExclude() FtSpellcheckTermsTermsExclude {
	c.command.append("TERMS", "EXCLUDE")
	return FtSpellcheckTermsTermsExclude(c)
}

func (c FtSpellcheckDistance) Dialect(dialect int64) FtSpellcheckDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSpellcheckDialect(c)
}

// Return Completed Redis command.
func (c FtSpellcheckDistance) Build() Completed {
	return completed(c)
}

type FtSpellcheckIndex Base

func (c FtSpellcheckIndex) Query(query string) FtSpellcheckQuery {
	c.command.append(query)
	return FtSpellcheckQuery(c)
}

type FtSpellcheckQuery Base

func (c FtSpellcheckQuery) Distance(distance int64) FtSpellcheckDistance {
	c.command.append("DISTANCE", strconv.FormatInt(distance, 10))
	return FtSpellcheckDistance(c)
}

func (c FtSpellcheckQuery) TermsInclude() FtSpellcheckTermsTermsInclude {
	c.command.append("TERMS", "INCLUDE")
	return FtSpellcheckTermsTermsInclude(c)
}

func (c FtSpellcheckQuery) TermsExclude() FtSpellcheckTermsTermsExclude {
	c.command.append("TERMS", "EXCLUDE")
	return FtSpellcheckTermsTermsExclude(c)
}

func (c FtSpellcheckQuery) Dialect(dialect int64) FtSpellcheckDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSpellcheckDialect(c)
}

// Return Completed Redis command.
func (c FtSpellcheckQuery) Build() Completed {
	return completed(c)
}

type FtSpellcheckTermsDictionary Base

func (c FtSpellcheckTermsDictionary) Terms(terms ...string) FtSpellcheckTermsTerms {
	c.command.append(terms...)
	return FtSpellcheckTermsTerms(c)
}

func (c FtSpellcheckTermsDictionary) Dialect(dialect int64) FtSpellcheckDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSpellcheckDialect(c)
}

// Return Completed Redis command.
func (c FtSpellcheckTermsDictionary) Build() Completed {
	return completed(c)
}

type FtSpellcheckTermsTerms Base

func (c FtSpellcheckTermsTerms) Terms(terms ...string) FtSpellcheckTermsTerms {
	c.command.append(terms...)
	return c
}

func (c FtSpellcheckTermsTerms) Dialect(dialect int64) FtSpellcheckDialect {
	c.command.append("DIALECT", strconv.FormatInt(dialect, 10))
	return FtSpellcheckDialect(c)
}

// Return Completed Redis command.
func (c FtSpellcheckTermsTerms) Build() Completed {
	return completed(c)
}

type FtSpellcheckTermsTermsExclude Base

func (c FtSpellcheckTermsTermsExclude) Dictionary(dictionary string) FtSpellcheckTermsDictionary {
	c.command.append(dictionary)
	return FtSpellcheckTermsDictionary(c)
}

type FtSpellcheckTermsTermsInclude Base

func (c FtSpellcheckTermsTermsInclude) Dictionary(dictionary string) FtSpellcheckTermsDictionary {
	c.command.append(dictionary)
	return FtSpellcheckTermsDictionary(c)
}

// Adds a suggestion string to an auto-complete suggestion dictionary.
//
// Time complexity: O(1)
type FtSugadd Base

// Adds a suggestion string to an auto-complete suggestion dictionary
//
// Command: FT.SUGADD.
//
// Time complexity: O(1)
func (b Builder) FtSugadd() FtSugadd {
	c := FtSugadd{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.SUGADD")
	return c
}

func (c FtSugadd) Key(key string) FtSugaddKey {
	c.command.append(key)
	return FtSugaddKey(c)
}

type FtSugaddIncrementScoreIncr Base

func (c FtSugaddIncrementScoreIncr) Payload(payload string) FtSugaddPayload {
	c.command.append("PAYLOAD", payload)
	return FtSugaddPayload(c)
}

// Return Completed Redis command.
func (c FtSugaddIncrementScoreIncr) Build() Completed {
	return completed(c)
}

type FtSugaddKey Base

func (c FtSugaddKey) String(string string) FtSugaddString {
	c.command.append(string)
	return FtSugaddString(c)
}

type FtSugaddPayload Base

// Return Completed Redis command.
func (c FtSugaddPayload) Build() Completed {
	return completed(c)
}

type FtSugaddScore Base

func (c FtSugaddScore) Incr() FtSugaddIncrementScoreIncr {
	c.command.append("INCR")
	return FtSugaddIncrementScoreIncr(c)
}

func (c FtSugaddScore) Payload(payload string) FtSugaddPayload {
	c.command.append("PAYLOAD", payload)
	return FtSugaddPayload(c)
}

// Return Completed Redis command.
func (c FtSugaddScore) Build() Completed {
	return completed(c)
}

type FtSugaddString Base

func (c FtSugaddString) Score(score float64) FtSugaddScore {
	c.command.append(strconv.FormatFloat(score, 'f', -1, 64))
	return FtSugaddScore(c)
}

// Deletes a string from a suggestion index.
//
// Time complexity: O(1)
type FtSugdel Base

// Deletes a string from a suggestion index
//
// Command: FT.SUGDEL.
//
// Time complexity: O(1)
func (b Builder) FtSugdel() FtSugdel {
	c := FtSugdel{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.SUGDEL")
	return c
}

func (c FtSugdel) Key(key string) FtSugdelKey {
	c.command.append(key)
	return FtSugdelKey(c)
}

type FtSugdelKey Base

func (c FtSugdelKey) String(string string) FtSugdelString {
	c.command.append(string)
	return FtSugdelString(c)
}

type FtSugdelString Base

// Return Completed Redis command.
func (c FtSugdelString) Build() Completed {
	return completed(c)
}

// Gets completion suggestions for a prefix.
//
// Time complexity: O(1)
type FtSugget Base

// Gets completion suggestions for a prefix
//
// Command: FT.SUGGET.
//
// Time complexity: O(1)
func (b Builder) FtSugget() FtSugget {
	c := FtSugget{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.SUGGET")
	return c
}

func (c FtSugget) Key(key string) FtSuggetKey {
	c.command.append(key)
	return FtSuggetKey(c)
}

type FtSuggetFuzzy Base

func (c FtSuggetFuzzy) Withscores() FtSuggetWithscores {
	c.command.append("WITHSCORES")
	return FtSuggetWithscores(c)
}

func (c FtSuggetFuzzy) Withpayloads() FtSuggetWithpayloads {
	c.command.append("WITHPAYLOADS")
	return FtSuggetWithpayloads(c)
}

func (c FtSuggetFuzzy) Max(max int64) FtSuggetMax {
	c.command.append("MAX", strconv.FormatInt(max, 10))
	return FtSuggetMax(c)
}

// Return Completed Redis command.
func (c FtSuggetFuzzy) Build() Completed {
	return completed(c)
}

type FtSuggetKey Base

func (c FtSuggetKey) Prefix(prefix string) FtSuggetPrefix {
	c.command.append(prefix)
	return FtSuggetPrefix(c)
}

type FtSuggetMax Base

// Return Completed Redis command.
func (c FtSuggetMax) Build() Completed {
	return completed(c)
}

type FtSuggetPrefix Base

func (c FtSuggetPrefix) Fuzzy() FtSuggetFuzzy {
	c.command.append("FUZZY")
	return FtSuggetFuzzy(c)
}

func (c FtSuggetPrefix) Withscores() FtSuggetWithscores {
	c.command.append("WITHSCORES")
	return FtSuggetWithscores(c)
}

func (c FtSuggetPrefix) Withpayloads() FtSuggetWithpayloads {
	c.command.append("WITHPAYLOADS")
	return FtSuggetWithpayloads(c)
}

func (c FtSuggetPrefix) Max(max int64) FtSuggetMax {
	c.command.append("MAX", strconv.FormatInt(max, 10))
	return FtSuggetMax(c)
}

// Return Completed Redis command.
func (c FtSuggetPrefix) Build() Completed {
	return completed(c)
}

type FtSuggetWithpayloads Base

func (c FtSuggetWithpayloads) Max(max int64) FtSuggetMax {
	c.command.append("MAX", strconv.FormatInt(max, 10))
	return FtSuggetMax(c)
}

// Return Completed Redis command.
func (c FtSuggetWithpayloads) Build() Completed {
	return completed(c)
}

type FtSuggetWithscores Base

func (c FtSuggetWithscores) Withpayloads() FtSuggetWithpayloads {
	c.command.append("WITHPAYLOADS")
	return FtSuggetWithpayloads(c)
}

func (c FtSuggetWithscores) Max(max int64) FtSuggetMax {
	c.command.append("MAX", strconv.FormatInt(max, 10))
	return FtSuggetMax(c)
}

// Return Completed Redis command.
func (c FtSuggetWithscores) Build() Completed {
	return completed(c)
}

// Gets the size of an auto-complete suggestion dictionary.
//
// Time complexity: O(1)
type FtSuglen Base

// Gets the size of an auto-complete suggestion dictionary
//
// Command: FT.SUGLEN.
//
// Time complexity: O(1)
func (b Builder) FtSuglen() FtSuglen {
	c := FtSuglen{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.SUGLEN")
	return c
}

func (c FtSuglen) Key(key string) FtSuglenKey {
	c.command.append(key)
	return FtSuglenKey(c)
}

type FtSuglenKey Base

// Return Completed Redis command.
func (c FtSuglenKey) Build() Completed {
	return completed(c)
}

// Dumps the contents of a synonym group.
//
// Time complexity: O(1)
type FtSyndump Base

// Dumps the contents of a synonym group
//
// Command: FT.SYNDUMP.
//
// Time complexity: O(1)
func (b Builder) FtSyndump() FtSyndump {
	c := FtSyndump{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.SYNDUMP")
	return c
}

func (c FtSyndump) Index(index string) FtSyndumpIndex {
	c.command.append(index)
	return FtSyndumpIndex(c)
}

type FtSyndumpIndex Base

// Return Completed Redis command.
func (c FtSyndumpIndex) Build() Completed {
	return completed(c)
}

// Creates or updates a synonym group with additional terms.
//
// Time complexity: O(1)
type FtSynupdate Base

// Creates or updates a synonym group with additional terms
//
// Command: FT.SYNUPDATE.
//
// Time complexity: O(1)
func (b Builder) FtSynupdate() FtSynupdate {
	c := FtSynupdate{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.SYNUPDATE")
	return c
}

func (c FtSynupdate) Index(index string) FtSynupdateIndex {
	c.command.append(index)
	return FtSynupdateIndex(c)
}

type FtSynupdateIndex Base

func (c FtSynupdateIndex) SynonymGroupId(synonymGroupId string) FtSynupdateSynonymGroupId {
	c.command.append(synonymGroupId)
	return FtSynupdateSynonymGroupId(c)
}

type FtSynupdateSkipinitialscan Base

func (c FtSynupdateSkipinitialscan) Term(term ...string) FtSynupdateTerm {
	c.command.append(term...)
	return FtSynupdateTerm(c)
}

type FtSynupdateSynonymGroupId Base

func (c FtSynupdateSynonymGroupId) Skipinitialscan() FtSynupdateSkipinitialscan {
	c.command.append("SKIPINITIALSCAN")
	return FtSynupdateSkipinitialscan(c)
}

func (c FtSynupdateSynonymGroupId) Term(term ...string) FtSynupdateTerm {
	c.command.append(term...)
	return FtSynupdateTerm(c)
}

type FtSynupdateTerm Base

func (c FtSynupdateTerm) Term(term ...string) FtSynupdateTerm {
	c.command.append(term...)
	return c
}

// Return Completed Redis command.
func (c FtSynupdateTerm) Build() Completed {
	return completed(c)
}

// Returns the distinct tags indexed in a Tag field.
//
// Time complexity: O(N)
type FtTagvals Base

// Returns the distinct tags indexed in a Tag field
//
// Command: FT.TAGVALS.
//
// Time complexity: O(N)
func (b Builder) FtTagvals() FtTagvals {
	c := FtTagvals{command: emptyCommand(), cslot: b.slot}
	c.command.append("FT.TAGVALS")
	return c
}

func (c FtTagvals) Index(index string) FtTagvalsIndex {
	c.command.append(index)
	return FtTagvalsIndex(c)
}

type FtTagvalsFieldName Base

// Return Completed Redis command.
func (c FtTagvalsFieldName) Build() Completed {
	return completed(c)
}

type FtTagvalsIndex Base

func (c FtTagvalsIndex) FieldName(fieldName string) FtTagvalsFieldName {
	c.command.append(fieldName)
	return FtTagvalsFieldName(c)
}

type FunctionDelete Base

// Command: FUNCTION DELETE.
func (b Builder) FunctionDelete() FunctionDelete {
	c := FunctionDelete{command: emptyCommand(), cslot: b.slot}
	c.command.append("FUNCTION", "DELETE")
	return c
}

func (c FunctionDelete) LibraryName(libraryName string) FunctionDeleteLibraryName {
	c.command.append(libraryName)
	return FunctionDeleteLibraryName(c)
}

type FunctionDeleteLibraryName Base

// Return Completed Redis command.
func (c FunctionDeleteLibraryName) Build() Completed {
	return completed(c)
}

type FunctionDump Base

// Command: FUNCTION DUMP.
func (b Builder) FunctionDump() FunctionDump {
	c := FunctionDump{command: emptyCommand(), cslot: b.slot}
	c.command.append("FUNCTION", "DUMP")
	return c
}

// Return Completed Redis command.
func (c FunctionDump) Build() Completed {
	return completed(c)
}

type FunctionFlush Base

// Command: FUNCTION FLUSH.
func (b Builder) FunctionFlush() FunctionFlush {
	c := FunctionFlush{command: emptyCommand(), cslot: b.slot}
	c.command.append("FUNCTION", "FLUSH")
	return c
}

func (c FunctionFlush) Async() FunctionFlushAsync {
	c.command.append("ASYNC")
	return FunctionFlushAsync(c)
}

func (c FunctionFlush) Sync() FunctionFlushAsyncSync {
	c.command.append("SYNC")
	return FunctionFlushAsyncSync(c)
}

// Return Completed Redis command.
func (c FunctionFlush) Build() Completed {
	return completed(c)
}

type FunctionFlushAsync Base

// Return Completed Redis command.
func (c FunctionFlushAsync) Build() Completed {
	return completed(c)
}

type FunctionFlushAsyncSync Base

// Return Completed Redis command.
func (c FunctionFlushAsyncSync) Build() Completed {
	return completed(c)
}

type FunctionHelp Base

// Command: FUNCTION HELP.
func (b Builder) FunctionHelp() FunctionHelp {
	c := FunctionHelp{command: emptyCommand(), cslot: b.slot}
	c.command.append("FUNCTION", "HELP")
	return c
}

// Return Completed Redis command.
func (c FunctionHelp) Build() Completed {
	return completed(c)
}

type FunctionKill Base

// Command: FUNCTION KILL.
func (b Builder) FunctionKill() FunctionKill {
	c := FunctionKill{command: emptyCommand(), cslot: b.slot}
	c.command.append("FUNCTION", "KILL")
	return c
}

// Return Completed Redis command.
func (c FunctionKill) Build() Completed {
	return completed(c)
}

type FunctionList Base

// Command: FUNCTION LIST.
func (b Builder) FunctionList() FunctionList {
	c := FunctionList{command: emptyCommand(), cslot: b.slot}
	c.command.append("FUNCTION", "LIST")
	return c
}

func (c FunctionList) Libraryname(libraryNamePattern string) FunctionListLibraryname {
	c.command.append("LIBRARYNAME", libraryNamePattern)
	return FunctionListLibraryname(c)
}

func (c FunctionList) Withcode() FunctionListWithcode {
	c.command.append("WITHCODE")
	return FunctionListWithcode(c)
}

// Return Completed Redis command.
func (c FunctionList) Build() Completed {
	return completed(c)
}

type FunctionListLibraryname Base

func (c FunctionListLibraryname) Withcode() FunctionListWithcode {
	c.command.append("WITHCODE")
	return FunctionListWithcode(c)
}

// Return Completed Redis command.
func (c FunctionListLibraryname) Build() Completed {
	return completed(c)
}

type FunctionListWithcode Base

// Return Completed Redis command.
func (c FunctionListWithcode) Build() Completed {
	return completed(c)
}

type FunctionLoad Base

// Command: FUNCTION LOAD.
func (b Builder) FunctionLoad() FunctionLoad {
	c := FunctionLoad{command: emptyCommand(), cslot: b.slot}
	c.command.append("FUNCTION", "LOAD")
	return c
}

func (c FunctionLoad) Replace() FunctionLoadReplace {
	c.command.append("REPLACE")
	return FunctionLoadReplace(c)
}

func (c FunctionLoad) FunctionCode(functionCode string) FunctionLoadFunctionCode {
	c.command.append(functionCode)
	return FunctionLoadFunctionCode(c)
}

type FunctionLoadFunctionCode Base

// Return Completed Redis command.
func (c FunctionLoadFunctionCode) Build() Completed {
	return completed(c)
}

type FunctionLoadReplace Base

func (c FunctionLoadReplace) FunctionCode(functionCode string) FunctionLoadFunctionCode {
	c.command.append(functionCode)
	return FunctionLoadFunctionCode(c)
}

type FunctionRestore Base

// Command: FUNCTION RESTORE.
func (b Builder) FunctionRestore() FunctionRestore {
	c := FunctionRestore{command: emptyCommand(), cslot: b.slot}
	c.command.append("FUNCTION", "RESTORE")
	return c
}

func (c FunctionRestore) SerializedValue(serializedValue string) FunctionRestoreSerializedValue {
	c.command.append(serializedValue)
	return FunctionRestoreSerializedValue(c)
}

type FunctionRestorePolicyAppend Base

// Return Completed Redis command.
func (c FunctionRestorePolicyAppend) Build() Completed {
	return completed(c)
}

type FunctionRestorePolicyFlush Base

// Return Completed Redis command.
func (c FunctionRestorePolicyFlush) Build() Completed {
	return completed(c)
}

type FunctionRestorePolicyReplace Base

// Return Completed Redis command.
func (c FunctionRestorePolicyReplace) Build() Completed {
	return completed(c)
}

type FunctionRestoreSerializedValue Base

func (c FunctionRestoreSerializedValue) Flush() FunctionRestorePolicyFlush {
	c.command.append("FLUSH")
	return FunctionRestorePolicyFlush(c)
}

func (c FunctionRestoreSerializedValue) Append() FunctionRestorePolicyAppend {
	c.command.append("APPEND")
	return FunctionRestorePolicyAppend(c)
}

func (c FunctionRestoreSerializedValue) Replace() FunctionRestorePolicyReplace {
	c.command.append("REPLACE")
	return FunctionRestorePolicyReplace(c)
}

// Return Completed Redis command.
func (c FunctionRestoreSerializedValue) Build() Completed {
	return completed(c)
}

type FunctionStats Base

// Command: FUNCTION STATS.
func (b Builder) FunctionStats() FunctionStats {
	c := FunctionStats{command: emptyCommand(), cslot: b.slot}
	c.command.append("FUNCTION", "STATS")
	return c
}

// Return Completed Redis command.
func (c FunctionStats) Build() Completed {
	return completed(c)
}

// Add one or more geospatial items in the geospatial index represented using a sorted set.
//
// Time complexity: O(log(N)) for each item added, where N is the number of elements in the sorted set.
type Geoadd Base

// Add one or more geospatial items in the geospatial index represented using a sorted set
//
// Command: GEOADD.
//
// Time complexity: O(log(N)) for each item added, where N is the number of elements in the sorted set.
func (b Builder) Geoadd() Geoadd {
	c := Geoadd{command: emptyCommand(), cslot: b.slot}
	c.command.append("GEOADD")
	return c
}

func (c Geoadd) Key(key string) GeoaddKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return GeoaddKey(c)
}

type GeoaddChangeCh Base

func (c GeoaddChangeCh) LongitudeLatitudeMember() GeoaddLongitudeLatitudeMember {
	return GeoaddLongitudeLatitudeMember(c)
}

type GeoaddConditionNx Base

func (c GeoaddConditionNx) Ch() GeoaddChangeCh {
	c.command.append("CH")
	return GeoaddChangeCh(c)
}

func (c GeoaddConditionNx) LongitudeLatitudeMember() GeoaddLongitudeLatitudeMember {
	return GeoaddLongitudeLatitudeMember(c)
}

type GeoaddConditionXx Base

func (c GeoaddConditionXx) Ch() GeoaddChangeCh {
	c.command.append("CH")
	return GeoaddChangeCh(c)
}

func (c GeoaddConditionXx) LongitudeLatitudeMember() GeoaddLongitudeLatitudeMember {
	return GeoaddLongitudeLatitudeMember(c)
}

type GeoaddKey Base

func (c GeoaddKey) Nx() GeoaddConditionNx {
	c.command.append("NX")
	return GeoaddConditionNx(c)
}

func (c GeoaddKey) Xx() GeoaddConditionXx {
	c.command.append("XX")
	return GeoaddConditionXx(c)
}

func (c GeoaddKey) Ch() GeoaddChangeCh {
	c.command.append("CH")
	return GeoaddChangeCh(c)
}

func (c GeoaddKey) LongitudeLatitudeMember() GeoaddLongitudeLatitudeMember {
	return GeoaddLongitudeLatitudeMember(c)
}

type GeoaddLongitudeLatitudeMember Base

func (c GeoaddLongitudeLatitudeMember) LongitudeLatitudeMember(longitude float64, latitude float64, member string) GeoaddLongitudeLatitudeMember {
	c.command.append(strconv.FormatFloat(longitude, 'f', -1, 64), strconv.FormatFloat(latitude, 'f', -1, 64), member)
	return c
}

// Return Completed Redis command.
func (c GeoaddLongitudeLatitudeMember) Build() Completed {
	return completed(c)
}

// Returns the distance between two members of a geospatial index.
//
// Time complexity: O(log(N))
type Geodist Base

// Returns the distance between two members of a geospatial index
//
// Command: GEODIST.
//
// Time complexity: O(log(N))
func (b Builder) Geodist() Geodist {
	c := Geodist{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("GEODIST")
	return c
}

func (c Geodist) Key(key string) GeodistKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return GeodistKey(c)
}

type GeodistKey Base

func (c GeodistKey) Member1(member1 string) GeodistMember1 {
	c.command.append(member1)
	return GeodistMember1(c)
}

type GeodistMember1 Base

func (c GeodistMember1) Member2(member2 string) GeodistMember2 {
	c.command.append(member2)
	return GeodistMember2(c)
}

type GeodistMember2 Base

func (c GeodistMember2) M() GeodistUnitM {
	c.command.append("m")
	return GeodistUnitM(c)
}

func (c GeodistMember2) Km() GeodistUnitKm {
	c.command.append("km")
	return GeodistUnitKm(c)
}

func (c GeodistMember2) Ft() GeodistUnitFt {
	c.command.append("ft")
	return GeodistUnitFt(c)
}

func (c GeodistMember2) Mi() GeodistUnitMi {
	c.command.append("mi")
	return GeodistUnitMi(c)
}

// Return Completed Redis command.
func (c GeodistMember2) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeodistMember2) Cache() Cacheable {
	return cacheable(c)
}

type GeodistUnitFt Base

// Return Completed Redis command.
func (c GeodistUnitFt) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeodistUnitFt) Cache() Cacheable {
	return cacheable(c)
}

type GeodistUnitKm Base

// Return Completed Redis command.
func (c GeodistUnitKm) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeodistUnitKm) Cache() Cacheable {
	return cacheable(c)
}

type GeodistUnitM Base

// Return Completed Redis command.
func (c GeodistUnitM) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeodistUnitM) Cache() Cacheable {
	return cacheable(c)
}

type GeodistUnitMi Base

// Return Completed Redis command.
func (c GeodistUnitMi) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeodistUnitMi) Cache() Cacheable {
	return cacheable(c)
}

// Returns members of a geospatial index as standard geohash strings.
//
// Time complexity: O(log(N)) for each member requested, where N is the number of elements in the sorted set.
type Geohash Base

// Returns members of a geospatial index as standard geohash strings
//
// Command: GEOHASH.
//
// Time complexity: O(log(N)) for each member requested, where N is the number of elements in the sorted set.
func (b Builder) Geohash() Geohash {
	c := Geohash{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("GEOHASH")
	return c
}

func (c Geohash) Key(key string) GeohashKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return GeohashKey(c)
}

type GeohashKey Base

func (c GeohashKey) Member(member ...string) GeohashMember {
	c.command.append(member...)
	return GeohashMember(c)
}

type GeohashMember Base

func (c GeohashMember) Member(member ...string) GeohashMember {
	c.command.append(member...)
	return c
}

// Return Completed Redis command.
func (c GeohashMember) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeohashMember) Cache() Cacheable {
	return cacheable(c)
}

// Returns longitude and latitude of members of a geospatial index.
//
// Time complexity: O(N) where N is the number of members requested.
type Geopos Base

// Returns longitude and latitude of members of a geospatial index
//
// Command: GEOPOS.
//
// Time complexity: O(N) where N is the number of members requested.
func (b Builder) Geopos() Geopos {
	c := Geopos{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("GEOPOS")
	return c
}

func (c Geopos) Key(key string) GeoposKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return GeoposKey(c)
}

type GeoposKey Base

func (c GeoposKey) Member(member ...string) GeoposMember {
	c.command.append(member...)
	return GeoposMember(c)
}

type GeoposMember Base

func (c GeoposMember) Member(member ...string) GeoposMember {
	c.command.append(member...)
	return c
}

// Return Completed Redis command.
func (c GeoposMember) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoposMember) Cache() Cacheable {
	return cacheable(c)
}

// Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point.
//
// Time complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
type Georadius Base

// Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point
//
// Command: GEORADIUS.
//
// Time complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
func (b Builder) Georadius() Georadius {
	c := Georadius{command: emptyCommand(), cslot: b.slot}
	c.command.append("GEORADIUS")
	return c
}

func (c Georadius) Key(key string) GeoradiusKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return GeoradiusKey(c)
}

type GeoradiusCountAny Base

func (c GeoradiusCountAny) Asc() GeoradiusOrderAsc {
	c.command.append("ASC")
	return GeoradiusOrderAsc(c)
}

func (c GeoradiusCountAny) Desc() GeoradiusOrderDesc {
	c.command.append("DESC")
	return GeoradiusOrderDesc(c)
}

func (c GeoradiusCountAny) Store(key string) GeoradiusStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusStore(c)
}

func (c GeoradiusCountAny) Storedist(key string) GeoradiusStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusCountAny) Build() Completed {
	return completed(c)
}

type GeoradiusCountCount Base

func (c GeoradiusCountCount) Any() GeoradiusCountAny {
	c.command.append("ANY")
	return GeoradiusCountAny(c)
}

func (c GeoradiusCountCount) Asc() GeoradiusOrderAsc {
	c.command.append("ASC")
	return GeoradiusOrderAsc(c)
}

func (c GeoradiusCountCount) Desc() GeoradiusOrderDesc {
	c.command.append("DESC")
	return GeoradiusOrderDesc(c)
}

func (c GeoradiusCountCount) Store(key string) GeoradiusStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusStore(c)
}

func (c GeoradiusCountCount) Storedist(key string) GeoradiusStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusCountCount) Build() Completed {
	return completed(c)
}

type GeoradiusKey Base

func (c GeoradiusKey) Longitude(longitude float64) GeoradiusLongitude {
	c.command.append(strconv.FormatFloat(longitude, 'f', -1, 64))
	return GeoradiusLongitude(c)
}

type GeoradiusLatitude Base

func (c GeoradiusLatitude) Radius(radius float64) GeoradiusRadius {
	c.command.append(strconv.FormatFloat(radius, 'f', -1, 64))
	return GeoradiusRadius(c)
}

type GeoradiusLongitude Base

func (c GeoradiusLongitude) Latitude(latitude float64) GeoradiusLatitude {
	c.command.append(strconv.FormatFloat(latitude, 'f', -1, 64))
	return GeoradiusLatitude(c)
}

type GeoradiusOrderAsc Base

func (c GeoradiusOrderAsc) Store(key string) GeoradiusStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusStore(c)
}

func (c GeoradiusOrderAsc) Storedist(key string) GeoradiusStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusOrderAsc) Build() Completed {
	return completed(c)
}

type GeoradiusOrderDesc Base

func (c GeoradiusOrderDesc) Store(key string) GeoradiusStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusStore(c)
}

func (c GeoradiusOrderDesc) Storedist(key string) GeoradiusStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusOrderDesc) Build() Completed {
	return completed(c)
}

type GeoradiusRadius Base

func (c GeoradiusRadius) M() GeoradiusUnitM {
	c.command.append("m")
	return GeoradiusUnitM(c)
}

func (c GeoradiusRadius) Km() GeoradiusUnitKm {
	c.command.append("km")
	return GeoradiusUnitKm(c)
}

func (c GeoradiusRadius) Ft() GeoradiusUnitFt {
	c.command.append("ft")
	return GeoradiusUnitFt(c)
}

func (c GeoradiusRadius) Mi() GeoradiusUnitMi {
	c.command.append("mi")
	return GeoradiusUnitMi(c)
}

type GeoradiusRo Base

// Command: GEORADIUS_RO.
func (b Builder) GeoradiusRo() GeoradiusRo {
	c := GeoradiusRo{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("GEORADIUS_RO")
	return c
}

func (c GeoradiusRo) Key(key string) GeoradiusRoKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return GeoradiusRoKey(c)
}

type GeoradiusRoCountAny Base

func (c GeoradiusRoCountAny) Asc() GeoradiusRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusRoOrderAsc(c)
}

func (c GeoradiusRoCountAny) Desc() GeoradiusRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusRoCountAny) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusRoCountAny) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusRoCountCount Base

func (c GeoradiusRoCountCount) Any() GeoradiusRoCountAny {
	c.command.append("ANY")
	return GeoradiusRoCountAny(c)
}

func (c GeoradiusRoCountCount) Asc() GeoradiusRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusRoOrderAsc(c)
}

func (c GeoradiusRoCountCount) Desc() GeoradiusRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusRoCountCount) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusRoCountCount) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusRoKey Base

func (c GeoradiusRoKey) Longitude(longitude float64) GeoradiusRoLongitude {
	c.command.append(strconv.FormatFloat(longitude, 'f', -1, 64))
	return GeoradiusRoLongitude(c)
}

type GeoradiusRoLatitude Base

func (c GeoradiusRoLatitude) Radius(radius float64) GeoradiusRoRadius {
	c.command.append(strconv.FormatFloat(radius, 'f', -1, 64))
	return GeoradiusRoRadius(c)
}

type GeoradiusRoLongitude Base

func (c GeoradiusRoLongitude) Latitude(latitude float64) GeoradiusRoLatitude {
	c.command.append(strconv.FormatFloat(latitude, 'f', -1, 64))
	return GeoradiusRoLatitude(c)
}

type GeoradiusRoOrderAsc Base

// Return Completed Redis command.
func (c GeoradiusRoOrderAsc) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusRoOrderAsc) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusRoOrderDesc Base

// Return Completed Redis command.
func (c GeoradiusRoOrderDesc) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusRoOrderDesc) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusRoRadius Base

func (c GeoradiusRoRadius) M() GeoradiusRoUnitM {
	c.command.append("m")
	return GeoradiusRoUnitM(c)
}

func (c GeoradiusRoRadius) Km() GeoradiusRoUnitKm {
	c.command.append("km")
	return GeoradiusRoUnitKm(c)
}

func (c GeoradiusRoRadius) Ft() GeoradiusRoUnitFt {
	c.command.append("ft")
	return GeoradiusRoUnitFt(c)
}

func (c GeoradiusRoRadius) Mi() GeoradiusRoUnitMi {
	c.command.append("mi")
	return GeoradiusRoUnitMi(c)
}

type GeoradiusRoUnitFt Base

func (c GeoradiusRoUnitFt) Withcoord() GeoradiusRoWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusRoWithcoord(c)
}

func (c GeoradiusRoUnitFt) Withdist() GeoradiusRoWithdist {
	c.command.append("WITHDIST")
	return GeoradiusRoWithdist(c)
}

func (c GeoradiusRoUnitFt) Withhash() GeoradiusRoWithhash {
	c.command.append("WITHHASH")
	return GeoradiusRoWithhash(c)
}

func (c GeoradiusRoUnitFt) Count(count int64) GeoradiusRoCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusRoCountCount(c)
}

func (c GeoradiusRoUnitFt) Asc() GeoradiusRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusRoOrderAsc(c)
}

func (c GeoradiusRoUnitFt) Desc() GeoradiusRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusRoUnitFt) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusRoUnitFt) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusRoUnitKm Base

func (c GeoradiusRoUnitKm) Withcoord() GeoradiusRoWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusRoWithcoord(c)
}

func (c GeoradiusRoUnitKm) Withdist() GeoradiusRoWithdist {
	c.command.append("WITHDIST")
	return GeoradiusRoWithdist(c)
}

func (c GeoradiusRoUnitKm) Withhash() GeoradiusRoWithhash {
	c.command.append("WITHHASH")
	return GeoradiusRoWithhash(c)
}

func (c GeoradiusRoUnitKm) Count(count int64) GeoradiusRoCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusRoCountCount(c)
}

func (c GeoradiusRoUnitKm) Asc() GeoradiusRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusRoOrderAsc(c)
}

func (c GeoradiusRoUnitKm) Desc() GeoradiusRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusRoUnitKm) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusRoUnitKm) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusRoUnitM Base

func (c GeoradiusRoUnitM) Withcoord() GeoradiusRoWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusRoWithcoord(c)
}

func (c GeoradiusRoUnitM) Withdist() GeoradiusRoWithdist {
	c.command.append("WITHDIST")
	return GeoradiusRoWithdist(c)
}

func (c GeoradiusRoUnitM) Withhash() GeoradiusRoWithhash {
	c.command.append("WITHHASH")
	return GeoradiusRoWithhash(c)
}

func (c GeoradiusRoUnitM) Count(count int64) GeoradiusRoCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusRoCountCount(c)
}

func (c GeoradiusRoUnitM) Asc() GeoradiusRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusRoOrderAsc(c)
}

func (c GeoradiusRoUnitM) Desc() GeoradiusRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusRoUnitM) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusRoUnitM) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusRoUnitMi Base

func (c GeoradiusRoUnitMi) Withcoord() GeoradiusRoWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusRoWithcoord(c)
}

func (c GeoradiusRoUnitMi) Withdist() GeoradiusRoWithdist {
	c.command.append("WITHDIST")
	return GeoradiusRoWithdist(c)
}

func (c GeoradiusRoUnitMi) Withhash() GeoradiusRoWithhash {
	c.command.append("WITHHASH")
	return GeoradiusRoWithhash(c)
}

func (c GeoradiusRoUnitMi) Count(count int64) GeoradiusRoCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusRoCountCount(c)
}

func (c GeoradiusRoUnitMi) Asc() GeoradiusRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusRoOrderAsc(c)
}

func (c GeoradiusRoUnitMi) Desc() GeoradiusRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusRoUnitMi) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusRoUnitMi) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusRoWithcoord Base

func (c GeoradiusRoWithcoord) Withdist() GeoradiusRoWithdist {
	c.command.append("WITHDIST")
	return GeoradiusRoWithdist(c)
}

func (c GeoradiusRoWithcoord) Withhash() GeoradiusRoWithhash {
	c.command.append("WITHHASH")
	return GeoradiusRoWithhash(c)
}

func (c GeoradiusRoWithcoord) Count(count int64) GeoradiusRoCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusRoCountCount(c)
}

func (c GeoradiusRoWithcoord) Asc() GeoradiusRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusRoOrderAsc(c)
}

func (c GeoradiusRoWithcoord) Desc() GeoradiusRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusRoWithcoord) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusRoWithcoord) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusRoWithdist Base

func (c GeoradiusRoWithdist) Withhash() GeoradiusRoWithhash {
	c.command.append("WITHHASH")
	return GeoradiusRoWithhash(c)
}

func (c GeoradiusRoWithdist) Count(count int64) GeoradiusRoCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusRoCountCount(c)
}

func (c GeoradiusRoWithdist) Asc() GeoradiusRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusRoOrderAsc(c)
}

func (c GeoradiusRoWithdist) Desc() GeoradiusRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusRoWithdist) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusRoWithdist) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusRoWithhash Base

func (c GeoradiusRoWithhash) Count(count int64) GeoradiusRoCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusRoCountCount(c)
}

func (c GeoradiusRoWithhash) Asc() GeoradiusRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusRoOrderAsc(c)
}

func (c GeoradiusRoWithhash) Desc() GeoradiusRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusRoWithhash) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusRoWithhash) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusStore Base

func (c GeoradiusStore) Storedist(key string) GeoradiusStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusStore) Build() Completed {
	return completed(c)
}

type GeoradiusStoredist Base

// Return Completed Redis command.
func (c GeoradiusStoredist) Build() Completed {
	return completed(c)
}

type GeoradiusUnitFt Base

func (c GeoradiusUnitFt) Withcoord() GeoradiusWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusWithcoord(c)
}

func (c GeoradiusUnitFt) Withdist() GeoradiusWithdist {
	c.command.append("WITHDIST")
	return GeoradiusWithdist(c)
}

func (c GeoradiusUnitFt) Withhash() GeoradiusWithhash {
	c.command.append("WITHHASH")
	return GeoradiusWithhash(c)
}

func (c GeoradiusUnitFt) Count(count int64) GeoradiusCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusCountCount(c)
}

func (c GeoradiusUnitFt) Asc() GeoradiusOrderAsc {
	c.command.append("ASC")
	return GeoradiusOrderAsc(c)
}

func (c GeoradiusUnitFt) Desc() GeoradiusOrderDesc {
	c.command.append("DESC")
	return GeoradiusOrderDesc(c)
}

func (c GeoradiusUnitFt) Store(key string) GeoradiusStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusStore(c)
}

func (c GeoradiusUnitFt) Storedist(key string) GeoradiusStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusUnitFt) Build() Completed {
	return completed(c)
}

type GeoradiusUnitKm Base

func (c GeoradiusUnitKm) Withcoord() GeoradiusWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusWithcoord(c)
}

func (c GeoradiusUnitKm) Withdist() GeoradiusWithdist {
	c.command.append("WITHDIST")
	return GeoradiusWithdist(c)
}

func (c GeoradiusUnitKm) Withhash() GeoradiusWithhash {
	c.command.append("WITHHASH")
	return GeoradiusWithhash(c)
}

func (c GeoradiusUnitKm) Count(count int64) GeoradiusCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusCountCount(c)
}

func (c GeoradiusUnitKm) Asc() GeoradiusOrderAsc {
	c.command.append("ASC")
	return GeoradiusOrderAsc(c)
}

func (c GeoradiusUnitKm) Desc() GeoradiusOrderDesc {
	c.command.append("DESC")
	return GeoradiusOrderDesc(c)
}

func (c GeoradiusUnitKm) Store(key string) GeoradiusStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusStore(c)
}

func (c GeoradiusUnitKm) Storedist(key string) GeoradiusStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusUnitKm) Build() Completed {
	return completed(c)
}

type GeoradiusUnitM Base

func (c GeoradiusUnitM) Withcoord() GeoradiusWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusWithcoord(c)
}

func (c GeoradiusUnitM) Withdist() GeoradiusWithdist {
	c.command.append("WITHDIST")
	return GeoradiusWithdist(c)
}

func (c GeoradiusUnitM) Withhash() GeoradiusWithhash {
	c.command.append("WITHHASH")
	return GeoradiusWithhash(c)
}

func (c GeoradiusUnitM) Count(count int64) GeoradiusCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusCountCount(c)
}

func (c GeoradiusUnitM) Asc() GeoradiusOrderAsc {
	c.command.append("ASC")
	return GeoradiusOrderAsc(c)
}

func (c GeoradiusUnitM) Desc() GeoradiusOrderDesc {
	c.command.append("DESC")
	return GeoradiusOrderDesc(c)
}

func (c GeoradiusUnitM) Store(key string) GeoradiusStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusStore(c)
}

func (c GeoradiusUnitM) Storedist(key string) GeoradiusStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusUnitM) Build() Completed {
	return completed(c)
}

type GeoradiusUnitMi Base

func (c GeoradiusUnitMi) Withcoord() GeoradiusWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusWithcoord(c)
}

func (c GeoradiusUnitMi) Withdist() GeoradiusWithdist {
	c.command.append("WITHDIST")
	return GeoradiusWithdist(c)
}

func (c GeoradiusUnitMi) Withhash() GeoradiusWithhash {
	c.command.append("WITHHASH")
	return GeoradiusWithhash(c)
}

func (c GeoradiusUnitMi) Count(count int64) GeoradiusCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusCountCount(c)
}

func (c GeoradiusUnitMi) Asc() GeoradiusOrderAsc {
	c.command.append("ASC")
	return GeoradiusOrderAsc(c)
}

func (c GeoradiusUnitMi) Desc() GeoradiusOrderDesc {
	c.command.append("DESC")
	return GeoradiusOrderDesc(c)
}

func (c GeoradiusUnitMi) Store(key string) GeoradiusStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusStore(c)
}

func (c GeoradiusUnitMi) Storedist(key string) GeoradiusStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusUnitMi) Build() Completed {
	return completed(c)
}

type GeoradiusWithcoord Base

func (c GeoradiusWithcoord) Withdist() GeoradiusWithdist {
	c.command.append("WITHDIST")
	return GeoradiusWithdist(c)
}

func (c GeoradiusWithcoord) Withhash() GeoradiusWithhash {
	c.command.append("WITHHASH")
	return GeoradiusWithhash(c)
}

func (c GeoradiusWithcoord) Count(count int64) GeoradiusCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusCountCount(c)
}

func (c GeoradiusWithcoord) Asc() GeoradiusOrderAsc {
	c.command.append("ASC")
	return GeoradiusOrderAsc(c)
}

func (c GeoradiusWithcoord) Desc() GeoradiusOrderDesc {
	c.command.append("DESC")
	return GeoradiusOrderDesc(c)
}

func (c GeoradiusWithcoord) Store(key string) GeoradiusStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusStore(c)
}

func (c GeoradiusWithcoord) Storedist(key string) GeoradiusStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusWithcoord) Build() Completed {
	return completed(c)
}

type GeoradiusWithdist Base

func (c GeoradiusWithdist) Withhash() GeoradiusWithhash {
	c.command.append("WITHHASH")
	return GeoradiusWithhash(c)
}

func (c GeoradiusWithdist) Count(count int64) GeoradiusCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusCountCount(c)
}

func (c GeoradiusWithdist) Asc() GeoradiusOrderAsc {
	c.command.append("ASC")
	return GeoradiusOrderAsc(c)
}

func (c GeoradiusWithdist) Desc() GeoradiusOrderDesc {
	c.command.append("DESC")
	return GeoradiusOrderDesc(c)
}

func (c GeoradiusWithdist) Store(key string) GeoradiusStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusStore(c)
}

func (c GeoradiusWithdist) Storedist(key string) GeoradiusStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusWithdist) Build() Completed {
	return completed(c)
}

type GeoradiusWithhash Base

func (c GeoradiusWithhash) Count(count int64) GeoradiusCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusCountCount(c)
}

func (c GeoradiusWithhash) Asc() GeoradiusOrderAsc {
	c.command.append("ASC")
	return GeoradiusOrderAsc(c)
}

func (c GeoradiusWithhash) Desc() GeoradiusOrderDesc {
	c.command.append("DESC")
	return GeoradiusOrderDesc(c)
}

func (c GeoradiusWithhash) Store(key string) GeoradiusStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusStore(c)
}

func (c GeoradiusWithhash) Storedist(key string) GeoradiusStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusWithhash) Build() Completed {
	return completed(c)
}

// Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member.
//
// Time complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
type Georadiusbymember Base

// Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member
//
// Command: GEORADIUSBYMEMBER.
//
// Time complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
func (b Builder) Georadiusbymember() Georadiusbymember {
	c := Georadiusbymember{command: emptyCommand(), cslot: b.slot}
	c.command.append("GEORADIUSBYMEMBER")
	return c
}

func (c Georadiusbymember) Key(key string) GeoradiusbymemberKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return GeoradiusbymemberKey(c)
}

type GeoradiusbymemberCountAny Base

func (c GeoradiusbymemberCountAny) Asc() GeoradiusbymemberOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberOrderAsc(c)
}

func (c GeoradiusbymemberCountAny) Desc() GeoradiusbymemberOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberOrderDesc(c)
}

func (c GeoradiusbymemberCountAny) Store(key string) GeoradiusbymemberStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusbymemberStore(c)
}

func (c GeoradiusbymemberCountAny) Storedist(key string) GeoradiusbymemberStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusbymemberStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberCountAny) Build() Completed {
	return completed(c)
}

type GeoradiusbymemberCountCount Base

func (c GeoradiusbymemberCountCount) Any() GeoradiusbymemberCountAny {
	c.command.append("ANY")
	return GeoradiusbymemberCountAny(c)
}

func (c GeoradiusbymemberCountCount) Asc() GeoradiusbymemberOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberOrderAsc(c)
}

func (c GeoradiusbymemberCountCount) Desc() GeoradiusbymemberOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberOrderDesc(c)
}

func (c GeoradiusbymemberCountCount) Store(key string) GeoradiusbymemberStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusbymemberStore(c)
}

func (c GeoradiusbymemberCountCount) Storedist(key string) GeoradiusbymemberStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusbymemberStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberCountCount) Build() Completed {
	return completed(c)
}

type GeoradiusbymemberKey Base

func (c GeoradiusbymemberKey) Member(member string) GeoradiusbymemberMember {
	c.command.append(member)
	return GeoradiusbymemberMember(c)
}

type GeoradiusbymemberMember Base

func (c GeoradiusbymemberMember) Radius(radius float64) GeoradiusbymemberRadius {
	c.command.append(strconv.FormatFloat(radius, 'f', -1, 64))
	return GeoradiusbymemberRadius(c)
}

type GeoradiusbymemberOrderAsc Base

func (c GeoradiusbymemberOrderAsc) Store(key string) GeoradiusbymemberStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusbymemberStore(c)
}

func (c GeoradiusbymemberOrderAsc) Storedist(key string) GeoradiusbymemberStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusbymemberStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberOrderAsc) Build() Completed {
	return completed(c)
}

type GeoradiusbymemberOrderDesc Base

func (c GeoradiusbymemberOrderDesc) Store(key string) GeoradiusbymemberStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusbymemberStore(c)
}

func (c GeoradiusbymemberOrderDesc) Storedist(key string) GeoradiusbymemberStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusbymemberStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberOrderDesc) Build() Completed {
	return completed(c)
}

type GeoradiusbymemberRadius Base

func (c GeoradiusbymemberRadius) M() GeoradiusbymemberUnitM {
	c.command.append("m")
	return GeoradiusbymemberUnitM(c)
}

func (c GeoradiusbymemberRadius) Km() GeoradiusbymemberUnitKm {
	c.command.append("km")
	return GeoradiusbymemberUnitKm(c)
}

func (c GeoradiusbymemberRadius) Ft() GeoradiusbymemberUnitFt {
	c.command.append("ft")
	return GeoradiusbymemberUnitFt(c)
}

func (c GeoradiusbymemberRadius) Mi() GeoradiusbymemberUnitMi {
	c.command.append("mi")
	return GeoradiusbymemberUnitMi(c)
}

type GeoradiusbymemberRo Base

// Command: GEORADIUSBYMEMBER_RO.
func (b Builder) GeoradiusbymemberRo() GeoradiusbymemberRo {
	c := GeoradiusbymemberRo{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("GEORADIUSBYMEMBER_RO")
	return c
}

func (c GeoradiusbymemberRo) Key(key string) GeoradiusbymemberRoKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return GeoradiusbymemberRoKey(c)
}

type GeoradiusbymemberRoCountAny Base

func (c GeoradiusbymemberRoCountAny) Asc() GeoradiusbymemberRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberRoOrderAsc(c)
}

func (c GeoradiusbymemberRoCountAny) Desc() GeoradiusbymemberRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberRoCountAny) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusbymemberRoCountAny) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusbymemberRoCountCount Base

func (c GeoradiusbymemberRoCountCount) Any() GeoradiusbymemberRoCountAny {
	c.command.append("ANY")
	return GeoradiusbymemberRoCountAny(c)
}

func (c GeoradiusbymemberRoCountCount) Asc() GeoradiusbymemberRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberRoOrderAsc(c)
}

func (c GeoradiusbymemberRoCountCount) Desc() GeoradiusbymemberRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberRoCountCount) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusbymemberRoCountCount) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusbymemberRoKey Base

func (c GeoradiusbymemberRoKey) Member(member string) GeoradiusbymemberRoMember {
	c.command.append(member)
	return GeoradiusbymemberRoMember(c)
}

type GeoradiusbymemberRoMember Base

func (c GeoradiusbymemberRoMember) Radius(radius float64) GeoradiusbymemberRoRadius {
	c.command.append(strconv.FormatFloat(radius, 'f', -1, 64))
	return GeoradiusbymemberRoRadius(c)
}

type GeoradiusbymemberRoOrderAsc Base

// Return Completed Redis command.
func (c GeoradiusbymemberRoOrderAsc) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusbymemberRoOrderAsc) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusbymemberRoOrderDesc Base

// Return Completed Redis command.
func (c GeoradiusbymemberRoOrderDesc) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusbymemberRoOrderDesc) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusbymemberRoRadius Base

func (c GeoradiusbymemberRoRadius) M() GeoradiusbymemberRoUnitM {
	c.command.append("m")
	return GeoradiusbymemberRoUnitM(c)
}

func (c GeoradiusbymemberRoRadius) Km() GeoradiusbymemberRoUnitKm {
	c.command.append("km")
	return GeoradiusbymemberRoUnitKm(c)
}

func (c GeoradiusbymemberRoRadius) Ft() GeoradiusbymemberRoUnitFt {
	c.command.append("ft")
	return GeoradiusbymemberRoUnitFt(c)
}

func (c GeoradiusbymemberRoRadius) Mi() GeoradiusbymemberRoUnitMi {
	c.command.append("mi")
	return GeoradiusbymemberRoUnitMi(c)
}

type GeoradiusbymemberRoUnitFt Base

func (c GeoradiusbymemberRoUnitFt) Withcoord() GeoradiusbymemberRoWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusbymemberRoWithcoord(c)
}

func (c GeoradiusbymemberRoUnitFt) Withdist() GeoradiusbymemberRoWithdist {
	c.command.append("WITHDIST")
	return GeoradiusbymemberRoWithdist(c)
}

func (c GeoradiusbymemberRoUnitFt) Withhash() GeoradiusbymemberRoWithhash {
	c.command.append("WITHHASH")
	return GeoradiusbymemberRoWithhash(c)
}

func (c GeoradiusbymemberRoUnitFt) Count(count int64) GeoradiusbymemberRoCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusbymemberRoCountCount(c)
}

func (c GeoradiusbymemberRoUnitFt) Asc() GeoradiusbymemberRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberRoOrderAsc(c)
}

func (c GeoradiusbymemberRoUnitFt) Desc() GeoradiusbymemberRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberRoUnitFt) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusbymemberRoUnitFt) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusbymemberRoUnitKm Base

func (c GeoradiusbymemberRoUnitKm) Withcoord() GeoradiusbymemberRoWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusbymemberRoWithcoord(c)
}

func (c GeoradiusbymemberRoUnitKm) Withdist() GeoradiusbymemberRoWithdist {
	c.command.append("WITHDIST")
	return GeoradiusbymemberRoWithdist(c)
}

func (c GeoradiusbymemberRoUnitKm) Withhash() GeoradiusbymemberRoWithhash {
	c.command.append("WITHHASH")
	return GeoradiusbymemberRoWithhash(c)
}

func (c GeoradiusbymemberRoUnitKm) Count(count int64) GeoradiusbymemberRoCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusbymemberRoCountCount(c)
}

func (c GeoradiusbymemberRoUnitKm) Asc() GeoradiusbymemberRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberRoOrderAsc(c)
}

func (c GeoradiusbymemberRoUnitKm) Desc() GeoradiusbymemberRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberRoUnitKm) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusbymemberRoUnitKm) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusbymemberRoUnitM Base

func (c GeoradiusbymemberRoUnitM) Withcoord() GeoradiusbymemberRoWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusbymemberRoWithcoord(c)
}

func (c GeoradiusbymemberRoUnitM) Withdist() GeoradiusbymemberRoWithdist {
	c.command.append("WITHDIST")
	return GeoradiusbymemberRoWithdist(c)
}

func (c GeoradiusbymemberRoUnitM) Withhash() GeoradiusbymemberRoWithhash {
	c.command.append("WITHHASH")
	return GeoradiusbymemberRoWithhash(c)
}

func (c GeoradiusbymemberRoUnitM) Count(count int64) GeoradiusbymemberRoCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusbymemberRoCountCount(c)
}

func (c GeoradiusbymemberRoUnitM) Asc() GeoradiusbymemberRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberRoOrderAsc(c)
}

func (c GeoradiusbymemberRoUnitM) Desc() GeoradiusbymemberRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberRoUnitM) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusbymemberRoUnitM) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusbymemberRoUnitMi Base

func (c GeoradiusbymemberRoUnitMi) Withcoord() GeoradiusbymemberRoWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusbymemberRoWithcoord(c)
}

func (c GeoradiusbymemberRoUnitMi) Withdist() GeoradiusbymemberRoWithdist {
	c.command.append("WITHDIST")
	return GeoradiusbymemberRoWithdist(c)
}

func (c GeoradiusbymemberRoUnitMi) Withhash() GeoradiusbymemberRoWithhash {
	c.command.append("WITHHASH")
	return GeoradiusbymemberRoWithhash(c)
}

func (c GeoradiusbymemberRoUnitMi) Count(count int64) GeoradiusbymemberRoCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusbymemberRoCountCount(c)
}

func (c GeoradiusbymemberRoUnitMi) Asc() GeoradiusbymemberRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberRoOrderAsc(c)
}

func (c GeoradiusbymemberRoUnitMi) Desc() GeoradiusbymemberRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberRoUnitMi) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusbymemberRoUnitMi) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusbymemberRoWithcoord Base

func (c GeoradiusbymemberRoWithcoord) Withdist() GeoradiusbymemberRoWithdist {
	c.command.append("WITHDIST")
	return GeoradiusbymemberRoWithdist(c)
}

func (c GeoradiusbymemberRoWithcoord) Withhash() GeoradiusbymemberRoWithhash {
	c.command.append("WITHHASH")
	return GeoradiusbymemberRoWithhash(c)
}

func (c GeoradiusbymemberRoWithcoord) Count(count int64) GeoradiusbymemberRoCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusbymemberRoCountCount(c)
}

func (c GeoradiusbymemberRoWithcoord) Asc() GeoradiusbymemberRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberRoOrderAsc(c)
}

func (c GeoradiusbymemberRoWithcoord) Desc() GeoradiusbymemberRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberRoWithcoord) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusbymemberRoWithcoord) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusbymemberRoWithdist Base

func (c GeoradiusbymemberRoWithdist) Withhash() GeoradiusbymemberRoWithhash {
	c.command.append("WITHHASH")
	return GeoradiusbymemberRoWithhash(c)
}

func (c GeoradiusbymemberRoWithdist) Count(count int64) GeoradiusbymemberRoCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusbymemberRoCountCount(c)
}

func (c GeoradiusbymemberRoWithdist) Asc() GeoradiusbymemberRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberRoOrderAsc(c)
}

func (c GeoradiusbymemberRoWithdist) Desc() GeoradiusbymemberRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberRoWithdist) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusbymemberRoWithdist) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusbymemberRoWithhash Base

func (c GeoradiusbymemberRoWithhash) Count(count int64) GeoradiusbymemberRoCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusbymemberRoCountCount(c)
}

func (c GeoradiusbymemberRoWithhash) Asc() GeoradiusbymemberRoOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberRoOrderAsc(c)
}

func (c GeoradiusbymemberRoWithhash) Desc() GeoradiusbymemberRoOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberRoOrderDesc(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberRoWithhash) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeoradiusbymemberRoWithhash) Cache() Cacheable {
	return cacheable(c)
}

type GeoradiusbymemberStore Base

func (c GeoradiusbymemberStore) Storedist(key string) GeoradiusbymemberStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusbymemberStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberStore) Build() Completed {
	return completed(c)
}

type GeoradiusbymemberStoredist Base

// Return Completed Redis command.
func (c GeoradiusbymemberStoredist) Build() Completed {
	return completed(c)
}

type GeoradiusbymemberUnitFt Base

func (c GeoradiusbymemberUnitFt) Withcoord() GeoradiusbymemberWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusbymemberWithcoord(c)
}

func (c GeoradiusbymemberUnitFt) Withdist() GeoradiusbymemberWithdist {
	c.command.append("WITHDIST")
	return GeoradiusbymemberWithdist(c)
}

func (c GeoradiusbymemberUnitFt) Withhash() GeoradiusbymemberWithhash {
	c.command.append("WITHHASH")
	return GeoradiusbymemberWithhash(c)
}

func (c GeoradiusbymemberUnitFt) Count(count int64) GeoradiusbymemberCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusbymemberCountCount(c)
}

func (c GeoradiusbymemberUnitFt) Asc() GeoradiusbymemberOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberOrderAsc(c)
}

func (c GeoradiusbymemberUnitFt) Desc() GeoradiusbymemberOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberOrderDesc(c)
}

func (c GeoradiusbymemberUnitFt) Store(key string) GeoradiusbymemberStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusbymemberStore(c)
}

func (c GeoradiusbymemberUnitFt) Storedist(key string) GeoradiusbymemberStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusbymemberStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberUnitFt) Build() Completed {
	return completed(c)
}

type GeoradiusbymemberUnitKm Base

func (c GeoradiusbymemberUnitKm) Withcoord() GeoradiusbymemberWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusbymemberWithcoord(c)
}

func (c GeoradiusbymemberUnitKm) Withdist() GeoradiusbymemberWithdist {
	c.command.append("WITHDIST")
	return GeoradiusbymemberWithdist(c)
}

func (c GeoradiusbymemberUnitKm) Withhash() GeoradiusbymemberWithhash {
	c.command.append("WITHHASH")
	return GeoradiusbymemberWithhash(c)
}

func (c GeoradiusbymemberUnitKm) Count(count int64) GeoradiusbymemberCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusbymemberCountCount(c)
}

func (c GeoradiusbymemberUnitKm) Asc() GeoradiusbymemberOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberOrderAsc(c)
}

func (c GeoradiusbymemberUnitKm) Desc() GeoradiusbymemberOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberOrderDesc(c)
}

func (c GeoradiusbymemberUnitKm) Store(key string) GeoradiusbymemberStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusbymemberStore(c)
}

func (c GeoradiusbymemberUnitKm) Storedist(key string) GeoradiusbymemberStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusbymemberStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberUnitKm) Build() Completed {
	return completed(c)
}

type GeoradiusbymemberUnitM Base

func (c GeoradiusbymemberUnitM) Withcoord() GeoradiusbymemberWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusbymemberWithcoord(c)
}

func (c GeoradiusbymemberUnitM) Withdist() GeoradiusbymemberWithdist {
	c.command.append("WITHDIST")
	return GeoradiusbymemberWithdist(c)
}

func (c GeoradiusbymemberUnitM) Withhash() GeoradiusbymemberWithhash {
	c.command.append("WITHHASH")
	return GeoradiusbymemberWithhash(c)
}

func (c GeoradiusbymemberUnitM) Count(count int64) GeoradiusbymemberCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusbymemberCountCount(c)
}

func (c GeoradiusbymemberUnitM) Asc() GeoradiusbymemberOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberOrderAsc(c)
}

func (c GeoradiusbymemberUnitM) Desc() GeoradiusbymemberOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberOrderDesc(c)
}

func (c GeoradiusbymemberUnitM) Store(key string) GeoradiusbymemberStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusbymemberStore(c)
}

func (c GeoradiusbymemberUnitM) Storedist(key string) GeoradiusbymemberStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusbymemberStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberUnitM) Build() Completed {
	return completed(c)
}

type GeoradiusbymemberUnitMi Base

func (c GeoradiusbymemberUnitMi) Withcoord() GeoradiusbymemberWithcoord {
	c.command.append("WITHCOORD")
	return GeoradiusbymemberWithcoord(c)
}

func (c GeoradiusbymemberUnitMi) Withdist() GeoradiusbymemberWithdist {
	c.command.append("WITHDIST")
	return GeoradiusbymemberWithdist(c)
}

func (c GeoradiusbymemberUnitMi) Withhash() GeoradiusbymemberWithhash {
	c.command.append("WITHHASH")
	return GeoradiusbymemberWithhash(c)
}

func (c GeoradiusbymemberUnitMi) Count(count int64) GeoradiusbymemberCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusbymemberCountCount(c)
}

func (c GeoradiusbymemberUnitMi) Asc() GeoradiusbymemberOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberOrderAsc(c)
}

func (c GeoradiusbymemberUnitMi) Desc() GeoradiusbymemberOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberOrderDesc(c)
}

func (c GeoradiusbymemberUnitMi) Store(key string) GeoradiusbymemberStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusbymemberStore(c)
}

func (c GeoradiusbymemberUnitMi) Storedist(key string) GeoradiusbymemberStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusbymemberStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberUnitMi) Build() Completed {
	return completed(c)
}

type GeoradiusbymemberWithcoord Base

func (c GeoradiusbymemberWithcoord) Withdist() GeoradiusbymemberWithdist {
	c.command.append("WITHDIST")
	return GeoradiusbymemberWithdist(c)
}

func (c GeoradiusbymemberWithcoord) Withhash() GeoradiusbymemberWithhash {
	c.command.append("WITHHASH")
	return GeoradiusbymemberWithhash(c)
}

func (c GeoradiusbymemberWithcoord) Count(count int64) GeoradiusbymemberCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusbymemberCountCount(c)
}

func (c GeoradiusbymemberWithcoord) Asc() GeoradiusbymemberOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberOrderAsc(c)
}

func (c GeoradiusbymemberWithcoord) Desc() GeoradiusbymemberOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberOrderDesc(c)
}

func (c GeoradiusbymemberWithcoord) Store(key string) GeoradiusbymemberStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusbymemberStore(c)
}

func (c GeoradiusbymemberWithcoord) Storedist(key string) GeoradiusbymemberStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusbymemberStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberWithcoord) Build() Completed {
	return completed(c)
}

type GeoradiusbymemberWithdist Base

func (c GeoradiusbymemberWithdist) Withhash() GeoradiusbymemberWithhash {
	c.command.append("WITHHASH")
	return GeoradiusbymemberWithhash(c)
}

func (c GeoradiusbymemberWithdist) Count(count int64) GeoradiusbymemberCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusbymemberCountCount(c)
}

func (c GeoradiusbymemberWithdist) Asc() GeoradiusbymemberOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberOrderAsc(c)
}

func (c GeoradiusbymemberWithdist) Desc() GeoradiusbymemberOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberOrderDesc(c)
}

func (c GeoradiusbymemberWithdist) Store(key string) GeoradiusbymemberStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusbymemberStore(c)
}

func (c GeoradiusbymemberWithdist) Storedist(key string) GeoradiusbymemberStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusbymemberStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberWithdist) Build() Completed {
	return completed(c)
}

type GeoradiusbymemberWithhash Base

func (c GeoradiusbymemberWithhash) Count(count int64) GeoradiusbymemberCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeoradiusbymemberCountCount(c)
}

func (c GeoradiusbymemberWithhash) Asc() GeoradiusbymemberOrderAsc {
	c.command.append("ASC")
	return GeoradiusbymemberOrderAsc(c)
}

func (c GeoradiusbymemberWithhash) Desc() GeoradiusbymemberOrderDesc {
	c.command.append("DESC")
	return GeoradiusbymemberOrderDesc(c)
}

func (c GeoradiusbymemberWithhash) Store(key string) GeoradiusbymemberStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STORE", key)
	return GeoradiusbymemberStore(c)
}

func (c GeoradiusbymemberWithhash) Storedist(key string) GeoradiusbymemberStoredist {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append("STOREDIST", key)
	return GeoradiusbymemberStoredist(c)
}

// Return Completed Redis command.
func (c GeoradiusbymemberWithhash) Build() Completed {
	return completed(c)
}

// Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle..
//
// Time complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape
type Geosearch Base

// Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle.
//
// Command: GEOSEARCH.
//
// Time complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape
func (b Builder) Geosearch() Geosearch {
	c := Geosearch{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("GEOSEARCH")
	return c
}

func (c Geosearch) Key(key string) GeosearchKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return GeosearchKey(c)
}

type GeosearchCircleBoxBybox Base

func (c GeosearchCircleBoxBybox) Height(height float64) GeosearchCircleBoxHeight {
	c.command.append(strconv.FormatFloat(height, 'f', -1, 64))
	return GeosearchCircleBoxHeight(c)
}

type GeosearchCircleBoxHeight Base

func (c GeosearchCircleBoxHeight) M() GeosearchCircleBoxUnitM {
	c.command.append("m")
	return GeosearchCircleBoxUnitM(c)
}

func (c GeosearchCircleBoxHeight) Km() GeosearchCircleBoxUnitKm {
	c.command.append("km")
	return GeosearchCircleBoxUnitKm(c)
}

func (c GeosearchCircleBoxHeight) Ft() GeosearchCircleBoxUnitFt {
	c.command.append("ft")
	return GeosearchCircleBoxUnitFt(c)
}

func (c GeosearchCircleBoxHeight) Mi() GeosearchCircleBoxUnitMi {
	c.command.append("mi")
	return GeosearchCircleBoxUnitMi(c)
}

type GeosearchCircleBoxUnitFt Base

func (c GeosearchCircleBoxUnitFt) Asc() GeosearchOrderAsc {
	c.command.append("ASC")
	return GeosearchOrderAsc(c)
}

func (c GeosearchCircleBoxUnitFt) Desc() GeosearchOrderDesc {
	c.command.append("DESC")
	return GeosearchOrderDesc(c)
}

func (c GeosearchCircleBoxUnitFt) Count(count int64) GeosearchCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchCountCount(c)
}

func (c GeosearchCircleBoxUnitFt) Withcoord() GeosearchWithcoord {
	c.command.append("WITHCOORD")
	return GeosearchWithcoord(c)
}

func (c GeosearchCircleBoxUnitFt) Withdist() GeosearchWithdist {
	c.command.append("WITHDIST")
	return GeosearchWithdist(c)
}

func (c GeosearchCircleBoxUnitFt) Withhash() GeosearchWithhash {
	c.command.append("WITHHASH")
	return GeosearchWithhash(c)
}

// Return Completed Redis command.
func (c GeosearchCircleBoxUnitFt) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeosearchCircleBoxUnitFt) Cache() Cacheable {
	return cacheable(c)
}

type GeosearchCircleBoxUnitKm Base

func (c GeosearchCircleBoxUnitKm) Asc() GeosearchOrderAsc {
	c.command.append("ASC")
	return GeosearchOrderAsc(c)
}

func (c GeosearchCircleBoxUnitKm) Desc() GeosearchOrderDesc {
	c.command.append("DESC")
	return GeosearchOrderDesc(c)
}

func (c GeosearchCircleBoxUnitKm) Count(count int64) GeosearchCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchCountCount(c)
}

func (c GeosearchCircleBoxUnitKm) Withcoord() GeosearchWithcoord {
	c.command.append("WITHCOORD")
	return GeosearchWithcoord(c)
}

func (c GeosearchCircleBoxUnitKm) Withdist() GeosearchWithdist {
	c.command.append("WITHDIST")
	return GeosearchWithdist(c)
}

func (c GeosearchCircleBoxUnitKm) Withhash() GeosearchWithhash {
	c.command.append("WITHHASH")
	return GeosearchWithhash(c)
}

// Return Completed Redis command.
func (c GeosearchCircleBoxUnitKm) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeosearchCircleBoxUnitKm) Cache() Cacheable {
	return cacheable(c)
}

type GeosearchCircleBoxUnitM Base

func (c GeosearchCircleBoxUnitM) Asc() GeosearchOrderAsc {
	c.command.append("ASC")
	return GeosearchOrderAsc(c)
}

func (c GeosearchCircleBoxUnitM) Desc() GeosearchOrderDesc {
	c.command.append("DESC")
	return GeosearchOrderDesc(c)
}

func (c GeosearchCircleBoxUnitM) Count(count int64) GeosearchCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchCountCount(c)
}

func (c GeosearchCircleBoxUnitM) Withcoord() GeosearchWithcoord {
	c.command.append("WITHCOORD")
	return GeosearchWithcoord(c)
}

func (c GeosearchCircleBoxUnitM) Withdist() GeosearchWithdist {
	c.command.append("WITHDIST")
	return GeosearchWithdist(c)
}

func (c GeosearchCircleBoxUnitM) Withhash() GeosearchWithhash {
	c.command.append("WITHHASH")
	return GeosearchWithhash(c)
}

// Return Completed Redis command.
func (c GeosearchCircleBoxUnitM) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeosearchCircleBoxUnitM) Cache() Cacheable {
	return cacheable(c)
}

type GeosearchCircleBoxUnitMi Base

func (c GeosearchCircleBoxUnitMi) Asc() GeosearchOrderAsc {
	c.command.append("ASC")
	return GeosearchOrderAsc(c)
}

func (c GeosearchCircleBoxUnitMi) Desc() GeosearchOrderDesc {
	c.command.append("DESC")
	return GeosearchOrderDesc(c)
}

func (c GeosearchCircleBoxUnitMi) Count(count int64) GeosearchCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchCountCount(c)
}

func (c GeosearchCircleBoxUnitMi) Withcoord() GeosearchWithcoord {
	c.command.append("WITHCOORD")
	return GeosearchWithcoord(c)
}

func (c GeosearchCircleBoxUnitMi) Withdist() GeosearchWithdist {
	c.command.append("WITHDIST")
	return GeosearchWithdist(c)
}

func (c GeosearchCircleBoxUnitMi) Withhash() GeosearchWithhash {
	c.command.append("WITHHASH")
	return GeosearchWithhash(c)
}

// Return Completed Redis command.
func (c GeosearchCircleBoxUnitMi) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeosearchCircleBoxUnitMi) Cache() Cacheable {
	return cacheable(c)
}

type GeosearchCircleCircleByradius Base

func (c GeosearchCircleCircleByradius) M() GeosearchCircleCircleUnitM {
	c.command.append("m")
	return GeosearchCircleCircleUnitM(c)
}

func (c GeosearchCircleCircleByradius) Km() GeosearchCircleCircleUnitKm {
	c.command.append("km")
	return GeosearchCircleCircleUnitKm(c)
}

func (c GeosearchCircleCircleByradius) Ft() GeosearchCircleCircleUnitFt {
	c.command.append("ft")
	return GeosearchCircleCircleUnitFt(c)
}

func (c GeosearchCircleCircleByradius) Mi() GeosearchCircleCircleUnitMi {
	c.command.append("mi")
	return GeosearchCircleCircleUnitMi(c)
}

type GeosearchCircleCircleUnitFt Base

func (c GeosearchCircleCircleUnitFt) Bybox(width float64) GeosearchCircleBoxBybox {
	c.command.append("BYBOX", strconv.FormatFloat(width, 'f', -1, 64))
	return GeosearchCircleBoxBybox(c)
}

func (c GeosearchCircleCircleUnitFt) Asc() GeosearchOrderAsc {
	c.command.append("ASC")
	return GeosearchOrderAsc(c)
}

func (c GeosearchCircleCircleUnitFt) Desc() GeosearchOrderDesc {
	c.command.append("DESC")
	return GeosearchOrderDesc(c)
}

func (c GeosearchCircleCircleUnitFt) Count(count int64) GeosearchCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchCountCount(c)
}

func (c GeosearchCircleCircleUnitFt) Withcoord() GeosearchWithcoord {
	c.command.append("WITHCOORD")
	return GeosearchWithcoord(c)
}

func (c GeosearchCircleCircleUnitFt) Withdist() GeosearchWithdist {
	c.command.append("WITHDIST")
	return GeosearchWithdist(c)
}

func (c GeosearchCircleCircleUnitFt) Withhash() GeosearchWithhash {
	c.command.append("WITHHASH")
	return GeosearchWithhash(c)
}

// Return Completed Redis command.
func (c GeosearchCircleCircleUnitFt) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeosearchCircleCircleUnitFt) Cache() Cacheable {
	return cacheable(c)
}

type GeosearchCircleCircleUnitKm Base

func (c GeosearchCircleCircleUnitKm) Bybox(width float64) GeosearchCircleBoxBybox {
	c.command.append("BYBOX", strconv.FormatFloat(width, 'f', -1, 64))
	return GeosearchCircleBoxBybox(c)
}

func (c GeosearchCircleCircleUnitKm) Asc() GeosearchOrderAsc {
	c.command.append("ASC")
	return GeosearchOrderAsc(c)
}

func (c GeosearchCircleCircleUnitKm) Desc() GeosearchOrderDesc {
	c.command.append("DESC")
	return GeosearchOrderDesc(c)
}

func (c GeosearchCircleCircleUnitKm) Count(count int64) GeosearchCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchCountCount(c)
}

func (c GeosearchCircleCircleUnitKm) Withcoord() GeosearchWithcoord {
	c.command.append("WITHCOORD")
	return GeosearchWithcoord(c)
}

func (c GeosearchCircleCircleUnitKm) Withdist() GeosearchWithdist {
	c.command.append("WITHDIST")
	return GeosearchWithdist(c)
}

func (c GeosearchCircleCircleUnitKm) Withhash() GeosearchWithhash {
	c.command.append("WITHHASH")
	return GeosearchWithhash(c)
}

// Return Completed Redis command.
func (c GeosearchCircleCircleUnitKm) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeosearchCircleCircleUnitKm) Cache() Cacheable {
	return cacheable(c)
}

type GeosearchCircleCircleUnitM Base

func (c GeosearchCircleCircleUnitM) Bybox(width float64) GeosearchCircleBoxBybox {
	c.command.append("BYBOX", strconv.FormatFloat(width, 'f', -1, 64))
	return GeosearchCircleBoxBybox(c)
}

func (c GeosearchCircleCircleUnitM) Asc() GeosearchOrderAsc {
	c.command.append("ASC")
	return GeosearchOrderAsc(c)
}

func (c GeosearchCircleCircleUnitM) Desc() GeosearchOrderDesc {
	c.command.append("DESC")
	return GeosearchOrderDesc(c)
}

func (c GeosearchCircleCircleUnitM) Count(count int64) GeosearchCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchCountCount(c)
}

func (c GeosearchCircleCircleUnitM) Withcoord() GeosearchWithcoord {
	c.command.append("WITHCOORD")
	return GeosearchWithcoord(c)
}

func (c GeosearchCircleCircleUnitM) Withdist() GeosearchWithdist {
	c.command.append("WITHDIST")
	return GeosearchWithdist(c)
}

func (c GeosearchCircleCircleUnitM) Withhash() GeosearchWithhash {
	c.command.append("WITHHASH")
	return GeosearchWithhash(c)
}

// Return Completed Redis command.
func (c GeosearchCircleCircleUnitM) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeosearchCircleCircleUnitM) Cache() Cacheable {
	return cacheable(c)
}

type GeosearchCircleCircleUnitMi Base

func (c GeosearchCircleCircleUnitMi) Bybox(width float64) GeosearchCircleBoxBybox {
	c.command.append("BYBOX", strconv.FormatFloat(width, 'f', -1, 64))
	return GeosearchCircleBoxBybox(c)
}

func (c GeosearchCircleCircleUnitMi) Asc() GeosearchOrderAsc {
	c.command.append("ASC")
	return GeosearchOrderAsc(c)
}

func (c GeosearchCircleCircleUnitMi) Desc() GeosearchOrderDesc {
	c.command.append("DESC")
	return GeosearchOrderDesc(c)
}

func (c GeosearchCircleCircleUnitMi) Count(count int64) GeosearchCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchCountCount(c)
}

func (c GeosearchCircleCircleUnitMi) Withcoord() GeosearchWithcoord {
	c.command.append("WITHCOORD")
	return GeosearchWithcoord(c)
}

func (c GeosearchCircleCircleUnitMi) Withdist() GeosearchWithdist {
	c.command.append("WITHDIST")
	return GeosearchWithdist(c)
}

func (c GeosearchCircleCircleUnitMi) Withhash() GeosearchWithhash {
	c.command.append("WITHHASH")
	return GeosearchWithhash(c)
}

// Return Completed Redis command.
func (c GeosearchCircleCircleUnitMi) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeosearchCircleCircleUnitMi) Cache() Cacheable {
	return cacheable(c)
}

type GeosearchCountAny Base

func (c GeosearchCountAny) Withcoord() GeosearchWithcoord {
	c.command.append("WITHCOORD")
	return GeosearchWithcoord(c)
}

func (c GeosearchCountAny) Withdist() GeosearchWithdist {
	c.command.append("WITHDIST")
	return GeosearchWithdist(c)
}

func (c GeosearchCountAny) Withhash() GeosearchWithhash {
	c.command.append("WITHHASH")
	return GeosearchWithhash(c)
}

// Return Completed Redis command.
func (c GeosearchCountAny) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeosearchCountAny) Cache() Cacheable {
	return cacheable(c)
}

type GeosearchCountCount Base

func (c GeosearchCountCount) Any() GeosearchCountAny {
	c.command.append("ANY")
	return GeosearchCountAny(c)
}

func (c GeosearchCountCount) Withcoord() GeosearchWithcoord {
	c.command.append("WITHCOORD")
	return GeosearchWithcoord(c)
}

func (c GeosearchCountCount) Withdist() GeosearchWithdist {
	c.command.append("WITHDIST")
	return GeosearchWithdist(c)
}

func (c GeosearchCountCount) Withhash() GeosearchWithhash {
	c.command.append("WITHHASH")
	return GeosearchWithhash(c)
}

// Return Completed Redis command.
func (c GeosearchCountCount) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeosearchCountCount) Cache() Cacheable {
	return cacheable(c)
}

type GeosearchFrommemberFromlonlat Base

func (c GeosearchFrommemberFromlonlat) Byradius(radius float64) GeosearchCircleCircleByradius {
	c.command.append("BYRADIUS", strconv.FormatFloat(radius, 'f', -1, 64))
	return GeosearchCircleCircleByradius(c)
}

func (c GeosearchFrommemberFromlonlat) Bybox(width float64) GeosearchCircleBoxBybox {
	c.command.append("BYBOX", strconv.FormatFloat(width, 'f', -1, 64))
	return GeosearchCircleBoxBybox(c)
}

type GeosearchFrommemberFrommember Base

func (c GeosearchFrommemberFrommember) Fromlonlat(longitude float64, latitude float64) GeosearchFrommemberFromlonlat {
	c.command.append("FROMLONLAT", strconv.FormatFloat(longitude, 'f', -1, 64), strconv.FormatFloat(latitude, 'f', -1, 64))
	return GeosearchFrommemberFromlonlat(c)
}

func (c GeosearchFrommemberFrommember) Byradius(radius float64) GeosearchCircleCircleByradius {
	c.command.append("BYRADIUS", strconv.FormatFloat(radius, 'f', -1, 64))
	return GeosearchCircleCircleByradius(c)
}

func (c GeosearchFrommemberFrommember) Bybox(width float64) GeosearchCircleBoxBybox {
	c.command.append("BYBOX", strconv.FormatFloat(width, 'f', -1, 64))
	return GeosearchCircleBoxBybox(c)
}

type GeosearchKey Base

func (c GeosearchKey) Frommember(member string) GeosearchFrommemberFrommember {
	c.command.append("FROMMEMBER", member)
	return GeosearchFrommemberFrommember(c)
}

func (c GeosearchKey) Fromlonlat(longitude float64, latitude float64) GeosearchFrommemberFromlonlat {
	c.command.append("FROMLONLAT", strconv.FormatFloat(longitude, 'f', -1, 64), strconv.FormatFloat(latitude, 'f', -1, 64))
	return GeosearchFrommemberFromlonlat(c)
}

type GeosearchOrderAsc Base

func (c GeosearchOrderAsc) Count(count int64) GeosearchCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchCountCount(c)
}

func (c GeosearchOrderAsc) Withcoord() GeosearchWithcoord {
	c.command.append("WITHCOORD")
	return GeosearchWithcoord(c)
}

func (c GeosearchOrderAsc) Withdist() GeosearchWithdist {
	c.command.append("WITHDIST")
	return GeosearchWithdist(c)
}

func (c GeosearchOrderAsc) Withhash() GeosearchWithhash {
	c.command.append("WITHHASH")
	return GeosearchWithhash(c)
}

// Return Completed Redis command.
func (c GeosearchOrderAsc) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeosearchOrderAsc) Cache() Cacheable {
	return cacheable(c)
}

type GeosearchOrderDesc Base

func (c GeosearchOrderDesc) Count(count int64) GeosearchCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchCountCount(c)
}

func (c GeosearchOrderDesc) Withcoord() GeosearchWithcoord {
	c.command.append("WITHCOORD")
	return GeosearchWithcoord(c)
}

func (c GeosearchOrderDesc) Withdist() GeosearchWithdist {
	c.command.append("WITHDIST")
	return GeosearchWithdist(c)
}

func (c GeosearchOrderDesc) Withhash() GeosearchWithhash {
	c.command.append("WITHHASH")
	return GeosearchWithhash(c)
}

// Return Completed Redis command.
func (c GeosearchOrderDesc) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeosearchOrderDesc) Cache() Cacheable {
	return cacheable(c)
}

type GeosearchWithcoord Base

func (c GeosearchWithcoord) Withdist() GeosearchWithdist {
	c.command.append("WITHDIST")
	return GeosearchWithdist(c)
}

func (c GeosearchWithcoord) Withhash() GeosearchWithhash {
	c.command.append("WITHHASH")
	return GeosearchWithhash(c)
}

// Return Completed Redis command.
func (c GeosearchWithcoord) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeosearchWithcoord) Cache() Cacheable {
	return cacheable(c)
}

type GeosearchWithdist Base

func (c GeosearchWithdist) Withhash() GeosearchWithhash {
	c.command.append("WITHHASH")
	return GeosearchWithhash(c)
}

// Return Completed Redis command.
func (c GeosearchWithdist) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeosearchWithdist) Cache() Cacheable {
	return cacheable(c)
}

type GeosearchWithhash Base

// Return Completed Redis command.
func (c GeosearchWithhash) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GeosearchWithhash) Cache() Cacheable {
	return cacheable(c)
}

// Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle, and store the result in another key..
//
// Time complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape
type Geosearchstore Base

// Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle, and store the result in another key.
//
// Command: GEOSEARCHSTORE.
//
// Time complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape
func (b Builder) Geosearchstore() Geosearchstore {
	c := Geosearchstore{command: emptyCommand(), cslot: b.slot}
	c.command.append("GEOSEARCHSTORE")
	return c
}

func (c Geosearchstore) Destination(destination string) GeosearchstoreDestination {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append(destination)
	return GeosearchstoreDestination(c)
}

type GeosearchstoreCircleBoxBybox Base

func (c GeosearchstoreCircleBoxBybox) Height(height float64) GeosearchstoreCircleBoxHeight {
	c.command.append(strconv.FormatFloat(height, 'f', -1, 64))
	return GeosearchstoreCircleBoxHeight(c)
}

type GeosearchstoreCircleBoxHeight Base

func (c GeosearchstoreCircleBoxHeight) M() GeosearchstoreCircleBoxUnitM {
	c.command.append("m")
	return GeosearchstoreCircleBoxUnitM(c)
}

func (c GeosearchstoreCircleBoxHeight) Km() GeosearchstoreCircleBoxUnitKm {
	c.command.append("km")
	return GeosearchstoreCircleBoxUnitKm(c)
}

func (c GeosearchstoreCircleBoxHeight) Ft() GeosearchstoreCircleBoxUnitFt {
	c.command.append("ft")
	return GeosearchstoreCircleBoxUnitFt(c)
}

func (c GeosearchstoreCircleBoxHeight) Mi() GeosearchstoreCircleBoxUnitMi {
	c.command.append("mi")
	return GeosearchstoreCircleBoxUnitMi(c)
}

type GeosearchstoreCircleBoxUnitFt Base

func (c GeosearchstoreCircleBoxUnitFt) Asc() GeosearchstoreOrderAsc {
	c.command.append("ASC")
	return GeosearchstoreOrderAsc(c)
}

func (c GeosearchstoreCircleBoxUnitFt) Desc() GeosearchstoreOrderDesc {
	c.command.append("DESC")
	return GeosearchstoreOrderDesc(c)
}

func (c GeosearchstoreCircleBoxUnitFt) Count(count int64) GeosearchstoreCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchstoreCountCount(c)
}

func (c GeosearchstoreCircleBoxUnitFt) Storedist() GeosearchstoreStoredist {
	c.command.append("STOREDIST")
	return GeosearchstoreStoredist(c)
}

// Return Completed Redis command.
func (c GeosearchstoreCircleBoxUnitFt) Build() Completed {
	return completed(c)
}

type GeosearchstoreCircleBoxUnitKm Base

func (c GeosearchstoreCircleBoxUnitKm) Asc() GeosearchstoreOrderAsc {
	c.command.append("ASC")
	return GeosearchstoreOrderAsc(c)
}

func (c GeosearchstoreCircleBoxUnitKm) Desc() GeosearchstoreOrderDesc {
	c.command.append("DESC")
	return GeosearchstoreOrderDesc(c)
}

func (c GeosearchstoreCircleBoxUnitKm) Count(count int64) GeosearchstoreCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchstoreCountCount(c)
}

func (c GeosearchstoreCircleBoxUnitKm) Storedist() GeosearchstoreStoredist {
	c.command.append("STOREDIST")
	return GeosearchstoreStoredist(c)
}

// Return Completed Redis command.
func (c GeosearchstoreCircleBoxUnitKm) Build() Completed {
	return completed(c)
}

type GeosearchstoreCircleBoxUnitM Base

func (c GeosearchstoreCircleBoxUnitM) Asc() GeosearchstoreOrderAsc {
	c.command.append("ASC")
	return GeosearchstoreOrderAsc(c)
}

func (c GeosearchstoreCircleBoxUnitM) Desc() GeosearchstoreOrderDesc {
	c.command.append("DESC")
	return GeosearchstoreOrderDesc(c)
}

func (c GeosearchstoreCircleBoxUnitM) Count(count int64) GeosearchstoreCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchstoreCountCount(c)
}

func (c GeosearchstoreCircleBoxUnitM) Storedist() GeosearchstoreStoredist {
	c.command.append("STOREDIST")
	return GeosearchstoreStoredist(c)
}

// Return Completed Redis command.
func (c GeosearchstoreCircleBoxUnitM) Build() Completed {
	return completed(c)
}

type GeosearchstoreCircleBoxUnitMi Base

func (c GeosearchstoreCircleBoxUnitMi) Asc() GeosearchstoreOrderAsc {
	c.command.append("ASC")
	return GeosearchstoreOrderAsc(c)
}

func (c GeosearchstoreCircleBoxUnitMi) Desc() GeosearchstoreOrderDesc {
	c.command.append("DESC")
	return GeosearchstoreOrderDesc(c)
}

func (c GeosearchstoreCircleBoxUnitMi) Count(count int64) GeosearchstoreCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchstoreCountCount(c)
}

func (c GeosearchstoreCircleBoxUnitMi) Storedist() GeosearchstoreStoredist {
	c.command.append("STOREDIST")
	return GeosearchstoreStoredist(c)
}

// Return Completed Redis command.
func (c GeosearchstoreCircleBoxUnitMi) Build() Completed {
	return completed(c)
}

type GeosearchstoreCircleCircleByradius Base

func (c GeosearchstoreCircleCircleByradius) M() GeosearchstoreCircleCircleUnitM {
	c.command.append("m")
	return GeosearchstoreCircleCircleUnitM(c)
}

func (c GeosearchstoreCircleCircleByradius) Km() GeosearchstoreCircleCircleUnitKm {
	c.command.append("km")
	return GeosearchstoreCircleCircleUnitKm(c)
}

func (c GeosearchstoreCircleCircleByradius) Ft() GeosearchstoreCircleCircleUnitFt {
	c.command.append("ft")
	return GeosearchstoreCircleCircleUnitFt(c)
}

func (c GeosearchstoreCircleCircleByradius) Mi() GeosearchstoreCircleCircleUnitMi {
	c.command.append("mi")
	return GeosearchstoreCircleCircleUnitMi(c)
}

type GeosearchstoreCircleCircleUnitFt Base

func (c GeosearchstoreCircleCircleUnitFt) Bybox(width float64) GeosearchstoreCircleBoxBybox {
	c.command.append("BYBOX", strconv.FormatFloat(width, 'f', -1, 64))
	return GeosearchstoreCircleBoxBybox(c)
}

func (c GeosearchstoreCircleCircleUnitFt) Asc() GeosearchstoreOrderAsc {
	c.command.append("ASC")
	return GeosearchstoreOrderAsc(c)
}

func (c GeosearchstoreCircleCircleUnitFt) Desc() GeosearchstoreOrderDesc {
	c.command.append("DESC")
	return GeosearchstoreOrderDesc(c)
}

func (c GeosearchstoreCircleCircleUnitFt) Count(count int64) GeosearchstoreCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchstoreCountCount(c)
}

func (c GeosearchstoreCircleCircleUnitFt) Storedist() GeosearchstoreStoredist {
	c.command.append("STOREDIST")
	return GeosearchstoreStoredist(c)
}

// Return Completed Redis command.
func (c GeosearchstoreCircleCircleUnitFt) Build() Completed {
	return completed(c)
}

type GeosearchstoreCircleCircleUnitKm Base

func (c GeosearchstoreCircleCircleUnitKm) Bybox(width float64) GeosearchstoreCircleBoxBybox {
	c.command.append("BYBOX", strconv.FormatFloat(width, 'f', -1, 64))
	return GeosearchstoreCircleBoxBybox(c)
}

func (c GeosearchstoreCircleCircleUnitKm) Asc() GeosearchstoreOrderAsc {
	c.command.append("ASC")
	return GeosearchstoreOrderAsc(c)
}

func (c GeosearchstoreCircleCircleUnitKm) Desc() GeosearchstoreOrderDesc {
	c.command.append("DESC")
	return GeosearchstoreOrderDesc(c)
}

func (c GeosearchstoreCircleCircleUnitKm) Count(count int64) GeosearchstoreCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchstoreCountCount(c)
}

func (c GeosearchstoreCircleCircleUnitKm) Storedist() GeosearchstoreStoredist {
	c.command.append("STOREDIST")
	return GeosearchstoreStoredist(c)
}

// Return Completed Redis command.
func (c GeosearchstoreCircleCircleUnitKm) Build() Completed {
	return completed(c)
}

type GeosearchstoreCircleCircleUnitM Base

func (c GeosearchstoreCircleCircleUnitM) Bybox(width float64) GeosearchstoreCircleBoxBybox {
	c.command.append("BYBOX", strconv.FormatFloat(width, 'f', -1, 64))
	return GeosearchstoreCircleBoxBybox(c)
}

func (c GeosearchstoreCircleCircleUnitM) Asc() GeosearchstoreOrderAsc {
	c.command.append("ASC")
	return GeosearchstoreOrderAsc(c)
}

func (c GeosearchstoreCircleCircleUnitM) Desc() GeosearchstoreOrderDesc {
	c.command.append("DESC")
	return GeosearchstoreOrderDesc(c)
}

func (c GeosearchstoreCircleCircleUnitM) Count(count int64) GeosearchstoreCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchstoreCountCount(c)
}

func (c GeosearchstoreCircleCircleUnitM) Storedist() GeosearchstoreStoredist {
	c.command.append("STOREDIST")
	return GeosearchstoreStoredist(c)
}

// Return Completed Redis command.
func (c GeosearchstoreCircleCircleUnitM) Build() Completed {
	return completed(c)
}

type GeosearchstoreCircleCircleUnitMi Base

func (c GeosearchstoreCircleCircleUnitMi) Bybox(width float64) GeosearchstoreCircleBoxBybox {
	c.command.append("BYBOX", strconv.FormatFloat(width, 'f', -1, 64))
	return GeosearchstoreCircleBoxBybox(c)
}

func (c GeosearchstoreCircleCircleUnitMi) Asc() GeosearchstoreOrderAsc {
	c.command.append("ASC")
	return GeosearchstoreOrderAsc(c)
}

func (c GeosearchstoreCircleCircleUnitMi) Desc() GeosearchstoreOrderDesc {
	c.command.append("DESC")
	return GeosearchstoreOrderDesc(c)
}

func (c GeosearchstoreCircleCircleUnitMi) Count(count int64) GeosearchstoreCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchstoreCountCount(c)
}

func (c GeosearchstoreCircleCircleUnitMi) Storedist() GeosearchstoreStoredist {
	c.command.append("STOREDIST")
	return GeosearchstoreStoredist(c)
}

// Return Completed Redis command.
func (c GeosearchstoreCircleCircleUnitMi) Build() Completed {
	return completed(c)
}

type GeosearchstoreCountAny Base

func (c GeosearchstoreCountAny) Storedist() GeosearchstoreStoredist {
	c.command.append("STOREDIST")
	return GeosearchstoreStoredist(c)
}

// Return Completed Redis command.
func (c GeosearchstoreCountAny) Build() Completed {
	return completed(c)
}

type GeosearchstoreCountCount Base

func (c GeosearchstoreCountCount) Any() GeosearchstoreCountAny {
	c.command.append("ANY")
	return GeosearchstoreCountAny(c)
}

func (c GeosearchstoreCountCount) Storedist() GeosearchstoreStoredist {
	c.command.append("STOREDIST")
	return GeosearchstoreStoredist(c)
}

// Return Completed Redis command.
func (c GeosearchstoreCountCount) Build() Completed {
	return completed(c)
}

type GeosearchstoreDestination Base

func (c GeosearchstoreDestination) Source(source string) GeosearchstoreSource {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(source)
	} else {
		c.cslot.set(getSlot(source))
	}
	c.command.append(source)
	return GeosearchstoreSource(c)
}

type GeosearchstoreFrommemberFromlonlat Base

func (c GeosearchstoreFrommemberFromlonlat) Byradius(radius float64) GeosearchstoreCircleCircleByradius {
	c.command.append("BYRADIUS", strconv.FormatFloat(radius, 'f', -1, 64))
	return GeosearchstoreCircleCircleByradius(c)
}

func (c GeosearchstoreFrommemberFromlonlat) Bybox(width float64) GeosearchstoreCircleBoxBybox {
	c.command.append("BYBOX", strconv.FormatFloat(width, 'f', -1, 64))
	return GeosearchstoreCircleBoxBybox(c)
}

type GeosearchstoreFrommemberFrommember Base

func (c GeosearchstoreFrommemberFrommember) Fromlonlat(longitude float64, latitude float64) GeosearchstoreFrommemberFromlonlat {
	c.command.append("FROMLONLAT", strconv.FormatFloat(longitude, 'f', -1, 64), strconv.FormatFloat(latitude, 'f', -1, 64))
	return GeosearchstoreFrommemberFromlonlat(c)
}

func (c GeosearchstoreFrommemberFrommember) Byradius(radius float64) GeosearchstoreCircleCircleByradius {
	c.command.append("BYRADIUS", strconv.FormatFloat(radius, 'f', -1, 64))
	return GeosearchstoreCircleCircleByradius(c)
}

func (c GeosearchstoreFrommemberFrommember) Bybox(width float64) GeosearchstoreCircleBoxBybox {
	c.command.append("BYBOX", strconv.FormatFloat(width, 'f', -1, 64))
	return GeosearchstoreCircleBoxBybox(c)
}

type GeosearchstoreOrderAsc Base

func (c GeosearchstoreOrderAsc) Count(count int64) GeosearchstoreCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchstoreCountCount(c)
}

func (c GeosearchstoreOrderAsc) Storedist() GeosearchstoreStoredist {
	c.command.append("STOREDIST")
	return GeosearchstoreStoredist(c)
}

// Return Completed Redis command.
func (c GeosearchstoreOrderAsc) Build() Completed {
	return completed(c)
}

type GeosearchstoreOrderDesc Base

func (c GeosearchstoreOrderDesc) Count(count int64) GeosearchstoreCountCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return GeosearchstoreCountCount(c)
}

func (c GeosearchstoreOrderDesc) Storedist() GeosearchstoreStoredist {
	c.command.append("STOREDIST")
	return GeosearchstoreStoredist(c)
}

// Return Completed Redis command.
func (c GeosearchstoreOrderDesc) Build() Completed {
	return completed(c)
}

type GeosearchstoreSource Base

func (c GeosearchstoreSource) Frommember(member string) GeosearchstoreFrommemberFrommember {
	c.command.append("FROMMEMBER", member)
	return GeosearchstoreFrommemberFrommember(c)
}

func (c GeosearchstoreSource) Fromlonlat(longitude float64, latitude float64) GeosearchstoreFrommemberFromlonlat {
	c.command.append("FROMLONLAT", strconv.FormatFloat(longitude, 'f', -1, 64), strconv.FormatFloat(latitude, 'f', -1, 64))
	return GeosearchstoreFrommemberFromlonlat(c)
}

type GeosearchstoreStoredist Base

// Return Completed Redis command.
func (c GeosearchstoreStoredist) Build() Completed {
	return completed(c)
}

// Get the value of a key.
//
// Time complexity: O(1)
type Get Base

// Get the value of a key
//
// Command: GET.
//
// Time complexity: O(1)
func (b Builder) Get() Get {
	c := Get{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("GET")
	return c
}

func (c Get) Key(key string) GetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return GetKey(c)
}

type GetKey Base

// Return Completed Redis command.
func (c GetKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GetKey) Cache() Cacheable {
	return cacheable(c)
}

// Returns the bit value at offset in the string value stored at key.
//
// Time complexity: O(1)
type Getbit Base

// Returns the bit value at offset in the string value stored at key
//
// Command: GETBIT.
//
// Time complexity: O(1)
func (b Builder) Getbit() Getbit {
	c := Getbit{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("GETBIT")
	return c
}

func (c Getbit) Key(key string) GetbitKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return GetbitKey(c)
}

type GetbitKey Base

func (c GetbitKey) Offset(offset int64) GetbitOffset {
	c.command.append(strconv.FormatInt(offset, 10))
	return GetbitOffset(c)
}

type GetbitOffset Base

// Return Completed Redis command.
func (c GetbitOffset) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GetbitOffset) Cache() Cacheable {
	return cacheable(c)
}

// Get the value of a key and delete the key.
//
// Time complexity: O(1)
type Getdel Base

// Get the value of a key and delete the key
//
// Command: GETDEL.
//
// Time complexity: O(1)
func (b Builder) Getdel() Getdel {
	c := Getdel{command: emptyCommand(), cslot: b.slot}
	c.command.append("GETDEL")
	return c
}

func (c Getdel) Key(key string) GetdelKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return GetdelKey(c)
}

type GetdelKey Base

// Return Completed Redis command.
func (c GetdelKey) Build() Completed {
	return completed(c)
}

// Get the value of a key and optionally set its expiration.
//
// Time complexity: O(1)
type Getex Base

// Get the value of a key and optionally set its expiration
//
// Command: GETEX.
//
// Time complexity: O(1)
func (b Builder) Getex() Getex {
	c := Getex{command: emptyCommand(), cslot: b.slot}
	c.command.append("GETEX")
	return c
}

func (c Getex) Key(key string) GetexKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return GetexKey(c)
}

type GetexExpirationExSeconds Base

// Return Completed Redis command.
func (c GetexExpirationExSeconds) Build() Completed {
	return completed(c)
}

type GetexExpirationExatTimestamp Base

// Return Completed Redis command.
func (c GetexExpirationExatTimestamp) Build() Completed {
	return completed(c)
}

type GetexExpirationPersist Base

// Return Completed Redis command.
func (c GetexExpirationPersist) Build() Completed {
	return completed(c)
}

type GetexExpirationPxMilliseconds Base

// Return Completed Redis command.
func (c GetexExpirationPxMilliseconds) Build() Completed {
	return completed(c)
}

type GetexExpirationPxatMillisecondsTimestamp Base

// Return Completed Redis command.
func (c GetexExpirationPxatMillisecondsTimestamp) Build() Completed {
	return completed(c)
}

type GetexKey Base

func (c GetexKey) ExSeconds(seconds int64) GetexExpirationExSeconds {
	c.command.append("EX", strconv.FormatInt(seconds, 10))
	return GetexExpirationExSeconds(c)
}

func (c GetexKey) PxMilliseconds(milliseconds int64) GetexExpirationPxMilliseconds {
	c.command.append("PX", strconv.FormatInt(milliseconds, 10))
	return GetexExpirationPxMilliseconds(c)
}

func (c GetexKey) ExatTimestamp(timestamp int64) GetexExpirationExatTimestamp {
	c.command.append("EXAT", strconv.FormatInt(timestamp, 10))
	return GetexExpirationExatTimestamp(c)
}

func (c GetexKey) PxatMillisecondsTimestamp(millisecondsTimestamp int64) GetexExpirationPxatMillisecondsTimestamp {
	c.command.append("PXAT", strconv.FormatInt(millisecondsTimestamp, 10))
	return GetexExpirationPxatMillisecondsTimestamp(c)
}

func (c GetexKey) Persist() GetexExpirationPersist {
	c.command.append("PERSIST")
	return GetexExpirationPersist(c)
}

// Return Completed Redis command.
func (c GetexKey) Build() Completed {
	return completed(c)
}

// Get a substring of the string stored at a key.
//
// Time complexity: O(N) where N is the length of the returned string. The complexity is ultimately determined by the returned length, but because creating a substring from an existing string is very cheap, it can be considered O(1) for small strings.
type Getrange Base

// Get a substring of the string stored at a key
//
// Command: GETRANGE.
//
// Time complexity: O(N) where N is the length of the returned string. The complexity is ultimately determined by the returned length, but because creating a substring from an existing string is very cheap, it can be considered O(1) for small strings.
func (b Builder) Getrange() Getrange {
	c := Getrange{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("GETRANGE")
	return c
}

func (c Getrange) Key(key string) GetrangeKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return GetrangeKey(c)
}

type GetrangeEnd Base

// Return Completed Redis command.
func (c GetrangeEnd) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GetrangeEnd) Cache() Cacheable {
	return cacheable(c)
}

type GetrangeKey Base

func (c GetrangeKey) Start(start int64) GetrangeStart {
	c.command.append(strconv.FormatInt(start, 10))
	return GetrangeStart(c)
}

type GetrangeStart Base

func (c GetrangeStart) End(end int64) GetrangeEnd {
	c.command.append(strconv.FormatInt(end, 10))
	return GetrangeEnd(c)
}

// Set the string value of a key and return its old value.
//
// Time complexity: O(1)
type Getset Base

// Set the string value of a key and return its old value
//
// Command: GETSET.
//
// Time complexity: O(1)
func (b Builder) Getset() Getset {
	c := Getset{command: emptyCommand(), cslot: b.slot}
	c.command.append("GETSET")
	return c
}

func (c Getset) Key(key string) GetsetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return GetsetKey(c)
}

type GetsetKey Base

func (c GetsetKey) Value(value string) GetsetValue {
	c.command.append(value)
	return GetsetValue(c)
}

type GetsetValue Base

// Return Completed Redis command.
func (c GetsetValue) Build() Completed {
	return completed(c)
}

// Retrieves a RedisGraph configuration.
type GraphConfigGet Base

// Retrieves a RedisGraph configuration
//
// Command: GRAPH.CONFIG GET.
func (b Builder) GraphConfigGet() GraphConfigGet {
	c := GraphConfigGet{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("GRAPH.CONFIG", "GET")
	return c
}

func (c GraphConfigGet) Name(name string) GraphConfigGetName {
	c.command.append(name)
	return GraphConfigGetName(c)
}

type GraphConfigGetName Base

// Return Completed Redis command.
func (c GraphConfigGetName) Build() Completed {
	return completed(c)
}

// Updates a RedisGraph configuration.
type GraphConfigSet Base

// Updates a RedisGraph configuration
//
// Command: GRAPH.CONFIG SET.
func (b Builder) GraphConfigSet() GraphConfigSet {
	c := GraphConfigSet{command: emptyCommand(), cslot: b.slot}
	c.command.append("GRAPH.CONFIG", "SET")
	return c
}

func (c GraphConfigSet) Name(name string) GraphConfigSetName {
	c.command.append(name)
	return GraphConfigSetName(c)
}

type GraphConfigSetName Base

func (c GraphConfigSetName) Value(value string) GraphConfigSetValue {
	c.command.append(value)
	return GraphConfigSetValue(c)
}

type GraphConfigSetValue Base

// Return Completed Redis command.
func (c GraphConfigSetValue) Build() Completed {
	return completed(c)
}

// Completely removes the graph and all of its entities.
type GraphDelete Base

// Completely removes the graph and all of its entities
//
// Command: GRAPH.DELETE.
func (b Builder) GraphDelete() GraphDelete {
	c := GraphDelete{command: emptyCommand(), cslot: b.slot}
	c.command.append("GRAPH.DELETE")
	return c
}

func (c GraphDelete) Graph(graph string) GraphDeleteGraph {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(graph)
	} else {
		c.cslot.set(getSlot(graph))
	}
	c.command.append(graph)
	return GraphDeleteGraph(c)
}

type GraphDeleteGraph Base

// Return Completed Redis command.
func (c GraphDeleteGraph) Build() Completed {
	return completed(c)
}

// Returns a query execution plan without running the query.
type GraphExplain Base

// Returns a query execution plan without running the query
//
// Command: GRAPH.EXPLAIN.
func (b Builder) GraphExplain() GraphExplain {
	c := GraphExplain{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("GRAPH.EXPLAIN")
	return c
}

func (c GraphExplain) Graph(graph string) GraphExplainGraph {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(graph)
	} else {
		c.cslot.set(getSlot(graph))
	}
	c.command.append(graph)
	return GraphExplainGraph(c)
}

type GraphExplainGraph Base

func (c GraphExplainGraph) Query(query string) GraphExplainQuery {
	c.command.append(query)
	return GraphExplainQuery(c)
}

type GraphExplainQuery Base

// Return Completed Redis command.
func (c GraphExplainQuery) Build() Completed {
	return completed(c)
}

// Lists all graph keys in the keyspace.
type GraphList Base

// Lists all graph keys in the keyspace
//
// Command: GRAPH.LIST.
func (b Builder) GraphList() GraphList {
	c := GraphList{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("GRAPH.LIST")
	return c
}

// Return Completed Redis command.
func (c GraphList) Build() Completed {
	return completed(c)
}

// Executes a query and returns an execution plan augmented with metrics for each operation's execution.
type GraphProfile Base

// Executes a query and returns an execution plan augmented with metrics for each operation's execution
//
// Command: GRAPH.PROFILE.
func (b Builder) GraphProfile() GraphProfile {
	c := GraphProfile{command: emptyCommand(), cslot: b.slot}
	c.command.append("GRAPH.PROFILE")
	return c
}

func (c GraphProfile) Graph(graph string) GraphProfileGraph {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(graph)
	} else {
		c.cslot.set(getSlot(graph))
	}
	c.command.append(graph)
	return GraphProfileGraph(c)
}

type GraphProfileGraph Base

func (c GraphProfileGraph) Query(query string) GraphProfileQuery {
	c.command.append(query)
	return GraphProfileQuery(c)
}

type GraphProfileQuery Base

func (c GraphProfileQuery) Timeout(timeout int64) GraphProfileTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return GraphProfileTimeout(c)
}

// Return Completed Redis command.
func (c GraphProfileQuery) Build() Completed {
	return completed(c)
}

type GraphProfileTimeout Base

// Return Completed Redis command.
func (c GraphProfileTimeout) Build() Completed {
	return completed(c)
}

// Executes the given query against a specified graph.
type GraphQuery Base

// Executes the given query against a specified graph
//
// Command: GRAPH.QUERY.
func (b Builder) GraphQuery() GraphQuery {
	c := GraphQuery{command: emptyCommand(), cslot: b.slot}
	c.command.append("GRAPH.QUERY")
	return c
}

func (c GraphQuery) Graph(graph string) GraphQueryGraph {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(graph)
	} else {
		c.cslot.set(getSlot(graph))
	}
	c.command.append(graph)
	return GraphQueryGraph(c)
}

type GraphQueryGraph Base

func (c GraphQueryGraph) Query(query string) GraphQueryQuery {
	c.command.append(query)
	return GraphQueryQuery(c)
}

type GraphQueryQuery Base

func (c GraphQueryQuery) Timeout(timeout int64) GraphQueryTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return GraphQueryTimeout(c)
}

// Return Completed Redis command.
func (c GraphQueryQuery) Build() Completed {
	return completed(c)
}

type GraphQueryTimeout Base

// Return Completed Redis command.
func (c GraphQueryTimeout) Build() Completed {
	return completed(c)
}

// Executes a given read only query against a specified graph.
type GraphRoQuery Base

// Executes a given read only query against a specified graph
//
// Command: GRAPH.RO_QUERY.
func (b Builder) GraphRoQuery() GraphRoQuery {
	c := GraphRoQuery{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("GRAPH.RO_QUERY")
	return c
}

func (c GraphRoQuery) Graph(graph string) GraphRoQueryGraph {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(graph)
	} else {
		c.cslot.set(getSlot(graph))
	}
	c.command.append(graph)
	return GraphRoQueryGraph(c)
}

type GraphRoQueryGraph Base

func (c GraphRoQueryGraph) Query(query string) GraphRoQueryQuery {
	c.command.append(query)
	return GraphRoQueryQuery(c)
}

type GraphRoQueryQuery Base

func (c GraphRoQueryQuery) Timeout(timeout int64) GraphRoQueryTimeout {
	c.command.append("TIMEOUT", strconv.FormatInt(timeout, 10))
	return GraphRoQueryTimeout(c)
}

// Return Completed Redis command.
func (c GraphRoQueryQuery) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GraphRoQueryQuery) Cache() Cacheable {
	return cacheable(c)
}

type GraphRoQueryTimeout Base

// Return Completed Redis command.
func (c GraphRoQueryTimeout) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c GraphRoQueryTimeout) Cache() Cacheable {
	return cacheable(c)
}

// Returns a list containing up to 10 of the slowest queries issued against the given graph.
type GraphSlowlog Base

// Returns a list containing up to 10 of the slowest queries issued against the given graph
//
// Command: GRAPH.SLOWLOG.
func (b Builder) GraphSlowlog() GraphSlowlog {
	c := GraphSlowlog{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("GRAPH.SLOWLOG")
	return c
}

func (c GraphSlowlog) Graph(graph string) GraphSlowlogGraph {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(graph)
	} else {
		c.cslot.set(getSlot(graph))
	}
	c.command.append(graph)
	return GraphSlowlogGraph(c)
}

type GraphSlowlogGraph Base

// Return Completed Redis command.
func (c GraphSlowlogGraph) Build() Completed {
	return completed(c)
}

// Delete one or more hash fields.
//
// Time complexity: O(N) where N is the number of fields to be removed.
type Hdel Base

// Delete one or more hash fields
//
// Command: HDEL.
//
// Time complexity: O(N) where N is the number of fields to be removed.
func (b Builder) Hdel() Hdel {
	c := Hdel{command: emptyCommand(), cslot: b.slot}
	c.command.append("HDEL")
	return c
}

func (c Hdel) Key(key string) HdelKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HdelKey(c)
}

type HdelField Base

func (c HdelField) Field(field ...string) HdelField {
	c.command.append(field...)
	return c
}

// Return Completed Redis command.
func (c HdelField) Build() Completed {
	return completed(c)
}

type HdelKey Base

func (c HdelKey) Field(field ...string) HdelField {
	c.command.append(field...)
	return HdelField(c)
}

// Handshake with Redis.
//
// Time complexity: O(1)
type Hello Base

// Handshake with Redis
//
// Command: HELLO.
//
// Time complexity: O(1)
func (b Builder) Hello() Hello {
	c := Hello{command: emptyCommand(), cslot: b.slot}
	c.command.append("HELLO")
	return c
}

func (c Hello) Protover(protover int64) HelloArgumentsProtover {
	c.command.append(strconv.FormatInt(protover, 10))
	return HelloArgumentsProtover(c)
}

// Return Completed Redis command.
func (c Hello) Build() Completed {
	return completed(c)
}

type HelloArgumentsAuth Base

func (c HelloArgumentsAuth) Setname(clientname string) HelloArgumentsSetname {
	c.command.append("SETNAME", clientname)
	return HelloArgumentsSetname(c)
}

// Return Completed Redis command.
func (c HelloArgumentsAuth) Build() Completed {
	return completed(c)
}

type HelloArgumentsProtover Base

func (c HelloArgumentsProtover) Auth(username string, password string) HelloArgumentsAuth {
	c.command.append("AUTH", username, password)
	return HelloArgumentsAuth(c)
}

func (c HelloArgumentsProtover) Setname(clientname string) HelloArgumentsSetname {
	c.command.append("SETNAME", clientname)
	return HelloArgumentsSetname(c)
}

// Return Completed Redis command.
func (c HelloArgumentsProtover) Build() Completed {
	return completed(c)
}

type HelloArgumentsSetname Base

// Return Completed Redis command.
func (c HelloArgumentsSetname) Build() Completed {
	return completed(c)
}

// Determine if a hash field exists.
//
// Time complexity: O(1)
type Hexists Base

// Determine if a hash field exists
//
// Command: HEXISTS.
//
// Time complexity: O(1)
func (b Builder) Hexists() Hexists {
	c := Hexists{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("HEXISTS")
	return c
}

func (c Hexists) Key(key string) HexistsKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HexistsKey(c)
}

type HexistsField Base

// Return Completed Redis command.
func (c HexistsField) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c HexistsField) Cache() Cacheable {
	return cacheable(c)
}

type HexistsKey Base

func (c HexistsKey) Field(field string) HexistsField {
	c.command.append(field)
	return HexistsField(c)
}

// Get the value of a hash field.
//
// Time complexity: O(1)
type Hget Base

// Get the value of a hash field
//
// Command: HGET.
//
// Time complexity: O(1)
func (b Builder) Hget() Hget {
	c := Hget{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("HGET")
	return c
}

func (c Hget) Key(key string) HgetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HgetKey(c)
}

type HgetField Base

// Return Completed Redis command.
func (c HgetField) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c HgetField) Cache() Cacheable {
	return cacheable(c)
}

type HgetKey Base

func (c HgetKey) Field(field string) HgetField {
	c.command.append(field)
	return HgetField(c)
}

// Get all the fields and values in a hash.
//
// Time complexity: O(N) where N is the size of the hash.
type Hgetall Base

// Get all the fields and values in a hash
//
// Command: HGETALL.
//
// Time complexity: O(N) where N is the size of the hash.
func (b Builder) Hgetall() Hgetall {
	c := Hgetall{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("HGETALL")
	return c
}

func (c Hgetall) Key(key string) HgetallKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HgetallKey(c)
}

type HgetallKey Base

// Return Completed Redis command.
func (c HgetallKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c HgetallKey) Cache() Cacheable {
	return cacheable(c)
}

// Increment the integer value of a hash field by the given number.
//
// Time complexity: O(1)
type Hincrby Base

// Increment the integer value of a hash field by the given number
//
// Command: HINCRBY.
//
// Time complexity: O(1)
func (b Builder) Hincrby() Hincrby {
	c := Hincrby{command: emptyCommand(), cslot: b.slot}
	c.command.append("HINCRBY")
	return c
}

func (c Hincrby) Key(key string) HincrbyKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HincrbyKey(c)
}

type HincrbyField Base

func (c HincrbyField) Increment(increment int64) HincrbyIncrement {
	c.command.append(strconv.FormatInt(increment, 10))
	return HincrbyIncrement(c)
}

type HincrbyIncrement Base

// Return Completed Redis command.
func (c HincrbyIncrement) Build() Completed {
	return completed(c)
}

type HincrbyKey Base

func (c HincrbyKey) Field(field string) HincrbyField {
	c.command.append(field)
	return HincrbyField(c)
}

// Increment the float value of a hash field by the given amount.
//
// Time complexity: O(1)
type Hincrbyfloat Base

// Increment the float value of a hash field by the given amount
//
// Command: HINCRBYFLOAT.
//
// Time complexity: O(1)
func (b Builder) Hincrbyfloat() Hincrbyfloat {
	c := Hincrbyfloat{command: emptyCommand(), cslot: b.slot}
	c.command.append("HINCRBYFLOAT")
	return c
}

func (c Hincrbyfloat) Key(key string) HincrbyfloatKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HincrbyfloatKey(c)
}

type HincrbyfloatField Base

func (c HincrbyfloatField) Increment(increment float64) HincrbyfloatIncrement {
	c.command.append(strconv.FormatFloat(increment, 'f', -1, 64))
	return HincrbyfloatIncrement(c)
}

type HincrbyfloatIncrement Base

// Return Completed Redis command.
func (c HincrbyfloatIncrement) Build() Completed {
	return completed(c)
}

type HincrbyfloatKey Base

func (c HincrbyfloatKey) Field(field string) HincrbyfloatField {
	c.command.append(field)
	return HincrbyfloatField(c)
}

// Get all the fields in a hash.
//
// Time complexity: O(N) where N is the size of the hash.
type Hkeys Base

// Get all the fields in a hash
//
// Command: HKEYS.
//
// Time complexity: O(N) where N is the size of the hash.
func (b Builder) Hkeys() Hkeys {
	c := Hkeys{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("HKEYS")
	return c
}

func (c Hkeys) Key(key string) HkeysKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HkeysKey(c)
}

type HkeysKey Base

// Return Completed Redis command.
func (c HkeysKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c HkeysKey) Cache() Cacheable {
	return cacheable(c)
}

// Get the number of fields in a hash.
//
// Time complexity: O(1)
type Hlen Base

// Get the number of fields in a hash
//
// Command: HLEN.
//
// Time complexity: O(1)
func (b Builder) Hlen() Hlen {
	c := Hlen{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("HLEN")
	return c
}

func (c Hlen) Key(key string) HlenKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HlenKey(c)
}

type HlenKey Base

// Return Completed Redis command.
func (c HlenKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c HlenKey) Cache() Cacheable {
	return cacheable(c)
}

// Get the values of all the given hash fields.
//
// Time complexity: O(N) where N is the number of fields being requested.
type Hmget Base

// Get the values of all the given hash fields
//
// Command: HMGET.
//
// Time complexity: O(N) where N is the number of fields being requested.
func (b Builder) Hmget() Hmget {
	c := Hmget{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("HMGET")
	return c
}

func (c Hmget) Key(key string) HmgetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HmgetKey(c)
}

type HmgetField Base

func (c HmgetField) Field(field ...string) HmgetField {
	c.command.append(field...)
	return c
}

// Return Completed Redis command.
func (c HmgetField) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c HmgetField) Cache() Cacheable {
	return cacheable(c)
}

type HmgetKey Base

func (c HmgetKey) Field(field ...string) HmgetField {
	c.command.append(field...)
	return HmgetField(c)
}

// Set multiple hash fields to multiple values.
//
// Time complexity: O(N) where N is the number of fields being set.
type Hmset Base

// Set multiple hash fields to multiple values
//
// Command: HMSET.
//
// Time complexity: O(N) where N is the number of fields being set.
func (b Builder) Hmset() Hmset {
	c := Hmset{command: emptyCommand(), cslot: b.slot}
	c.command.append("HMSET")
	return c
}

func (c Hmset) Key(key string) HmsetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HmsetKey(c)
}

type HmsetFieldValue Base

func (c HmsetFieldValue) FieldValue(field string, value string) HmsetFieldValue {
	c.command.append(field, value)
	return c
}

// Return Completed Redis command.
func (c HmsetFieldValue) Build() Completed {
	return completed(c)
}

type HmsetKey Base

func (c HmsetKey) FieldValue() HmsetFieldValue {
	return HmsetFieldValue(c)
}

// Get one or multiple random fields from a hash.
//
// Time complexity: O(N) where N is the number of fields returned
type Hrandfield Base

// Get one or multiple random fields from a hash
//
// Command: HRANDFIELD.
//
// Time complexity: O(N) where N is the number of fields returned
func (b Builder) Hrandfield() Hrandfield {
	c := Hrandfield{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("HRANDFIELD")
	return c
}

func (c Hrandfield) Key(key string) HrandfieldKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HrandfieldKey(c)
}

type HrandfieldKey Base

func (c HrandfieldKey) Count(count int64) HrandfieldOptionsCount {
	c.command.append(strconv.FormatInt(count, 10))
	return HrandfieldOptionsCount(c)
}

// Return Completed Redis command.
func (c HrandfieldKey) Build() Completed {
	return completed(c)
}

type HrandfieldOptionsCount Base

func (c HrandfieldOptionsCount) Withvalues() HrandfieldOptionsWithvalues {
	c.command.append("WITHVALUES")
	return HrandfieldOptionsWithvalues(c)
}

// Return Completed Redis command.
func (c HrandfieldOptionsCount) Build() Completed {
	return completed(c)
}

type HrandfieldOptionsWithvalues Base

// Return Completed Redis command.
func (c HrandfieldOptionsWithvalues) Build() Completed {
	return completed(c)
}

// Incrementally iterate hash fields and associated values.
//
// Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..
type Hscan Base

// Incrementally iterate hash fields and associated values
//
// Command: HSCAN.
//
// Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..
func (b Builder) Hscan() Hscan {
	c := Hscan{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("HSCAN")
	return c
}

func (c Hscan) Key(key string) HscanKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HscanKey(c)
}

type HscanCount Base

// Return Completed Redis command.
func (c HscanCount) Build() Completed {
	return completed(c)
}

type HscanCursor Base

func (c HscanCursor) Match(pattern string) HscanMatch {
	c.command.append("MATCH", pattern)
	return HscanMatch(c)
}

func (c HscanCursor) Count(count int64) HscanCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return HscanCount(c)
}

// Return Completed Redis command.
func (c HscanCursor) Build() Completed {
	return completed(c)
}

type HscanKey Base

func (c HscanKey) Cursor(cursor int64) HscanCursor {
	c.command.append(strconv.FormatInt(cursor, 10))
	return HscanCursor(c)
}

type HscanMatch Base

func (c HscanMatch) Count(count int64) HscanCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return HscanCount(c)
}

// Return Completed Redis command.
func (c HscanMatch) Build() Completed {
	return completed(c)
}

// Set the string value of a hash field.
//
// Time complexity: O(1) for each field/value pair added, so O(N) to add N field/value pairs when the command is called with multiple field/value pairs.
type Hset Base

// Set the string value of a hash field
//
// Command: HSET.
//
// Time complexity: O(1) for each field/value pair added, so O(N) to add N field/value pairs when the command is called with multiple field/value pairs.
func (b Builder) Hset() Hset {
	c := Hset{command: emptyCommand(), cslot: b.slot}
	c.command.append("HSET")
	return c
}

func (c Hset) Key(key string) HsetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HsetKey(c)
}

type HsetFieldValue Base

func (c HsetFieldValue) FieldValue(field string, value string) HsetFieldValue {
	c.command.append(field, value)
	return c
}

// Return Completed Redis command.
func (c HsetFieldValue) Build() Completed {
	return completed(c)
}

type HsetKey Base

func (c HsetKey) FieldValue() HsetFieldValue {
	return HsetFieldValue(c)
}

// Set the value of a hash field, only if the field does not exist.
//
// Time complexity: O(1)
type Hsetnx Base

// Set the value of a hash field, only if the field does not exist
//
// Command: HSETNX.
//
// Time complexity: O(1)
func (b Builder) Hsetnx() Hsetnx {
	c := Hsetnx{command: emptyCommand(), cslot: b.slot}
	c.command.append("HSETNX")
	return c
}

func (c Hsetnx) Key(key string) HsetnxKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HsetnxKey(c)
}

type HsetnxField Base

func (c HsetnxField) Value(value string) HsetnxValue {
	c.command.append(value)
	return HsetnxValue(c)
}

type HsetnxKey Base

func (c HsetnxKey) Field(field string) HsetnxField {
	c.command.append(field)
	return HsetnxField(c)
}

type HsetnxValue Base

// Return Completed Redis command.
func (c HsetnxValue) Build() Completed {
	return completed(c)
}

// Get the length of the value of a hash field.
//
// Time complexity: O(1)
type Hstrlen Base

// Get the length of the value of a hash field
//
// Command: HSTRLEN.
//
// Time complexity: O(1)
func (b Builder) Hstrlen() Hstrlen {
	c := Hstrlen{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("HSTRLEN")
	return c
}

func (c Hstrlen) Key(key string) HstrlenKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HstrlenKey(c)
}

type HstrlenField Base

// Return Completed Redis command.
func (c HstrlenField) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c HstrlenField) Cache() Cacheable {
	return cacheable(c)
}

type HstrlenKey Base

func (c HstrlenKey) Field(field string) HstrlenField {
	c.command.append(field)
	return HstrlenField(c)
}

// Get all the values in a hash.
//
// Time complexity: O(N) where N is the size of the hash.
type Hvals Base

// Get all the values in a hash
//
// Command: HVALS.
//
// Time complexity: O(N) where N is the size of the hash.
func (b Builder) Hvals() Hvals {
	c := Hvals{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("HVALS")
	return c
}

func (c Hvals) Key(key string) HvalsKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return HvalsKey(c)
}

type HvalsKey Base

// Return Completed Redis command.
func (c HvalsKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c HvalsKey) Cache() Cacheable {
	return cacheable(c)
}

// Increment the integer value of a key by one.
//
// Time complexity: O(1)
type Incr Base

// Increment the integer value of a key by one
//
// Command: INCR.
//
// Time complexity: O(1)
func (b Builder) Incr() Incr {
	c := Incr{command: emptyCommand(), cslot: b.slot}
	c.command.append("INCR")
	return c
}

func (c Incr) Key(key string) IncrKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return IncrKey(c)
}

type IncrKey Base

// Return Completed Redis command.
func (c IncrKey) Build() Completed {
	return completed(c)
}

// Increment the integer value of a key by the given amount.
//
// Time complexity: O(1)
type Incrby Base

// Increment the integer value of a key by the given amount
//
// Command: INCRBY.
//
// Time complexity: O(1)
func (b Builder) Incrby() Incrby {
	c := Incrby{command: emptyCommand(), cslot: b.slot}
	c.command.append("INCRBY")
	return c
}

func (c Incrby) Key(key string) IncrbyKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return IncrbyKey(c)
}

type IncrbyIncrement Base

// Return Completed Redis command.
func (c IncrbyIncrement) Build() Completed {
	return completed(c)
}

type IncrbyKey Base

func (c IncrbyKey) Increment(increment int64) IncrbyIncrement {
	c.command.append(strconv.FormatInt(increment, 10))
	return IncrbyIncrement(c)
}

// Increment the float value of a key by the given amount.
//
// Time complexity: O(1)
type Incrbyfloat Base

// Increment the float value of a key by the given amount
//
// Command: INCRBYFLOAT.
//
// Time complexity: O(1)
func (b Builder) Incrbyfloat() Incrbyfloat {
	c := Incrbyfloat{command: emptyCommand(), cslot: b.slot}
	c.command.append("INCRBYFLOAT")
	return c
}

func (c Incrbyfloat) Key(key string) IncrbyfloatKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return IncrbyfloatKey(c)
}

type IncrbyfloatIncrement Base

// Return Completed Redis command.
func (c IncrbyfloatIncrement) Build() Completed {
	return completed(c)
}

type IncrbyfloatKey Base

func (c IncrbyfloatKey) Increment(increment float64) IncrbyfloatIncrement {
	c.command.append(strconv.FormatFloat(increment, 'f', -1, 64))
	return IncrbyfloatIncrement(c)
}

// Get information and statistics about the server.
type Info Base

// Get information and statistics about the server
//
// Command: INFO.
func (b Builder) Info() Info {
	c := Info{command: emptyCommand(), cslot: b.slot}
	c.command.append("INFO")
	return c
}

func (c Info) Section(section ...string) InfoSection {
	c.command.append(section...)
	return InfoSection(c)
}

// Return Completed Redis command.
func (c Info) Build() Completed {
	return completed(c)
}

type InfoSection Base

func (c InfoSection) Section(section ...string) InfoSection {
	c.command.append(section...)
	return c
}

// Return Completed Redis command.
func (c InfoSection) Build() Completed {
	return completed(c)
}

// Appends JSON value(s) to the JSON array at path.
//
// Time complexity: O(1) when path is evaluated to a single value, O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonArrappend Base

// Appends JSON value(s) to the JSON array at path
//
// Command: JSON.ARRAPPEND.
//
// Time complexity: O(1) when path is evaluated to a single value, O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonArrappend() JsonArrappend {
	c := JsonArrappend{command: emptyCommand(), cslot: b.slot}
	c.command.append("JSON.ARRAPPEND")
	return c
}

func (c JsonArrappend) Key(key string) JsonArrappendKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonArrappendKey(c)
}

type JsonArrappendKey Base

func (c JsonArrappendKey) Path(path string) JsonArrappendPath {
	c.command.append(path)
	return JsonArrappendPath(c)
}

func (c JsonArrappendKey) Value(value ...string) JsonArrappendValue {
	c.command.append(value...)
	return JsonArrappendValue(c)
}

type JsonArrappendPath Base

func (c JsonArrappendPath) Value(value ...string) JsonArrappendValue {
	c.command.append(value...)
	return JsonArrappendValue(c)
}

type JsonArrappendValue Base

func (c JsonArrappendValue) Value(value ...string) JsonArrappendValue {
	c.command.append(value...)
	return c
}

// Return Completed Redis command.
func (c JsonArrappendValue) Build() Completed {
	return completed(c)
}

// Returns the index of the first occurrence of a JSON scalar value in the array at path.
//
// Time complexity: O(N) when path is evaluated to a single value where N is the size of the array, O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonArrindex Base

// Returns the index of the first occurrence of a JSON scalar value in the array at path
//
// Command: JSON.ARRINDEX.
//
// Time complexity: O(N) when path is evaluated to a single value where N is the size of the array, O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonArrindex() JsonArrindex {
	c := JsonArrindex{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("JSON.ARRINDEX")
	return c
}

func (c JsonArrindex) Key(key string) JsonArrindexKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonArrindexKey(c)
}

type JsonArrindexKey Base

func (c JsonArrindexKey) Path(path string) JsonArrindexPath {
	c.command.append(path)
	return JsonArrindexPath(c)
}

type JsonArrindexPath Base

func (c JsonArrindexPath) Value(value string) JsonArrindexValue {
	c.command.append(value)
	return JsonArrindexValue(c)
}

type JsonArrindexStartStart Base

func (c JsonArrindexStartStart) Stop(stop int64) JsonArrindexStartStop {
	c.command.append(strconv.FormatInt(stop, 10))
	return JsonArrindexStartStop(c)
}

// Return Completed Redis command.
func (c JsonArrindexStartStart) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonArrindexStartStart) Cache() Cacheable {
	return cacheable(c)
}

type JsonArrindexStartStop Base

// Return Completed Redis command.
func (c JsonArrindexStartStop) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonArrindexStartStop) Cache() Cacheable {
	return cacheable(c)
}

type JsonArrindexValue Base

func (c JsonArrindexValue) Start(start int64) JsonArrindexStartStart {
	c.command.append(strconv.FormatInt(start, 10))
	return JsonArrindexStartStart(c)
}

// Return Completed Redis command.
func (c JsonArrindexValue) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonArrindexValue) Cache() Cacheable {
	return cacheable(c)
}

// Inserts the JSON scalar(s) value at the specified index in the array at path.
//
// Time complexity: O(N) when path is evaluated to a single value where N is the size of the array, O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonArrinsert Base

// Inserts the JSON scalar(s) value at the specified index in the array at path
//
// Command: JSON.ARRINSERT.
//
// Time complexity: O(N) when path is evaluated to a single value where N is the size of the array, O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonArrinsert() JsonArrinsert {
	c := JsonArrinsert{command: emptyCommand(), cslot: b.slot}
	c.command.append("JSON.ARRINSERT")
	return c
}

func (c JsonArrinsert) Key(key string) JsonArrinsertKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonArrinsertKey(c)
}

type JsonArrinsertIndex Base

func (c JsonArrinsertIndex) Value(value ...string) JsonArrinsertValue {
	c.command.append(value...)
	return JsonArrinsertValue(c)
}

type JsonArrinsertKey Base

func (c JsonArrinsertKey) Path(path string) JsonArrinsertPath {
	c.command.append(path)
	return JsonArrinsertPath(c)
}

type JsonArrinsertPath Base

func (c JsonArrinsertPath) Index(index int64) JsonArrinsertIndex {
	c.command.append(strconv.FormatInt(index, 10))
	return JsonArrinsertIndex(c)
}

type JsonArrinsertValue Base

func (c JsonArrinsertValue) Value(value ...string) JsonArrinsertValue {
	c.command.append(value...)
	return c
}

// Return Completed Redis command.
func (c JsonArrinsertValue) Build() Completed {
	return completed(c)
}

// Returns the length of the array at path.
//
// Time complexity: O(1) where path is evaluated to a single value, O(N) where path is evaluated to multiple values, where N is the size of the key
type JsonArrlen Base

// Returns the length of the array at path
//
// Command: JSON.ARRLEN.
//
// Time complexity: O(1) where path is evaluated to a single value, O(N) where path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonArrlen() JsonArrlen {
	c := JsonArrlen{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("JSON.ARRLEN")
	return c
}

func (c JsonArrlen) Key(key string) JsonArrlenKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonArrlenKey(c)
}

type JsonArrlenKey Base

func (c JsonArrlenKey) Path(path string) JsonArrlenPath {
	c.command.append(path)
	return JsonArrlenPath(c)
}

// Return Completed Redis command.
func (c JsonArrlenKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonArrlenKey) Cache() Cacheable {
	return cacheable(c)
}

type JsonArrlenPath Base

// Return Completed Redis command.
func (c JsonArrlenPath) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonArrlenPath) Cache() Cacheable {
	return cacheable(c)
}

// Removes and returns the element at the specified index in the array at path.
//
// Time complexity: O(N) when path is evaluated to a single value where N is the size of the array and the specified index is not the last element, O(1) when path is evaluated to a single value and the specified index is the last element, or O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonArrpop Base

// Removes and returns the element at the specified index in the array at path
//
// Command: JSON.ARRPOP.
//
// Time complexity: O(N) when path is evaluated to a single value where N is the size of the array and the specified index is not the last element, O(1) when path is evaluated to a single value and the specified index is the last element, or O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonArrpop() JsonArrpop {
	c := JsonArrpop{command: emptyCommand(), cslot: b.slot}
	c.command.append("JSON.ARRPOP")
	return c
}

func (c JsonArrpop) Key(key string) JsonArrpopKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonArrpopKey(c)
}

type JsonArrpopKey Base

func (c JsonArrpopKey) Path(path string) JsonArrpopPathPath {
	c.command.append(path)
	return JsonArrpopPathPath(c)
}

// Return Completed Redis command.
func (c JsonArrpopKey) Build() Completed {
	return completed(c)
}

type JsonArrpopPathIndex Base

// Return Completed Redis command.
func (c JsonArrpopPathIndex) Build() Completed {
	return completed(c)
}

type JsonArrpopPathPath Base

func (c JsonArrpopPathPath) Index(index int64) JsonArrpopPathIndex {
	c.command.append(strconv.FormatInt(index, 10))
	return JsonArrpopPathIndex(c)
}

// Return Completed Redis command.
func (c JsonArrpopPathPath) Build() Completed {
	return completed(c)
}

// Trims the array at path to contain only the specified inclusive range of indices from start to stop.
//
// Time complexity: O(N) when path is evaluated to a single value where N is the size of the array, O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonArrtrim Base

// Trims the array at path to contain only the specified inclusive range of indices from start to stop
//
// Command: JSON.ARRTRIM.
//
// Time complexity: O(N) when path is evaluated to a single value where N is the size of the array, O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonArrtrim() JsonArrtrim {
	c := JsonArrtrim{command: emptyCommand(), cslot: b.slot}
	c.command.append("JSON.ARRTRIM")
	return c
}

func (c JsonArrtrim) Key(key string) JsonArrtrimKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonArrtrimKey(c)
}

type JsonArrtrimKey Base

func (c JsonArrtrimKey) Path(path string) JsonArrtrimPath {
	c.command.append(path)
	return JsonArrtrimPath(c)
}

type JsonArrtrimPath Base

func (c JsonArrtrimPath) Start(start int64) JsonArrtrimStart {
	c.command.append(strconv.FormatInt(start, 10))
	return JsonArrtrimStart(c)
}

type JsonArrtrimStart Base

func (c JsonArrtrimStart) Stop(stop int64) JsonArrtrimStop {
	c.command.append(strconv.FormatInt(stop, 10))
	return JsonArrtrimStop(c)
}

type JsonArrtrimStop Base

// Return Completed Redis command.
func (c JsonArrtrimStop) Build() Completed {
	return completed(c)
}

// Clears all values from an array or an object, sets numeric values to `0`, sets string values to empty, and sets boolean values to `false`.
//
// Time complexity: O(N) when path is evaluated to a single value where N is the size of the values, O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonClear Base

// Clears all values from an array or an object, sets numeric values to `0`, sets string values to empty, and sets boolean values to `false`
//
// Command: JSON.CLEAR.
//
// Time complexity: O(N) when path is evaluated to a single value where N is the size of the values, O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonClear() JsonClear {
	c := JsonClear{command: emptyCommand(), cslot: b.slot}
	c.command.append("JSON.CLEAR")
	return c
}

func (c JsonClear) Key(key string) JsonClearKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonClearKey(c)
}

type JsonClearKey Base

func (c JsonClearKey) Path(path string) JsonClearPath {
	c.command.append(path)
	return JsonClearPath(c)
}

// Return Completed Redis command.
func (c JsonClearKey) Build() Completed {
	return completed(c)
}

type JsonClearPath Base

// Return Completed Redis command.
func (c JsonClearPath) Build() Completed {
	return completed(c)
}

type JsonDebugHelp Base

// Command: JSON.DEBUG HELP.
func (b Builder) JsonDebugHelp() JsonDebugHelp {
	c := JsonDebugHelp{command: emptyCommand(), cslot: b.slot}
	c.command.append("JSON.DEBUG", "HELP")
	return c
}

// Return Completed Redis command.
func (c JsonDebugHelp) Build() Completed {
	return completed(c)
}

type JsonDebugMemory Base

// Command: JSON.DEBUG MEMORY.
func (b Builder) JsonDebugMemory() JsonDebugMemory {
	c := JsonDebugMemory{command: emptyCommand(), cslot: b.slot}
	c.command.append("JSON.DEBUG", "MEMORY")
	return c
}

func (c JsonDebugMemory) Key(key string) JsonDebugMemoryKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonDebugMemoryKey(c)
}

type JsonDebugMemoryKey Base

func (c JsonDebugMemoryKey) Path(path string) JsonDebugMemoryPath {
	c.command.append(path)
	return JsonDebugMemoryPath(c)
}

// Return Completed Redis command.
func (c JsonDebugMemoryKey) Build() Completed {
	return completed(c)
}

type JsonDebugMemoryPath Base

// Return Completed Redis command.
func (c JsonDebugMemoryPath) Build() Completed {
	return completed(c)
}

// Deletes a value.
//
// Time complexity: O(N) when path is evaluated to a single value where N is the size of the deleted value, O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonDel Base

// Deletes a value
//
// Command: JSON.DEL.
//
// Time complexity: O(N) when path is evaluated to a single value where N is the size of the deleted value, O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonDel() JsonDel {
	c := JsonDel{command: emptyCommand(), cslot: b.slot}
	c.command.append("JSON.DEL")
	return c
}

func (c JsonDel) Key(key string) JsonDelKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonDelKey(c)
}

type JsonDelKey Base

func (c JsonDelKey) Path(path string) JsonDelPath {
	c.command.append(path)
	return JsonDelPath(c)
}

// Return Completed Redis command.
func (c JsonDelKey) Build() Completed {
	return completed(c)
}

type JsonDelPath Base

// Return Completed Redis command.
func (c JsonDelPath) Build() Completed {
	return completed(c)
}

type JsonForget Base

// Command: JSON.FORGET.
func (b Builder) JsonForget() JsonForget {
	c := JsonForget{command: emptyCommand(), cslot: b.slot}
	c.command.append("JSON.FORGET")
	return c
}

func (c JsonForget) Key(key string) JsonForgetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonForgetKey(c)
}

type JsonForgetKey Base

func (c JsonForgetKey) Path(path string) JsonForgetPath {
	c.command.append(path)
	return JsonForgetPath(c)
}

// Return Completed Redis command.
func (c JsonForgetKey) Build() Completed {
	return completed(c)
}

type JsonForgetPath Base

// Return Completed Redis command.
func (c JsonForgetPath) Build() Completed {
	return completed(c)
}

// Gets the value at one or more paths in JSON serialized form.
//
// Time complexity: O(N) when path is evaluated to a single value where N is the size of the value, O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonGet Base

// Gets the value at one or more paths in JSON serialized form
//
// Command: JSON.GET.
//
// Time complexity: O(N) when path is evaluated to a single value where N is the size of the value, O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonGet() JsonGet {
	c := JsonGet{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("JSON.GET")
	return c
}

func (c JsonGet) Key(key string) JsonGetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonGetKey(c)
}

type JsonGetIndent Base

func (c JsonGetIndent) Newline(newline string) JsonGetNewline {
	c.command.append("NEWLINE", newline)
	return JsonGetNewline(c)
}

func (c JsonGetIndent) Space(space string) JsonGetSpace {
	c.command.append("SPACE", space)
	return JsonGetSpace(c)
}

func (c JsonGetIndent) Paths(paths ...string) JsonGetPaths {
	c.command.append(paths...)
	return JsonGetPaths(c)
}

// Return Completed Redis command.
func (c JsonGetIndent) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonGetIndent) Cache() Cacheable {
	return cacheable(c)
}

type JsonGetKey Base

func (c JsonGetKey) Indent(indent string) JsonGetIndent {
	c.command.append("INDENT", indent)
	return JsonGetIndent(c)
}

func (c JsonGetKey) Newline(newline string) JsonGetNewline {
	c.command.append("NEWLINE", newline)
	return JsonGetNewline(c)
}

func (c JsonGetKey) Space(space string) JsonGetSpace {
	c.command.append("SPACE", space)
	return JsonGetSpace(c)
}

func (c JsonGetKey) Paths(paths ...string) JsonGetPaths {
	c.command.append(paths...)
	return JsonGetPaths(c)
}

// Return Completed Redis command.
func (c JsonGetKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonGetKey) Cache() Cacheable {
	return cacheable(c)
}

type JsonGetNewline Base

func (c JsonGetNewline) Space(space string) JsonGetSpace {
	c.command.append("SPACE", space)
	return JsonGetSpace(c)
}

func (c JsonGetNewline) Paths(paths ...string) JsonGetPaths {
	c.command.append(paths...)
	return JsonGetPaths(c)
}

// Return Completed Redis command.
func (c JsonGetNewline) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonGetNewline) Cache() Cacheable {
	return cacheable(c)
}

type JsonGetPaths Base

func (c JsonGetPaths) Paths(paths ...string) JsonGetPaths {
	c.command.append(paths...)
	return c
}

// Return Completed Redis command.
func (c JsonGetPaths) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonGetPaths) Cache() Cacheable {
	return cacheable(c)
}

type JsonGetSpace Base

func (c JsonGetSpace) Paths(paths ...string) JsonGetPaths {
	c.command.append(paths...)
	return JsonGetPaths(c)
}

// Return Completed Redis command.
func (c JsonGetSpace) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonGetSpace) Cache() Cacheable {
	return cacheable(c)
}

// Returns the values at a path from one or more keys.
//
// Time complexity: O(M*N) when path is evaluated to a single value where M is the number of keys and N is the size of the value, O(N1+N2+...+Nm) when path is evaluated to multiple values where m is the number of keys and Ni is the size of the i-th key
type JsonMget Base

// Returns the values at a path from one or more keys
//
// Command: JSON.MGET.
//
// Time complexity: O(M*N) when path is evaluated to a single value where M is the number of keys and N is the size of the value, O(N1+N2+...+Nm) when path is evaluated to multiple values where m is the number of keys and Ni is the size of the i-th key
func (b Builder) JsonMget() JsonMget {
	c := JsonMget{command: emptyCommand(), cslot: b.slot, ctags: ctagMtGet}
	c.command.append("JSON.MGET")
	return c
}

func (c JsonMget) Key(key ...string) JsonMgetKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return JsonMgetKey(c)
}

type JsonMgetKey Base

func (c JsonMgetKey) Key(key ...string) JsonMgetKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c JsonMgetKey) Path(path string) JsonMgetPath {
	c.command.append(path)
	return JsonMgetPath(c)
}

type JsonMgetPath Base

// Return Completed Redis command.
func (c JsonMgetPath) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonMgetPath) Cache() Cacheable {
	return cacheable(c)
}

// Increments the numeric value at path by a value.
//
// Time complexity: O(1) when path is evaluated to a single value, O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonNumincrby Base

// Increments the numeric value at path by a value
//
// Command: JSON.NUMINCRBY.
//
// Time complexity: O(1) when path is evaluated to a single value, O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonNumincrby() JsonNumincrby {
	c := JsonNumincrby{command: emptyCommand(), cslot: b.slot}
	c.command.append("JSON.NUMINCRBY")
	return c
}

func (c JsonNumincrby) Key(key string) JsonNumincrbyKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonNumincrbyKey(c)
}

type JsonNumincrbyKey Base

func (c JsonNumincrbyKey) Path(path string) JsonNumincrbyPath {
	c.command.append(path)
	return JsonNumincrbyPath(c)
}

type JsonNumincrbyPath Base

func (c JsonNumincrbyPath) Value(value float64) JsonNumincrbyValue {
	c.command.append(strconv.FormatFloat(value, 'f', -1, 64))
	return JsonNumincrbyValue(c)
}

type JsonNumincrbyValue Base

// Return Completed Redis command.
func (c JsonNumincrbyValue) Build() Completed {
	return completed(c)
}

type JsonNummultby Base

// Command: JSON.NUMMULTBY.
func (b Builder) JsonNummultby() JsonNummultby {
	c := JsonNummultby{command: emptyCommand(), cslot: b.slot}
	c.command.append("JSON.NUMMULTBY")
	return c
}

func (c JsonNummultby) Key(key string) JsonNummultbyKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonNummultbyKey(c)
}

type JsonNummultbyKey Base

func (c JsonNummultbyKey) Path(path string) JsonNummultbyPath {
	c.command.append(path)
	return JsonNummultbyPath(c)
}

type JsonNummultbyPath Base

func (c JsonNummultbyPath) Value(value float64) JsonNummultbyValue {
	c.command.append(strconv.FormatFloat(value, 'f', -1, 64))
	return JsonNummultbyValue(c)
}

type JsonNummultbyValue Base

// Return Completed Redis command.
func (c JsonNummultbyValue) Build() Completed {
	return completed(c)
}

// Returns the JSON keys of the object at path.
//
// Time complexity: O(N) when path is evaluated to a single value, where N is the number of keys in the object, O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonObjkeys Base

// Returns the JSON keys of the object at path
//
// Command: JSON.OBJKEYS.
//
// Time complexity: O(N) when path is evaluated to a single value, where N is the number of keys in the object, O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonObjkeys() JsonObjkeys {
	c := JsonObjkeys{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("JSON.OBJKEYS")
	return c
}

func (c JsonObjkeys) Key(key string) JsonObjkeysKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonObjkeysKey(c)
}

type JsonObjkeysKey Base

func (c JsonObjkeysKey) Path(path string) JsonObjkeysPath {
	c.command.append(path)
	return JsonObjkeysPath(c)
}

// Return Completed Redis command.
func (c JsonObjkeysKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonObjkeysKey) Cache() Cacheable {
	return cacheable(c)
}

type JsonObjkeysPath Base

// Return Completed Redis command.
func (c JsonObjkeysPath) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonObjkeysPath) Cache() Cacheable {
	return cacheable(c)
}

// Returns the number of keys of the object at path.
//
// Time complexity: O(1) when path is evaluated to a single value, O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonObjlen Base

// Returns the number of keys of the object at path
//
// Command: JSON.OBJLEN.
//
// Time complexity: O(1) when path is evaluated to a single value, O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonObjlen() JsonObjlen {
	c := JsonObjlen{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("JSON.OBJLEN")
	return c
}

func (c JsonObjlen) Key(key string) JsonObjlenKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonObjlenKey(c)
}

type JsonObjlenKey Base

func (c JsonObjlenKey) Path(path string) JsonObjlenPath {
	c.command.append(path)
	return JsonObjlenPath(c)
}

// Return Completed Redis command.
func (c JsonObjlenKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonObjlenKey) Cache() Cacheable {
	return cacheable(c)
}

type JsonObjlenPath Base

// Return Completed Redis command.
func (c JsonObjlenPath) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonObjlenPath) Cache() Cacheable {
	return cacheable(c)
}

// Returns the JSON value at path in Redis Serialization Protocol (RESP).
//
// Time complexity: O(N) when path is evaluated to a single value, where N is the size of the value, O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonResp Base

// Returns the JSON value at path in Redis Serialization Protocol (RESP)
//
// Command: JSON.RESP.
//
// Time complexity: O(N) when path is evaluated to a single value, where N is the size of the value, O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonResp() JsonResp {
	c := JsonResp{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("JSON.RESP")
	return c
}

func (c JsonResp) Key(key string) JsonRespKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonRespKey(c)
}

type JsonRespKey Base

func (c JsonRespKey) Path(path string) JsonRespPath {
	c.command.append(path)
	return JsonRespPath(c)
}

// Return Completed Redis command.
func (c JsonRespKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonRespKey) Cache() Cacheable {
	return cacheable(c)
}

type JsonRespPath Base

// Return Completed Redis command.
func (c JsonRespPath) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonRespPath) Cache() Cacheable {
	return cacheable(c)
}

// Sets or updates the JSON value at a path.
//
// Time complexity: O(M+N) when path is evaluated to a single value where M is the size of the original value (if it exists) and N is the size of the new value, O(M+N) when path is evaluated to multiple values where M is the size of the key and N is the size of the new value
type JsonSet Base

// Sets or updates the JSON value at a path
//
// Command: JSON.SET.
//
// Time complexity: O(M+N) when path is evaluated to a single value where M is the size of the original value (if it exists) and N is the size of the new value, O(M+N) when path is evaluated to multiple values where M is the size of the key and N is the size of the new value
func (b Builder) JsonSet() JsonSet {
	c := JsonSet{command: emptyCommand(), cslot: b.slot}
	c.command.append("JSON.SET")
	return c
}

func (c JsonSet) Key(key string) JsonSetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonSetKey(c)
}

type JsonSetConditionNx Base

// Return Completed Redis command.
func (c JsonSetConditionNx) Build() Completed {
	return completed(c)
}

type JsonSetConditionXx Base

// Return Completed Redis command.
func (c JsonSetConditionXx) Build() Completed {
	return completed(c)
}

type JsonSetKey Base

func (c JsonSetKey) Path(path string) JsonSetPath {
	c.command.append(path)
	return JsonSetPath(c)
}

type JsonSetPath Base

func (c JsonSetPath) Value(value string) JsonSetValue {
	c.command.append(value)
	return JsonSetValue(c)
}

type JsonSetValue Base

func (c JsonSetValue) Nx() JsonSetConditionNx {
	c.command.append("NX")
	return JsonSetConditionNx(c)
}

func (c JsonSetValue) Xx() JsonSetConditionXx {
	c.command.append("XX")
	return JsonSetConditionXx(c)
}

// Return Completed Redis command.
func (c JsonSetValue) Build() Completed {
	return completed(c)
}

// Appends a string to a JSON string value at path.
//
// Time complexity: O(1) when path is evaluated to a single value, O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonStrappend Base

// Appends a string to a JSON string value at path
//
// Command: JSON.STRAPPEND.
//
// Time complexity: O(1) when path is evaluated to a single value, O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonStrappend() JsonStrappend {
	c := JsonStrappend{command: emptyCommand(), cslot: b.slot}
	c.command.append("JSON.STRAPPEND")
	return c
}

func (c JsonStrappend) Key(key string) JsonStrappendKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonStrappendKey(c)
}

type JsonStrappendKey Base

func (c JsonStrappendKey) Path(path string) JsonStrappendPath {
	c.command.append(path)
	return JsonStrappendPath(c)
}

func (c JsonStrappendKey) Value(value string) JsonStrappendValue {
	c.command.append(value)
	return JsonStrappendValue(c)
}

type JsonStrappendPath Base

func (c JsonStrappendPath) Value(value string) JsonStrappendValue {
	c.command.append(value)
	return JsonStrappendValue(c)
}

type JsonStrappendValue Base

// Return Completed Redis command.
func (c JsonStrappendValue) Build() Completed {
	return completed(c)
}

// Returns the length of the JSON String at path in key.
//
// Time complexity: O(1) when path is evaluated to a single value, O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonStrlen Base

// Returns the length of the JSON String at path in key
//
// Command: JSON.STRLEN.
//
// Time complexity: O(1) when path is evaluated to a single value, O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonStrlen() JsonStrlen {
	c := JsonStrlen{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("JSON.STRLEN")
	return c
}

func (c JsonStrlen) Key(key string) JsonStrlenKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonStrlenKey(c)
}

type JsonStrlenKey Base

func (c JsonStrlenKey) Path(path string) JsonStrlenPath {
	c.command.append(path)
	return JsonStrlenPath(c)
}

// Return Completed Redis command.
func (c JsonStrlenKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonStrlenKey) Cache() Cacheable {
	return cacheable(c)
}

type JsonStrlenPath Base

// Return Completed Redis command.
func (c JsonStrlenPath) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonStrlenPath) Cache() Cacheable {
	return cacheable(c)
}

// Toggles a boolean value.
//
// Time complexity: O(1) when path is evaluated to a single value, O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonToggle Base

// Toggles a boolean value
//
// Command: JSON.TOGGLE.
//
// Time complexity: O(1) when path is evaluated to a single value, O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonToggle() JsonToggle {
	c := JsonToggle{command: emptyCommand(), cslot: b.slot}
	c.command.append("JSON.TOGGLE")
	return c
}

func (c JsonToggle) Key(key string) JsonToggleKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonToggleKey(c)
}

type JsonToggleKey Base

func (c JsonToggleKey) Path(path string) JsonTogglePath {
	c.command.append(path)
	return JsonTogglePath(c)
}

type JsonTogglePath Base

// Return Completed Redis command.
func (c JsonTogglePath) Build() Completed {
	return completed(c)
}

// Returns the type of the JSON value at path.
//
// Time complexity: O(1) when path is evaluated to a single value, O(N) when path is evaluated to multiple values, where N is the size of the key
type JsonType Base

// Returns the type of the JSON value at path
//
// Command: JSON.TYPE.
//
// Time complexity: O(1) when path is evaluated to a single value, O(N) when path is evaluated to multiple values, where N is the size of the key
func (b Builder) JsonType() JsonType {
	c := JsonType{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("JSON.TYPE")
	return c
}

func (c JsonType) Key(key string) JsonTypeKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return JsonTypeKey(c)
}

type JsonTypeKey Base

func (c JsonTypeKey) Path(path string) JsonTypePath {
	c.command.append(path)
	return JsonTypePath(c)
}

// Return Completed Redis command.
func (c JsonTypeKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonTypeKey) Cache() Cacheable {
	return cacheable(c)
}

type JsonTypePath Base

// Return Completed Redis command.
func (c JsonTypePath) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c JsonTypePath) Cache() Cacheable {
	return cacheable(c)
}

// Find all keys matching the given pattern.
//
// Time complexity: O(N) with N being the number of keys in the database, under the assumption that the key names in the database and the given pattern have limited length.
type Keys Base

// Find all keys matching the given pattern
//
// Command: KEYS.
//
// Time complexity: O(N) with N being the number of keys in the database, under the assumption that the key names in the database and the given pattern have limited length.
func (b Builder) Keys() Keys {
	c := Keys{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("KEYS")
	return c
}

func (c Keys) Pattern(pattern string) KeysPattern {
	c.command.append(pattern)
	return KeysPattern(c)
}

type KeysPattern Base

// Return Completed Redis command.
func (c KeysPattern) Build() Completed {
	return completed(c)
}

// Get the UNIX time stamp of the last successful save to disk.
type Lastsave Base

// Get the UNIX time stamp of the last successful save to disk
//
// Command: LASTSAVE.
func (b Builder) Lastsave() Lastsave {
	c := Lastsave{command: emptyCommand(), cslot: b.slot}
	c.command.append("LASTSAVE")
	return c
}

// Return Completed Redis command.
func (c Lastsave) Build() Completed {
	return completed(c)
}

// Return a human readable latency analysis report..
type LatencyDoctor Base

// Return a human readable latency analysis report.
//
// Command: LATENCY DOCTOR.
func (b Builder) LatencyDoctor() LatencyDoctor {
	c := LatencyDoctor{command: emptyCommand(), cslot: b.slot}
	c.command.append("LATENCY", "DOCTOR")
	return c
}

// Return Completed Redis command.
func (c LatencyDoctor) Build() Completed {
	return completed(c)
}

// Return a latency graph for the event..
type LatencyGraph Base

// Return a latency graph for the event.
//
// Command: LATENCY GRAPH.
func (b Builder) LatencyGraph() LatencyGraph {
	c := LatencyGraph{command: emptyCommand(), cslot: b.slot}
	c.command.append("LATENCY", "GRAPH")
	return c
}

func (c LatencyGraph) Event(event string) LatencyGraphEvent {
	c.command.append(event)
	return LatencyGraphEvent(c)
}

type LatencyGraphEvent Base

// Return Completed Redis command.
func (c LatencyGraphEvent) Build() Completed {
	return completed(c)
}

// Show helpful text about the different subcommands..
type LatencyHelp Base

// Show helpful text about the different subcommands.
//
// Command: LATENCY HELP.
func (b Builder) LatencyHelp() LatencyHelp {
	c := LatencyHelp{command: emptyCommand(), cslot: b.slot}
	c.command.append("LATENCY", "HELP")
	return c
}

// Return Completed Redis command.
func (c LatencyHelp) Build() Completed {
	return completed(c)
}

type LatencyHistogram Base

// Command: LATENCY HISTOGRAM.
func (b Builder) LatencyHistogram() LatencyHistogram {
	c := LatencyHistogram{command: emptyCommand(), cslot: b.slot}
	c.command.append("LATENCY", "HISTOGRAM")
	return c
}

func (c LatencyHistogram) Command(command ...string) LatencyHistogramCommand {
	c.command.append(command...)
	return LatencyHistogramCommand(c)
}

// Return Completed Redis command.
func (c LatencyHistogram) Build() Completed {
	return completed(c)
}

type LatencyHistogramCommand Base

func (c LatencyHistogramCommand) Command(command ...string) LatencyHistogramCommand {
	c.command.append(command...)
	return c
}

// Return Completed Redis command.
func (c LatencyHistogramCommand) Build() Completed {
	return completed(c)
}

// Return timestamp-latency samples for the event..
type LatencyHistory Base

// Return timestamp-latency samples for the event.
//
// Command: LATENCY HISTORY.
func (b Builder) LatencyHistory() LatencyHistory {
	c := LatencyHistory{command: emptyCommand(), cslot: b.slot}
	c.command.append("LATENCY", "HISTORY")
	return c
}

func (c LatencyHistory) Event(event string) LatencyHistoryEvent {
	c.command.append(event)
	return LatencyHistoryEvent(c)
}

type LatencyHistoryEvent Base

// Return Completed Redis command.
func (c LatencyHistoryEvent) Build() Completed {
	return completed(c)
}

// Return the latest latency samples for all events..
type LatencyLatest Base

// Return the latest latency samples for all events.
//
// Command: LATENCY LATEST.
func (b Builder) LatencyLatest() LatencyLatest {
	c := LatencyLatest{command: emptyCommand(), cslot: b.slot}
	c.command.append("LATENCY", "LATEST")
	return c
}

// Return Completed Redis command.
func (c LatencyLatest) Build() Completed {
	return completed(c)
}

// Reset latency data for one or more events..
type LatencyReset Base

// Reset latency data for one or more events.
//
// Command: LATENCY RESET.
func (b Builder) LatencyReset() LatencyReset {
	c := LatencyReset{command: emptyCommand(), cslot: b.slot}
	c.command.append("LATENCY", "RESET")
	return c
}

func (c LatencyReset) Event(event ...string) LatencyResetEvent {
	c.command.append(event...)
	return LatencyResetEvent(c)
}

// Return Completed Redis command.
func (c LatencyReset) Build() Completed {
	return completed(c)
}

type LatencyResetEvent Base

func (c LatencyResetEvent) Event(event ...string) LatencyResetEvent {
	c.command.append(event...)
	return c
}

// Return Completed Redis command.
func (c LatencyResetEvent) Build() Completed {
	return completed(c)
}

// Find longest common substring.
//
// Time complexity: O(N*M) where N and M are the lengths of s1 and s2, respectively
type Lcs Base

// Find longest common substring
//
// Command: LCS.
//
// Time complexity: O(N*M) where N and M are the lengths of s1 and s2, respectively
func (b Builder) Lcs() Lcs {
	c := Lcs{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("LCS")
	return c
}

func (c Lcs) Key1(key1 string) LcsKey1 {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key1)
	} else {
		c.cslot.set(getSlot(key1))
	}
	c.command.append(key1)
	return LcsKey1(c)
}

type LcsIdx Base

func (c LcsIdx) Minmatchlen(len int64) LcsMinmatchlen {
	c.command.append("MINMATCHLEN", strconv.FormatInt(len, 10))
	return LcsMinmatchlen(c)
}

func (c LcsIdx) Withmatchlen() LcsWithmatchlen {
	c.command.append("WITHMATCHLEN")
	return LcsWithmatchlen(c)
}

// Return Completed Redis command.
func (c LcsIdx) Build() Completed {
	return completed(c)
}

type LcsKey1 Base

func (c LcsKey1) Key2(key2 string) LcsKey2 {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key2)
	} else {
		c.cslot.set(getSlot(key2))
	}
	c.command.append(key2)
	return LcsKey2(c)
}

type LcsKey2 Base

func (c LcsKey2) Len() LcsLen {
	c.command.append("LEN")
	return LcsLen(c)
}

func (c LcsKey2) Idx() LcsIdx {
	c.command.append("IDX")
	return LcsIdx(c)
}

func (c LcsKey2) Minmatchlen(len int64) LcsMinmatchlen {
	c.command.append("MINMATCHLEN", strconv.FormatInt(len, 10))
	return LcsMinmatchlen(c)
}

func (c LcsKey2) Withmatchlen() LcsWithmatchlen {
	c.command.append("WITHMATCHLEN")
	return LcsWithmatchlen(c)
}

// Return Completed Redis command.
func (c LcsKey2) Build() Completed {
	return completed(c)
}

type LcsLen Base

func (c LcsLen) Idx() LcsIdx {
	c.command.append("IDX")
	return LcsIdx(c)
}

func (c LcsLen) Minmatchlen(len int64) LcsMinmatchlen {
	c.command.append("MINMATCHLEN", strconv.FormatInt(len, 10))
	return LcsMinmatchlen(c)
}

func (c LcsLen) Withmatchlen() LcsWithmatchlen {
	c.command.append("WITHMATCHLEN")
	return LcsWithmatchlen(c)
}

// Return Completed Redis command.
func (c LcsLen) Build() Completed {
	return completed(c)
}

type LcsMinmatchlen Base

func (c LcsMinmatchlen) Withmatchlen() LcsWithmatchlen {
	c.command.append("WITHMATCHLEN")
	return LcsWithmatchlen(c)
}

// Return Completed Redis command.
func (c LcsMinmatchlen) Build() Completed {
	return completed(c)
}

type LcsWithmatchlen Base

// Return Completed Redis command.
func (c LcsWithmatchlen) Build() Completed {
	return completed(c)
}

// Get an element from a list by its index.
//
// Time complexity: O(N) where N is the number of elements to traverse to get to the element at index. This makes asking for the first or the last element of the list O(1).
type Lindex Base

// Get an element from a list by its index
//
// Command: LINDEX.
//
// Time complexity: O(N) where N is the number of elements to traverse to get to the element at index. This makes asking for the first or the last element of the list O(1).
func (b Builder) Lindex() Lindex {
	c := Lindex{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("LINDEX")
	return c
}

func (c Lindex) Key(key string) LindexKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return LindexKey(c)
}

type LindexIndex Base

// Return Completed Redis command.
func (c LindexIndex) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c LindexIndex) Cache() Cacheable {
	return cacheable(c)
}

type LindexKey Base

func (c LindexKey) Index(index int64) LindexIndex {
	c.command.append(strconv.FormatInt(index, 10))
	return LindexIndex(c)
}

// Insert an element before or after another element in a list.
//
// Time complexity: O(N) where N is the number of elements to traverse before seeing the value pivot. This means that inserting somewhere on the left end on the list (head) can be considered O(1) and inserting somewhere on the right end (tail) is O(N).
type Linsert Base

// Insert an element before or after another element in a list
//
// Command: LINSERT.
//
// Time complexity: O(N) where N is the number of elements to traverse before seeing the value pivot. This means that inserting somewhere on the left end on the list (head) can be considered O(1) and inserting somewhere on the right end (tail) is O(N).
func (b Builder) Linsert() Linsert {
	c := Linsert{command: emptyCommand(), cslot: b.slot}
	c.command.append("LINSERT")
	return c
}

func (c Linsert) Key(key string) LinsertKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return LinsertKey(c)
}

type LinsertElement Base

// Return Completed Redis command.
func (c LinsertElement) Build() Completed {
	return completed(c)
}

type LinsertKey Base

func (c LinsertKey) Before() LinsertWhereBefore {
	c.command.append("BEFORE")
	return LinsertWhereBefore(c)
}

func (c LinsertKey) After() LinsertWhereAfter {
	c.command.append("AFTER")
	return LinsertWhereAfter(c)
}

type LinsertPivot Base

func (c LinsertPivot) Element(element string) LinsertElement {
	c.command.append(element)
	return LinsertElement(c)
}

type LinsertWhereAfter Base

func (c LinsertWhereAfter) Pivot(pivot string) LinsertPivot {
	c.command.append(pivot)
	return LinsertPivot(c)
}

type LinsertWhereBefore Base

func (c LinsertWhereBefore) Pivot(pivot string) LinsertPivot {
	c.command.append(pivot)
	return LinsertPivot(c)
}

// Get the length of a list.
//
// Time complexity: O(1)
type Llen Base

// Get the length of a list
//
// Command: LLEN.
//
// Time complexity: O(1)
func (b Builder) Llen() Llen {
	c := Llen{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("LLEN")
	return c
}

func (c Llen) Key(key string) LlenKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return LlenKey(c)
}

type LlenKey Base

// Return Completed Redis command.
func (c LlenKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c LlenKey) Cache() Cacheable {
	return cacheable(c)
}

// Pop an element from a list, push it to another list and return it.
//
// Time complexity: O(1)
type Lmove Base

// Pop an element from a list, push it to another list and return it
//
// Command: LMOVE.
//
// Time complexity: O(1)
func (b Builder) Lmove() Lmove {
	c := Lmove{command: emptyCommand(), cslot: b.slot}
	c.command.append("LMOVE")
	return c
}

func (c Lmove) Source(source string) LmoveSource {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(source)
	} else {
		c.cslot.set(getSlot(source))
	}
	c.command.append(source)
	return LmoveSource(c)
}

type LmoveDestination Base

func (c LmoveDestination) Left() LmoveWherefromLeft {
	c.command.append("LEFT")
	return LmoveWherefromLeft(c)
}

func (c LmoveDestination) Right() LmoveWherefromRight {
	c.command.append("RIGHT")
	return LmoveWherefromRight(c)
}

type LmoveSource Base

func (c LmoveSource) Destination(destination string) LmoveDestination {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append(destination)
	return LmoveDestination(c)
}

type LmoveWherefromLeft Base

func (c LmoveWherefromLeft) Left() LmoveWheretoLeft {
	c.command.append("LEFT")
	return LmoveWheretoLeft(c)
}

func (c LmoveWherefromLeft) Right() LmoveWheretoRight {
	c.command.append("RIGHT")
	return LmoveWheretoRight(c)
}

type LmoveWherefromRight Base

func (c LmoveWherefromRight) Left() LmoveWheretoLeft {
	c.command.append("LEFT")
	return LmoveWheretoLeft(c)
}

func (c LmoveWherefromRight) Right() LmoveWheretoRight {
	c.command.append("RIGHT")
	return LmoveWheretoRight(c)
}

type LmoveWheretoLeft Base

// Return Completed Redis command.
func (c LmoveWheretoLeft) Build() Completed {
	return completed(c)
}

type LmoveWheretoRight Base

// Return Completed Redis command.
func (c LmoveWheretoRight) Build() Completed {
	return completed(c)
}

// Pop elements from a list.
//
// Time complexity: O(N+M) where N is the number of provided keys and M is the number of elements returned.
type Lmpop Base

// Pop elements from a list
//
// Command: LMPOP.
//
// Time complexity: O(N+M) where N is the number of provided keys and M is the number of elements returned.
func (b Builder) Lmpop() Lmpop {
	c := Lmpop{command: emptyCommand(), cslot: b.slot}
	c.command.append("LMPOP")
	return c
}

func (c Lmpop) Numkeys(numkeys int64) LmpopNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return LmpopNumkeys(c)
}

type LmpopCount Base

// Return Completed Redis command.
func (c LmpopCount) Build() Completed {
	return completed(c)
}

type LmpopKey Base

func (c LmpopKey) Key(key ...string) LmpopKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c LmpopKey) Left() LmpopWhereLeft {
	c.command.append("LEFT")
	return LmpopWhereLeft(c)
}

func (c LmpopKey) Right() LmpopWhereRight {
	c.command.append("RIGHT")
	return LmpopWhereRight(c)
}

type LmpopNumkeys Base

func (c LmpopNumkeys) Key(key ...string) LmpopKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return LmpopKey(c)
}

type LmpopWhereLeft Base

func (c LmpopWhereLeft) Count(count int64) LmpopCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return LmpopCount(c)
}

// Return Completed Redis command.
func (c LmpopWhereLeft) Build() Completed {
	return completed(c)
}

type LmpopWhereRight Base

func (c LmpopWhereRight) Count(count int64) LmpopCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return LmpopCount(c)
}

// Return Completed Redis command.
func (c LmpopWhereRight) Build() Completed {
	return completed(c)
}

// Display some computer art and the Redis version.
type Lolwut Base

// Display some computer art and the Redis version
//
// Command: LOLWUT.
func (b Builder) Lolwut() Lolwut {
	c := Lolwut{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("LOLWUT")
	return c
}

func (c Lolwut) Version(version int64) LolwutVersion {
	c.command.append("VERSION", strconv.FormatInt(version, 10))
	return LolwutVersion(c)
}

// Return Completed Redis command.
func (c Lolwut) Build() Completed {
	return completed(c)
}

type LolwutVersion Base

// Return Completed Redis command.
func (c LolwutVersion) Build() Completed {
	return completed(c)
}

// Remove and get the first elements in a list.
//
// Time complexity: O(N) where N is the number of elements returned
type Lpop Base

// Remove and get the first elements in a list
//
// Command: LPOP.
//
// Time complexity: O(N) where N is the number of elements returned
func (b Builder) Lpop() Lpop {
	c := Lpop{command: emptyCommand(), cslot: b.slot}
	c.command.append("LPOP")
	return c
}

func (c Lpop) Key(key string) LpopKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return LpopKey(c)
}

type LpopCount Base

// Return Completed Redis command.
func (c LpopCount) Build() Completed {
	return completed(c)
}

type LpopKey Base

func (c LpopKey) Count(count int64) LpopCount {
	c.command.append(strconv.FormatInt(count, 10))
	return LpopCount(c)
}

// Return Completed Redis command.
func (c LpopKey) Build() Completed {
	return completed(c)
}

// Return the index of matching elements on a list.
//
// Time complexity: O(N) where N is the number of elements in the list, for the average case. When searching for elements near the head or the tail of the list, or when the MAXLEN option is provided, the command may run in constant time.
type Lpos Base

// Return the index of matching elements on a list
//
// Command: LPOS.
//
// Time complexity: O(N) where N is the number of elements in the list, for the average case. When searching for elements near the head or the tail of the list, or when the MAXLEN option is provided, the command may run in constant time.
func (b Builder) Lpos() Lpos {
	c := Lpos{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("LPOS")
	return c
}

func (c Lpos) Key(key string) LposKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return LposKey(c)
}

type LposCount Base

func (c LposCount) Maxlen(len int64) LposMaxlen {
	c.command.append("MAXLEN", strconv.FormatInt(len, 10))
	return LposMaxlen(c)
}

// Return Completed Redis command.
func (c LposCount) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c LposCount) Cache() Cacheable {
	return cacheable(c)
}

type LposElement Base

func (c LposElement) Rank(rank int64) LposRank {
	c.command.append("RANK", strconv.FormatInt(rank, 10))
	return LposRank(c)
}

func (c LposElement) Count(numMatches int64) LposCount {
	c.command.append("COUNT", strconv.FormatInt(numMatches, 10))
	return LposCount(c)
}

func (c LposElement) Maxlen(len int64) LposMaxlen {
	c.command.append("MAXLEN", strconv.FormatInt(len, 10))
	return LposMaxlen(c)
}

// Return Completed Redis command.
func (c LposElement) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c LposElement) Cache() Cacheable {
	return cacheable(c)
}

type LposKey Base

func (c LposKey) Element(element string) LposElement {
	c.command.append(element)
	return LposElement(c)
}

type LposMaxlen Base

// Return Completed Redis command.
func (c LposMaxlen) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c LposMaxlen) Cache() Cacheable {
	return cacheable(c)
}

type LposRank Base

func (c LposRank) Count(numMatches int64) LposCount {
	c.command.append("COUNT", strconv.FormatInt(numMatches, 10))
	return LposCount(c)
}

func (c LposRank) Maxlen(len int64) LposMaxlen {
	c.command.append("MAXLEN", strconv.FormatInt(len, 10))
	return LposMaxlen(c)
}

// Return Completed Redis command.
func (c LposRank) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c LposRank) Cache() Cacheable {
	return cacheable(c)
}

// Prepend one or multiple elements to a list.
//
// Time complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.
type Lpush Base

// Prepend one or multiple elements to a list
//
// Command: LPUSH.
//
// Time complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.
func (b Builder) Lpush() Lpush {
	c := Lpush{command: emptyCommand(), cslot: b.slot}
	c.command.append("LPUSH")
	return c
}

func (c Lpush) Key(key string) LpushKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return LpushKey(c)
}

type LpushElement Base

func (c LpushElement) Element(element ...string) LpushElement {
	c.command.append(element...)
	return c
}

// Return Completed Redis command.
func (c LpushElement) Build() Completed {
	return completed(c)
}

type LpushKey Base

func (c LpushKey) Element(element ...string) LpushElement {
	c.command.append(element...)
	return LpushElement(c)
}

// Prepend an element to a list, only if the list exists.
//
// Time complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.
type Lpushx Base

// Prepend an element to a list, only if the list exists
//
// Command: LPUSHX.
//
// Time complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.
func (b Builder) Lpushx() Lpushx {
	c := Lpushx{command: emptyCommand(), cslot: b.slot}
	c.command.append("LPUSHX")
	return c
}

func (c Lpushx) Key(key string) LpushxKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return LpushxKey(c)
}

type LpushxElement Base

func (c LpushxElement) Element(element ...string) LpushxElement {
	c.command.append(element...)
	return c
}

// Return Completed Redis command.
func (c LpushxElement) Build() Completed {
	return completed(c)
}

type LpushxKey Base

func (c LpushxKey) Element(element ...string) LpushxElement {
	c.command.append(element...)
	return LpushxElement(c)
}

// Get a range of elements from a list.
//
// Time complexity: O(S+N) where S is the distance of start offset from HEAD for small lists, from nearest end (HEAD or TAIL) for large lists; and N is the number of elements in the specified range.
type Lrange Base

// Get a range of elements from a list
//
// Command: LRANGE.
//
// Time complexity: O(S+N) where S is the distance of start offset from HEAD for small lists, from nearest end (HEAD or TAIL) for large lists; and N is the number of elements in the specified range.
func (b Builder) Lrange() Lrange {
	c := Lrange{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("LRANGE")
	return c
}

func (c Lrange) Key(key string) LrangeKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return LrangeKey(c)
}

type LrangeKey Base

func (c LrangeKey) Start(start int64) LrangeStart {
	c.command.append(strconv.FormatInt(start, 10))
	return LrangeStart(c)
}

type LrangeStart Base

func (c LrangeStart) Stop(stop int64) LrangeStop {
	c.command.append(strconv.FormatInt(stop, 10))
	return LrangeStop(c)
}

type LrangeStop Base

// Return Completed Redis command.
func (c LrangeStop) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c LrangeStop) Cache() Cacheable {
	return cacheable(c)
}

// Remove elements from a list.
//
// Time complexity: O(N+M) where N is the length of the list and M is the number of elements removed.
type Lrem Base

// Remove elements from a list
//
// Command: LREM.
//
// Time complexity: O(N+M) where N is the length of the list and M is the number of elements removed.
func (b Builder) Lrem() Lrem {
	c := Lrem{command: emptyCommand(), cslot: b.slot}
	c.command.append("LREM")
	return c
}

func (c Lrem) Key(key string) LremKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return LremKey(c)
}

type LremCount Base

func (c LremCount) Element(element string) LremElement {
	c.command.append(element)
	return LremElement(c)
}

type LremElement Base

// Return Completed Redis command.
func (c LremElement) Build() Completed {
	return completed(c)
}

type LremKey Base

func (c LremKey) Count(count int64) LremCount {
	c.command.append(strconv.FormatInt(count, 10))
	return LremCount(c)
}

// Set the value of an element in a list by its index.
//
// Time complexity: O(N) where N is the length of the list. Setting either the first or the last element of the list is O(1).
type Lset Base

// Set the value of an element in a list by its index
//
// Command: LSET.
//
// Time complexity: O(N) where N is the length of the list. Setting either the first or the last element of the list is O(1).
func (b Builder) Lset() Lset {
	c := Lset{command: emptyCommand(), cslot: b.slot}
	c.command.append("LSET")
	return c
}

func (c Lset) Key(key string) LsetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return LsetKey(c)
}

type LsetElement Base

// Return Completed Redis command.
func (c LsetElement) Build() Completed {
	return completed(c)
}

type LsetIndex Base

func (c LsetIndex) Element(element string) LsetElement {
	c.command.append(element)
	return LsetElement(c)
}

type LsetKey Base

func (c LsetKey) Index(index int64) LsetIndex {
	c.command.append(strconv.FormatInt(index, 10))
	return LsetIndex(c)
}

// Trim a list to the specified range.
//
// Time complexity: O(N) where N is the number of elements to be removed by the operation.
type Ltrim Base

// Trim a list to the specified range
//
// Command: LTRIM.
//
// Time complexity: O(N) where N is the number of elements to be removed by the operation.
func (b Builder) Ltrim() Ltrim {
	c := Ltrim{command: emptyCommand(), cslot: b.slot}
	c.command.append("LTRIM")
	return c
}

func (c Ltrim) Key(key string) LtrimKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return LtrimKey(c)
}

type LtrimKey Base

func (c LtrimKey) Start(start int64) LtrimStart {
	c.command.append(strconv.FormatInt(start, 10))
	return LtrimStart(c)
}

type LtrimStart Base

func (c LtrimStart) Stop(stop int64) LtrimStop {
	c.command.append(strconv.FormatInt(stop, 10))
	return LtrimStop(c)
}

type LtrimStop Base

// Return Completed Redis command.
func (c LtrimStop) Build() Completed {
	return completed(c)
}

// Outputs memory problems report.
type MemoryDoctor Base

// Outputs memory problems report
//
// Command: MEMORY DOCTOR.
func (b Builder) MemoryDoctor() MemoryDoctor {
	c := MemoryDoctor{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("MEMORY", "DOCTOR")
	return c
}

// Return Completed Redis command.
func (c MemoryDoctor) Build() Completed {
	return completed(c)
}

// Show helpful text about the different subcommands.
type MemoryHelp Base

// Show helpful text about the different subcommands
//
// Command: MEMORY HELP.
func (b Builder) MemoryHelp() MemoryHelp {
	c := MemoryHelp{command: emptyCommand(), cslot: b.slot}
	c.command.append("MEMORY", "HELP")
	return c
}

// Return Completed Redis command.
func (c MemoryHelp) Build() Completed {
	return completed(c)
}

// Show allocator internal stats.
type MemoryMallocStats Base

// Show allocator internal stats
//
// Command: MEMORY MALLOC-STATS.
func (b Builder) MemoryMallocStats() MemoryMallocStats {
	c := MemoryMallocStats{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("MEMORY", "MALLOC-STATS")
	return c
}

// Return Completed Redis command.
func (c MemoryMallocStats) Build() Completed {
	return completed(c)
}

// Ask the allocator to release memory.
type MemoryPurge Base

// Ask the allocator to release memory
//
// Command: MEMORY PURGE.
func (b Builder) MemoryPurge() MemoryPurge {
	c := MemoryPurge{command: emptyCommand(), cslot: b.slot}
	c.command.append("MEMORY", "PURGE")
	return c
}

// Return Completed Redis command.
func (c MemoryPurge) Build() Completed {
	return completed(c)
}

// Show memory usage details.
type MemoryStats Base

// Show memory usage details
//
// Command: MEMORY STATS.
func (b Builder) MemoryStats() MemoryStats {
	c := MemoryStats{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("MEMORY", "STATS")
	return c
}

// Return Completed Redis command.
func (c MemoryStats) Build() Completed {
	return completed(c)
}

// Estimate the memory usage of a key.
//
// Time complexity: O(N) where N is the number of samples.
type MemoryUsage Base

// Estimate the memory usage of a key
//
// Command: MEMORY USAGE.
//
// Time complexity: O(N) where N is the number of samples.
func (b Builder) MemoryUsage() MemoryUsage {
	c := MemoryUsage{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("MEMORY", "USAGE")
	return c
}

func (c MemoryUsage) Key(key string) MemoryUsageKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return MemoryUsageKey(c)
}

type MemoryUsageKey Base

func (c MemoryUsageKey) Samples(count int64) MemoryUsageSamples {
	c.command.append("SAMPLES", strconv.FormatInt(count, 10))
	return MemoryUsageSamples(c)
}

// Return Completed Redis command.
func (c MemoryUsageKey) Build() Completed {
	return completed(c)
}

type MemoryUsageSamples Base

// Return Completed Redis command.
func (c MemoryUsageSamples) Build() Completed {
	return completed(c)
}

// Get the values of all the given keys.
//
// Time complexity: O(N) where N is the number of keys to retrieve.
type Mget Base

// Get the values of all the given keys
//
// Command: MGET.
//
// Time complexity: O(N) where N is the number of keys to retrieve.
func (b Builder) Mget() Mget {
	c := Mget{command: emptyCommand(), cslot: b.slot, ctags: ctagMtGet}
	c.command.append("MGET")
	return c
}

func (c Mget) Key(key ...string) MgetKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return MgetKey(c)
}

type MgetKey Base

func (c MgetKey) Key(key ...string) MgetKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c MgetKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c MgetKey) Cache() Cacheable {
	return cacheable(c)
}

// Atomically transfer a key from a Redis instance to another one..
//
// Time complexity: This command actually executes a DUMP+DEL in the source instance, and a RESTORE in the target instance. See the pages of these commands for time complexity. Also an O(N) data transfer between the two instances is performed.
type Migrate Base

// Atomically transfer a key from a Redis instance to another one.
//
// Command: MIGRATE.
//
// Time complexity: This command actually executes a DUMP+DEL in the source instance, and a RESTORE in the target instance. See the pages of these commands for time complexity. Also an O(N) data transfer between the two instances is performed.
func (b Builder) Migrate() Migrate {
	c := Migrate{command: emptyCommand(), cslot: b.slot, ctags: ctagBlock}
	c.command.append("MIGRATE")
	return c
}

func (c Migrate) Host(host string) MigrateHost {
	c.command.append(host)
	return MigrateHost(c)
}

type MigrateAuthAuth Base

func (c MigrateAuthAuth) Auth2(username string, password string) MigrateAuthAuth2 {
	c.command.append("AUTH2", username, password)
	return MigrateAuthAuth2(c)
}

func (c MigrateAuthAuth) Keys(key ...string) MigrateKeys {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append("KEYS")
	c.command.append(key...)
	return MigrateKeys(c)
}

// Return Completed Redis command.
func (c MigrateAuthAuth) Build() Completed {
	return completed(c)
}

type MigrateAuthAuth2 Base

func (c MigrateAuthAuth2) Keys(key ...string) MigrateKeys {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append("KEYS")
	c.command.append(key...)
	return MigrateKeys(c)
}

// Return Completed Redis command.
func (c MigrateAuthAuth2) Build() Completed {
	return completed(c)
}

type MigrateCopy Base

func (c MigrateCopy) Replace() MigrateReplace {
	c.command.append("REPLACE")
	return MigrateReplace(c)
}

func (c MigrateCopy) Auth(password string) MigrateAuthAuth {
	c.command.append("AUTH", password)
	return MigrateAuthAuth(c)
}

func (c MigrateCopy) Auth2(username string, password string) MigrateAuthAuth2 {
	c.command.append("AUTH2", username, password)
	return MigrateAuthAuth2(c)
}

func (c MigrateCopy) Keys(key ...string) MigrateKeys {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append("KEYS")
	c.command.append(key...)
	return MigrateKeys(c)
}

// Return Completed Redis command.
func (c MigrateCopy) Build() Completed {
	return completed(c)
}

type MigrateDestinationDb Base

func (c MigrateDestinationDb) Timeout(timeout int64) MigrateTimeout {
	c.command.append(strconv.FormatInt(timeout, 10))
	return MigrateTimeout(c)
}

type MigrateHost Base

func (c MigrateHost) Port(port int64) MigratePort {
	c.command.append(strconv.FormatInt(port, 10))
	return MigratePort(c)
}

type MigrateKey Base

func (c MigrateKey) DestinationDb(destinationDb int64) MigrateDestinationDb {
	c.command.append(strconv.FormatInt(destinationDb, 10))
	return MigrateDestinationDb(c)
}

type MigrateKeys Base

func (c MigrateKeys) Keys(key ...string) MigrateKeys {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append("KEYS")
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c MigrateKeys) Build() Completed {
	return completed(c)
}

type MigratePort Base

func (c MigratePort) Key(key string) MigrateKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return MigrateKey(c)
}

type MigrateReplace Base

func (c MigrateReplace) Auth(password string) MigrateAuthAuth {
	c.command.append("AUTH", password)
	return MigrateAuthAuth(c)
}

func (c MigrateReplace) Auth2(username string, password string) MigrateAuthAuth2 {
	c.command.append("AUTH2", username, password)
	return MigrateAuthAuth2(c)
}

func (c MigrateReplace) Keys(key ...string) MigrateKeys {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append("KEYS")
	c.command.append(key...)
	return MigrateKeys(c)
}

// Return Completed Redis command.
func (c MigrateReplace) Build() Completed {
	return completed(c)
}

type MigrateTimeout Base

func (c MigrateTimeout) Copy() MigrateCopy {
	c.command.append("COPY")
	return MigrateCopy(c)
}

func (c MigrateTimeout) Replace() MigrateReplace {
	c.command.append("REPLACE")
	return MigrateReplace(c)
}

func (c MigrateTimeout) Auth(password string) MigrateAuthAuth {
	c.command.append("AUTH", password)
	return MigrateAuthAuth(c)
}

func (c MigrateTimeout) Auth2(username string, password string) MigrateAuthAuth2 {
	c.command.append("AUTH2", username, password)
	return MigrateAuthAuth2(c)
}

func (c MigrateTimeout) Keys(key ...string) MigrateKeys {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append("KEYS")
	c.command.append(key...)
	return MigrateKeys(c)
}

// Return Completed Redis command.
func (c MigrateTimeout) Build() Completed {
	return completed(c)
}

// List all modules loaded by the server.
//
// Time complexity: O(N) where N is the number of loaded modules.
type ModuleList Base

// List all modules loaded by the server
//
// Command: MODULE LIST.
//
// Time complexity: O(N) where N is the number of loaded modules.
func (b Builder) ModuleList() ModuleList {
	c := ModuleList{command: emptyCommand(), cslot: b.slot}
	c.command.append("MODULE", "LIST")
	return c
}

// Return Completed Redis command.
func (c ModuleList) Build() Completed {
	return completed(c)
}

// Load a module.
//
// Time complexity: O(1)
type ModuleLoad Base

// Load a module
//
// Command: MODULE LOAD.
//
// Time complexity: O(1)
func (b Builder) ModuleLoad() ModuleLoad {
	c := ModuleLoad{command: emptyCommand(), cslot: b.slot}
	c.command.append("MODULE", "LOAD")
	return c
}

func (c ModuleLoad) Path(path string) ModuleLoadPath {
	c.command.append(path)
	return ModuleLoadPath(c)
}

type ModuleLoadArg Base

func (c ModuleLoadArg) Arg(arg ...string) ModuleLoadArg {
	c.command.append(arg...)
	return c
}

// Return Completed Redis command.
func (c ModuleLoadArg) Build() Completed {
	return completed(c)
}

type ModuleLoadPath Base

func (c ModuleLoadPath) Arg(arg ...string) ModuleLoadArg {
	c.command.append(arg...)
	return ModuleLoadArg(c)
}

// Return Completed Redis command.
func (c ModuleLoadPath) Build() Completed {
	return completed(c)
}

type ModuleLoadex Base

// Command: MODULE LOADEX.
func (b Builder) ModuleLoadex() ModuleLoadex {
	c := ModuleLoadex{command: emptyCommand(), cslot: b.slot}
	c.command.append("MODULE", "LOADEX")
	return c
}

func (c ModuleLoadex) Path(path string) ModuleLoadexPath {
	c.command.append(path)
	return ModuleLoadexPath(c)
}

type ModuleLoadexArgs Base

func (c ModuleLoadexArgs) Args(args ...string) ModuleLoadexArgs {
	c.command.append("ARGS")
	c.command.append(args...)
	return c
}

// Return Completed Redis command.
func (c ModuleLoadexArgs) Build() Completed {
	return completed(c)
}

type ModuleLoadexConfig Base

func (c ModuleLoadexConfig) Config(name string, value string) ModuleLoadexConfig {
	c.command.append("CONFIG", name, value)
	return c
}

func (c ModuleLoadexConfig) Args(args ...string) ModuleLoadexArgs {
	c.command.append("ARGS")
	c.command.append(args...)
	return ModuleLoadexArgs(c)
}

// Return Completed Redis command.
func (c ModuleLoadexConfig) Build() Completed {
	return completed(c)
}

type ModuleLoadexPath Base

func (c ModuleLoadexPath) Config() ModuleLoadexConfig {
	return ModuleLoadexConfig(c)
}

func (c ModuleLoadexPath) Args(args ...string) ModuleLoadexArgs {
	c.command.append("ARGS")
	c.command.append(args...)
	return ModuleLoadexArgs(c)
}

// Return Completed Redis command.
func (c ModuleLoadexPath) Build() Completed {
	return completed(c)
}

// Unload a module.
//
// Time complexity: O(1)
type ModuleUnload Base

// Unload a module
//
// Command: MODULE UNLOAD.
//
// Time complexity: O(1)
func (b Builder) ModuleUnload() ModuleUnload {
	c := ModuleUnload{command: emptyCommand(), cslot: b.slot}
	c.command.append("MODULE", "UNLOAD")
	return c
}

func (c ModuleUnload) Name(name string) ModuleUnloadName {
	c.command.append(name)
	return ModuleUnloadName(c)
}

type ModuleUnloadName Base

// Return Completed Redis command.
func (c ModuleUnloadName) Build() Completed {
	return completed(c)
}

// Listen for all requests received by the server in real time.
type Monitor Base

// Listen for all requests received by the server in real time
//
// Command: MONITOR.
func (b Builder) Monitor() Monitor {
	c := Monitor{command: emptyCommand(), cslot: b.slot}
	c.command.append("MONITOR")
	return c
}

// Return Completed Redis command.
func (c Monitor) Build() Completed {
	return completed(c)
}

// Move a key to another database.
//
// Time complexity: O(1)
type Move Base

// Move a key to another database
//
// Command: MOVE.
//
// Time complexity: O(1)
func (b Builder) Move() Move {
	c := Move{command: emptyCommand(), cslot: b.slot}
	c.command.append("MOVE")
	return c
}

func (c Move) Key(key string) MoveKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return MoveKey(c)
}

type MoveDb Base

// Return Completed Redis command.
func (c MoveDb) Build() Completed {
	return completed(c)
}

type MoveKey Base

func (c MoveKey) Db(db int64) MoveDb {
	c.command.append(strconv.FormatInt(db, 10))
	return MoveDb(c)
}

// Set multiple keys to multiple values.
//
// Time complexity: O(N) where N is the number of keys to set.
type Mset Base

// Set multiple keys to multiple values
//
// Command: MSET.
//
// Time complexity: O(N) where N is the number of keys to set.
func (b Builder) Mset() Mset {
	c := Mset{command: emptyCommand(), cslot: b.slot}
	c.command.append("MSET")
	return c
}

func (c Mset) KeyValue() MsetKeyValue {
	return MsetKeyValue(c)
}

type MsetKeyValue Base

func (c MsetKeyValue) KeyValue(key string, value string) MsetKeyValue {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key, value)
	return c
}

// Return Completed Redis command.
func (c MsetKeyValue) Build() Completed {
	return completed(c)
}

// Set multiple keys to multiple values, only if none of the keys exist.
//
// Time complexity: O(N) where N is the number of keys to set.
type Msetnx Base

// Set multiple keys to multiple values, only if none of the keys exist
//
// Command: MSETNX.
//
// Time complexity: O(N) where N is the number of keys to set.
func (b Builder) Msetnx() Msetnx {
	c := Msetnx{command: emptyCommand(), cslot: b.slot}
	c.command.append("MSETNX")
	return c
}

func (c Msetnx) KeyValue() MsetnxKeyValue {
	return MsetnxKeyValue(c)
}

type MsetnxKeyValue Base

func (c MsetnxKeyValue) KeyValue(key string, value string) MsetnxKeyValue {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key, value)
	return c
}

// Return Completed Redis command.
func (c MsetnxKeyValue) Build() Completed {
	return completed(c)
}

// Mark the start of a transaction block.
type Multi Base

// Mark the start of a transaction block
//
// Command: MULTI.
func (b Builder) Multi() Multi {
	c := Multi{command: emptyCommand(), cslot: b.slot}
	c.command.append("MULTI")
	return c
}

// Return Completed Redis command.
func (c Multi) Build() Completed {
	return completed(c)
}

// Inspect the internal encoding of a Redis object.
//
// Time complexity: O(1)
type ObjectEncoding Base

// Inspect the internal encoding of a Redis object
//
// Command: OBJECT ENCODING.
//
// Time complexity: O(1)
func (b Builder) ObjectEncoding() ObjectEncoding {
	c := ObjectEncoding{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("OBJECT", "ENCODING")
	return c
}

func (c ObjectEncoding) Key(key string) ObjectEncodingKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ObjectEncodingKey(c)
}

type ObjectEncodingKey Base

// Return Completed Redis command.
func (c ObjectEncodingKey) Build() Completed {
	return completed(c)
}

// Get the logarithmic access frequency counter of a Redis object.
//
// Time complexity: O(1)
type ObjectFreq Base

// Get the logarithmic access frequency counter of a Redis object
//
// Command: OBJECT FREQ.
//
// Time complexity: O(1)
func (b Builder) ObjectFreq() ObjectFreq {
	c := ObjectFreq{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("OBJECT", "FREQ")
	return c
}

func (c ObjectFreq) Key(key string) ObjectFreqKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ObjectFreqKey(c)
}

type ObjectFreqKey Base

// Return Completed Redis command.
func (c ObjectFreqKey) Build() Completed {
	return completed(c)
}

// Show helpful text about the different subcommands.
//
// Time complexity: O(1)
type ObjectHelp Base

// Show helpful text about the different subcommands
//
// Command: OBJECT HELP.
//
// Time complexity: O(1)
func (b Builder) ObjectHelp() ObjectHelp {
	c := ObjectHelp{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("OBJECT", "HELP")
	return c
}

// Return Completed Redis command.
func (c ObjectHelp) Build() Completed {
	return completed(c)
}

// Get the time since a Redis object was last accessed.
//
// Time complexity: O(1)
type ObjectIdletime Base

// Get the time since a Redis object was last accessed
//
// Command: OBJECT IDLETIME.
//
// Time complexity: O(1)
func (b Builder) ObjectIdletime() ObjectIdletime {
	c := ObjectIdletime{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("OBJECT", "IDLETIME")
	return c
}

func (c ObjectIdletime) Key(key string) ObjectIdletimeKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ObjectIdletimeKey(c)
}

type ObjectIdletimeKey Base

// Return Completed Redis command.
func (c ObjectIdletimeKey) Build() Completed {
	return completed(c)
}

// Get the number of references to the value of the key.
//
// Time complexity: O(1)
type ObjectRefcount Base

// Get the number of references to the value of the key
//
// Command: OBJECT REFCOUNT.
//
// Time complexity: O(1)
func (b Builder) ObjectRefcount() ObjectRefcount {
	c := ObjectRefcount{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("OBJECT", "REFCOUNT")
	return c
}

func (c ObjectRefcount) Key(key string) ObjectRefcountKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ObjectRefcountKey(c)
}

type ObjectRefcountKey Base

// Return Completed Redis command.
func (c ObjectRefcountKey) Build() Completed {
	return completed(c)
}

// Remove the expiration from a key.
//
// Time complexity: O(1)
type Persist Base

// Remove the expiration from a key
//
// Command: PERSIST.
//
// Time complexity: O(1)
func (b Builder) Persist() Persist {
	c := Persist{command: emptyCommand(), cslot: b.slot}
	c.command.append("PERSIST")
	return c
}

func (c Persist) Key(key string) PersistKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return PersistKey(c)
}

type PersistKey Base

// Return Completed Redis command.
func (c PersistKey) Build() Completed {
	return completed(c)
}

// Set a key's time to live in milliseconds.
//
// Time complexity: O(1)
type Pexpire Base

// Set a key's time to live in milliseconds
//
// Command: PEXPIRE.
//
// Time complexity: O(1)
func (b Builder) Pexpire() Pexpire {
	c := Pexpire{command: emptyCommand(), cslot: b.slot}
	c.command.append("PEXPIRE")
	return c
}

func (c Pexpire) Key(key string) PexpireKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return PexpireKey(c)
}

type PexpireConditionGt Base

// Return Completed Redis command.
func (c PexpireConditionGt) Build() Completed {
	return completed(c)
}

type PexpireConditionLt Base

// Return Completed Redis command.
func (c PexpireConditionLt) Build() Completed {
	return completed(c)
}

type PexpireConditionNx Base

// Return Completed Redis command.
func (c PexpireConditionNx) Build() Completed {
	return completed(c)
}

type PexpireConditionXx Base

// Return Completed Redis command.
func (c PexpireConditionXx) Build() Completed {
	return completed(c)
}

type PexpireKey Base

func (c PexpireKey) Milliseconds(milliseconds int64) PexpireMilliseconds {
	c.command.append(strconv.FormatInt(milliseconds, 10))
	return PexpireMilliseconds(c)
}

type PexpireMilliseconds Base

func (c PexpireMilliseconds) Nx() PexpireConditionNx {
	c.command.append("NX")
	return PexpireConditionNx(c)
}

func (c PexpireMilliseconds) Xx() PexpireConditionXx {
	c.command.append("XX")
	return PexpireConditionXx(c)
}

func (c PexpireMilliseconds) Gt() PexpireConditionGt {
	c.command.append("GT")
	return PexpireConditionGt(c)
}

func (c PexpireMilliseconds) Lt() PexpireConditionLt {
	c.command.append("LT")
	return PexpireConditionLt(c)
}

// Return Completed Redis command.
func (c PexpireMilliseconds) Build() Completed {
	return completed(c)
}

// Set the expiration for a key as a UNIX timestamp specified in milliseconds.
//
// Time complexity: O(1)
type Pexpireat Base

// Set the expiration for a key as a UNIX timestamp specified in milliseconds
//
// Command: PEXPIREAT.
//
// Time complexity: O(1)
func (b Builder) Pexpireat() Pexpireat {
	c := Pexpireat{command: emptyCommand(), cslot: b.slot}
	c.command.append("PEXPIREAT")
	return c
}

func (c Pexpireat) Key(key string) PexpireatKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return PexpireatKey(c)
}

type PexpireatConditionGt Base

// Return Completed Redis command.
func (c PexpireatConditionGt) Build() Completed {
	return completed(c)
}

type PexpireatConditionLt Base

// Return Completed Redis command.
func (c PexpireatConditionLt) Build() Completed {
	return completed(c)
}

type PexpireatConditionNx Base

// Return Completed Redis command.
func (c PexpireatConditionNx) Build() Completed {
	return completed(c)
}

type PexpireatConditionXx Base

// Return Completed Redis command.
func (c PexpireatConditionXx) Build() Completed {
	return completed(c)
}

type PexpireatKey Base

func (c PexpireatKey) MillisecondsTimestamp(millisecondsTimestamp int64) PexpireatMillisecondsTimestamp {
	c.command.append(strconv.FormatInt(millisecondsTimestamp, 10))
	return PexpireatMillisecondsTimestamp(c)
}

type PexpireatMillisecondsTimestamp Base

func (c PexpireatMillisecondsTimestamp) Nx() PexpireatConditionNx {
	c.command.append("NX")
	return PexpireatConditionNx(c)
}

func (c PexpireatMillisecondsTimestamp) Xx() PexpireatConditionXx {
	c.command.append("XX")
	return PexpireatConditionXx(c)
}

func (c PexpireatMillisecondsTimestamp) Gt() PexpireatConditionGt {
	c.command.append("GT")
	return PexpireatConditionGt(c)
}

func (c PexpireatMillisecondsTimestamp) Lt() PexpireatConditionLt {
	c.command.append("LT")
	return PexpireatConditionLt(c)
}

// Return Completed Redis command.
func (c PexpireatMillisecondsTimestamp) Build() Completed {
	return completed(c)
}

// Get the expiration Unix timestamp for a key in milliseconds.
//
// Time complexity: O(1)
type Pexpiretime Base

// Get the expiration Unix timestamp for a key in milliseconds
//
// Command: PEXPIRETIME.
//
// Time complexity: O(1)
func (b Builder) Pexpiretime() Pexpiretime {
	c := Pexpiretime{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("PEXPIRETIME")
	return c
}

func (c Pexpiretime) Key(key string) PexpiretimeKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return PexpiretimeKey(c)
}

type PexpiretimeKey Base

// Return Completed Redis command.
func (c PexpiretimeKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c PexpiretimeKey) Cache() Cacheable {
	return cacheable(c)
}

// Adds the specified elements to the specified HyperLogLog..
//
// Time complexity: O(1) to add every element.
type Pfadd Base

// Adds the specified elements to the specified HyperLogLog.
//
// Command: PFADD.
//
// Time complexity: O(1) to add every element.
func (b Builder) Pfadd() Pfadd {
	c := Pfadd{command: emptyCommand(), cslot: b.slot}
	c.command.append("PFADD")
	return c
}

func (c Pfadd) Key(key string) PfaddKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return PfaddKey(c)
}

type PfaddElement Base

func (c PfaddElement) Element(element ...string) PfaddElement {
	c.command.append(element...)
	return c
}

// Return Completed Redis command.
func (c PfaddElement) Build() Completed {
	return completed(c)
}

type PfaddKey Base

func (c PfaddKey) Element(element ...string) PfaddElement {
	c.command.append(element...)
	return PfaddElement(c)
}

// Return Completed Redis command.
func (c PfaddKey) Build() Completed {
	return completed(c)
}

// Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s)..
//
// Time complexity: O(1) with a very small average constant time when called with a single key. O(N) with N being the number of keys, and much bigger constant times, when called with multiple keys.
type Pfcount Base

// Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).
//
// Command: PFCOUNT.
//
// Time complexity: O(1) with a very small average constant time when called with a single key. O(N) with N being the number of keys, and much bigger constant times, when called with multiple keys.
func (b Builder) Pfcount() Pfcount {
	c := Pfcount{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("PFCOUNT")
	return c
}

func (c Pfcount) Key(key ...string) PfcountKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return PfcountKey(c)
}

type PfcountKey Base

func (c PfcountKey) Key(key ...string) PfcountKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c PfcountKey) Build() Completed {
	return completed(c)
}

// Merge N different HyperLogLogs into a single one..
//
// Time complexity: O(N) to merge N HyperLogLogs, but with high constant times.
type Pfmerge Base

// Merge N different HyperLogLogs into a single one.
//
// Command: PFMERGE.
//
// Time complexity: O(N) to merge N HyperLogLogs, but with high constant times.
func (b Builder) Pfmerge() Pfmerge {
	c := Pfmerge{command: emptyCommand(), cslot: b.slot}
	c.command.append("PFMERGE")
	return c
}

func (c Pfmerge) Destkey(destkey string) PfmergeDestkey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destkey)
	} else {
		c.cslot.set(getSlot(destkey))
	}
	c.command.append(destkey)
	return PfmergeDestkey(c)
}

type PfmergeDestkey Base

func (c PfmergeDestkey) Sourcekey(sourcekey ...string) PfmergeSourcekey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range sourcekey {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range sourcekey {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(sourcekey...)
	return PfmergeSourcekey(c)
}

type PfmergeSourcekey Base

func (c PfmergeSourcekey) Sourcekey(sourcekey ...string) PfmergeSourcekey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range sourcekey {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range sourcekey {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(sourcekey...)
	return c
}

// Return Completed Redis command.
func (c PfmergeSourcekey) Build() Completed {
	return completed(c)
}

// Ping the server.
type Ping Base

// Ping the server
//
// Command: PING.
func (b Builder) Ping() Ping {
	c := Ping{command: emptyCommand(), cslot: b.slot}
	c.command.append("PING")
	return c
}

func (c Ping) Message(message string) PingMessage {
	c.command.append(message)
	return PingMessage(c)
}

// Return Completed Redis command.
func (c Ping) Build() Completed {
	return completed(c)
}

type PingMessage Base

// Return Completed Redis command.
func (c PingMessage) Build() Completed {
	return completed(c)
}

// Set the value and expiration in milliseconds of a key.
//
// Time complexity: O(1)
type Psetex Base

// Set the value and expiration in milliseconds of a key
//
// Command: PSETEX.
//
// Time complexity: O(1)
func (b Builder) Psetex() Psetex {
	c := Psetex{command: emptyCommand(), cslot: b.slot}
	c.command.append("PSETEX")
	return c
}

func (c Psetex) Key(key string) PsetexKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return PsetexKey(c)
}

type PsetexKey Base

func (c PsetexKey) Milliseconds(milliseconds int64) PsetexMilliseconds {
	c.command.append(strconv.FormatInt(milliseconds, 10))
	return PsetexMilliseconds(c)
}

type PsetexMilliseconds Base

func (c PsetexMilliseconds) Value(value string) PsetexValue {
	c.command.append(value)
	return PsetexValue(c)
}

type PsetexValue Base

// Return Completed Redis command.
func (c PsetexValue) Build() Completed {
	return completed(c)
}

// Listen for messages published to channels matching the given patterns.
//
// Time complexity: O(N) where N is the number of patterns the client is already subscribed to.
type Psubscribe Base

// Listen for messages published to channels matching the given patterns
//
// Command: PSUBSCRIBE.
//
// Time complexity: O(N) where N is the number of patterns the client is already subscribed to.
func (b Builder) Psubscribe() Psubscribe {
	c := Psubscribe{command: emptyCommand(), cslot: b.slot, ctags: ctagNoRet}
	c.command.append("PSUBSCRIBE")
	return c
}

func (c Psubscribe) Pattern(pattern ...string) PsubscribePattern {
	c.command.append(pattern...)
	return PsubscribePattern(c)
}

type PsubscribePattern Base

func (c PsubscribePattern) Pattern(pattern ...string) PsubscribePattern {
	c.command.append(pattern...)
	return c
}

// Return Completed Redis command.
func (c PsubscribePattern) Build() Completed {
	return completed(c)
}

// Internal command used for replication.
type Psync Base

// Internal command used for replication
//
// Command: PSYNC.
func (b Builder) Psync() Psync {
	c := Psync{command: emptyCommand(), cslot: b.slot}
	c.command.append("PSYNC")
	return c
}

func (c Psync) Replicationid(replicationid string) PsyncReplicationid {
	c.command.append(replicationid)
	return PsyncReplicationid(c)
}

type PsyncOffset Base

// Return Completed Redis command.
func (c PsyncOffset) Build() Completed {
	return completed(c)
}

type PsyncReplicationid Base

func (c PsyncReplicationid) Offset(offset int64) PsyncOffset {
	c.command.append(strconv.FormatInt(offset, 10))
	return PsyncOffset(c)
}

// Get the time to live for a key in milliseconds.
//
// Time complexity: O(1)
type Pttl Base

// Get the time to live for a key in milliseconds
//
// Command: PTTL.
//
// Time complexity: O(1)
func (b Builder) Pttl() Pttl {
	c := Pttl{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("PTTL")
	return c
}

func (c Pttl) Key(key string) PttlKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return PttlKey(c)
}

type PttlKey Base

// Return Completed Redis command.
func (c PttlKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c PttlKey) Cache() Cacheable {
	return cacheable(c)
}

// Post a message to a channel.
//
// Time complexity: O(N+M) where N is the number of clients subscribed to the receiving channel and M is the total number of subscribed patterns (by any client).
type Publish Base

// Post a message to a channel
//
// Command: PUBLISH.
//
// Time complexity: O(N+M) where N is the number of clients subscribed to the receiving channel and M is the total number of subscribed patterns (by any client).
func (b Builder) Publish() Publish {
	c := Publish{command: emptyCommand(), cslot: b.slot}
	c.command.append("PUBLISH")
	return c
}

func (c Publish) Channel(channel string) PublishChannel {
	c.command.append(channel)
	return PublishChannel(c)
}

type PublishChannel Base

func (c PublishChannel) Message(message string) PublishMessage {
	c.command.append(message)
	return PublishMessage(c)
}

type PublishMessage Base

// Return Completed Redis command.
func (c PublishMessage) Build() Completed {
	return completed(c)
}

// List active channels.
//
// Time complexity: O(N) where N is the number of active channels, and assuming constant time pattern matching (relatively short channels and patterns)
type PubsubChannels Base

// List active channels
//
// Command: PUBSUB CHANNELS.
//
// Time complexity: O(N) where N is the number of active channels, and assuming constant time pattern matching (relatively short channels and patterns)
func (b Builder) PubsubChannels() PubsubChannels {
	c := PubsubChannels{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("PUBSUB", "CHANNELS")
	return c
}

func (c PubsubChannels) Pattern(pattern string) PubsubChannelsPattern {
	c.command.append(pattern)
	return PubsubChannelsPattern(c)
}

// Return Completed Redis command.
func (c PubsubChannels) Build() Completed {
	return completed(c)
}

type PubsubChannelsPattern Base

// Return Completed Redis command.
func (c PubsubChannelsPattern) Build() Completed {
	return completed(c)
}

// Show helpful text about the different subcommands.
//
// Time complexity: O(1)
type PubsubHelp Base

// Show helpful text about the different subcommands
//
// Command: PUBSUB HELP.
//
// Time complexity: O(1)
func (b Builder) PubsubHelp() PubsubHelp {
	c := PubsubHelp{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("PUBSUB", "HELP")
	return c
}

// Return Completed Redis command.
func (c PubsubHelp) Build() Completed {
	return completed(c)
}

// Get the count of unique patterns pattern subscriptions.
//
// Time complexity: O(1)
type PubsubNumpat Base

// Get the count of unique patterns pattern subscriptions
//
// Command: PUBSUB NUMPAT.
//
// Time complexity: O(1)
func (b Builder) PubsubNumpat() PubsubNumpat {
	c := PubsubNumpat{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("PUBSUB", "NUMPAT")
	return c
}

// Return Completed Redis command.
func (c PubsubNumpat) Build() Completed {
	return completed(c)
}

// Get the count of subscribers for channels.
//
// Time complexity: O(N) for the NUMSUB subcommand, where N is the number of requested channels
type PubsubNumsub Base

// Get the count of subscribers for channels
//
// Command: PUBSUB NUMSUB.
//
// Time complexity: O(N) for the NUMSUB subcommand, where N is the number of requested channels
func (b Builder) PubsubNumsub() PubsubNumsub {
	c := PubsubNumsub{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("PUBSUB", "NUMSUB")
	return c
}

func (c PubsubNumsub) Channel(channel ...string) PubsubNumsubChannel {
	c.command.append(channel...)
	return PubsubNumsubChannel(c)
}

// Return Completed Redis command.
func (c PubsubNumsub) Build() Completed {
	return completed(c)
}

type PubsubNumsubChannel Base

func (c PubsubNumsubChannel) Channel(channel ...string) PubsubNumsubChannel {
	c.command.append(channel...)
	return c
}

// Return Completed Redis command.
func (c PubsubNumsubChannel) Build() Completed {
	return completed(c)
}

type PubsubShardchannels Base

// Command: PUBSUB SHARDCHANNELS.
func (b Builder) PubsubShardchannels() PubsubShardchannels {
	c := PubsubShardchannels{command: emptyCommand(), cslot: b.slot}
	c.command.append("PUBSUB", "SHARDCHANNELS")
	return c
}

func (c PubsubShardchannels) Pattern(pattern string) PubsubShardchannelsPattern {
	c.command.append(pattern)
	return PubsubShardchannelsPattern(c)
}

// Return Completed Redis command.
func (c PubsubShardchannels) Build() Completed {
	return completed(c)
}

type PubsubShardchannelsPattern Base

// Return Completed Redis command.
func (c PubsubShardchannelsPattern) Build() Completed {
	return completed(c)
}

type PubsubShardnumsub Base

// Command: PUBSUB SHARDNUMSUB.
func (b Builder) PubsubShardnumsub() PubsubShardnumsub {
	c := PubsubShardnumsub{command: emptyCommand(), cslot: b.slot}
	c.command.append("PUBSUB", "SHARDNUMSUB")
	return c
}

func (c PubsubShardnumsub) Channel(channel ...string) PubsubShardnumsubChannel {
	c.command.append(channel...)
	return PubsubShardnumsubChannel(c)
}

// Return Completed Redis command.
func (c PubsubShardnumsub) Build() Completed {
	return completed(c)
}

type PubsubShardnumsubChannel Base

func (c PubsubShardnumsubChannel) Channel(channel ...string) PubsubShardnumsubChannel {
	c.command.append(channel...)
	return c
}

// Return Completed Redis command.
func (c PubsubShardnumsubChannel) Build() Completed {
	return completed(c)
}

// Stop listening for messages posted to channels matching the given patterns.
//
// Time complexity: O(N+M) where N is the number of patterns the client is already subscribed and M is the number of total patterns subscribed in the system (by any client).
type Punsubscribe Base

// Stop listening for messages posted to channels matching the given patterns
//
// Command: PUNSUBSCRIBE.
//
// Time complexity: O(N+M) where N is the number of patterns the client is already subscribed and M is the number of total patterns subscribed in the system (by any client).
func (b Builder) Punsubscribe() Punsubscribe {
	c := Punsubscribe{command: emptyCommand(), cslot: b.slot, ctags: ctagNoRet}
	c.command.append("PUNSUBSCRIBE")
	return c
}

func (c Punsubscribe) Pattern(pattern ...string) PunsubscribePattern {
	c.command.append(pattern...)
	return PunsubscribePattern(c)
}

// Return Completed Redis command.
func (c Punsubscribe) Build() Completed {
	return completed(c)
}

type PunsubscribePattern Base

func (c PunsubscribePattern) Pattern(pattern ...string) PunsubscribePattern {
	c.command.append(pattern...)
	return c
}

// Return Completed Redis command.
func (c PunsubscribePattern) Build() Completed {
	return completed(c)
}

// Close the connection.
type Quit Base

// Close the connection
//
// Command: QUIT.
func (b Builder) Quit() Quit {
	c := Quit{command: emptyCommand(), cslot: b.slot}
	c.command.append("QUIT")
	return c
}

// Return Completed Redis command.
func (c Quit) Build() Completed {
	return completed(c)
}

// Return a random key from the keyspace.
//
// Time complexity: O(1)
type Randomkey Base

// Return a random key from the keyspace
//
// Command: RANDOMKEY.
//
// Time complexity: O(1)
func (b Builder) Randomkey() Randomkey {
	c := Randomkey{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("RANDOMKEY")
	return c
}

// Return Completed Redis command.
func (c Randomkey) Build() Completed {
	return completed(c)
}

// Enables read queries for a connection to a cluster replica node.
//
// Time complexity: O(1)
type Readonly Base

// Enables read queries for a connection to a cluster replica node
//
// Command: READONLY.
//
// Time complexity: O(1)
func (b Builder) Readonly() Readonly {
	c := Readonly{command: emptyCommand(), cslot: b.slot}
	c.command.append("READONLY")
	return c
}

// Return Completed Redis command.
func (c Readonly) Build() Completed {
	return completed(c)
}

// Disables read queries for a connection to a cluster replica node.
//
// Time complexity: O(1)
type Readwrite Base

// Disables read queries for a connection to a cluster replica node
//
// Command: READWRITE.
//
// Time complexity: O(1)
func (b Builder) Readwrite() Readwrite {
	c := Readwrite{command: emptyCommand(), cslot: b.slot}
	c.command.append("READWRITE")
	return c
}

// Return Completed Redis command.
func (c Readwrite) Build() Completed {
	return completed(c)
}

// Rename a key.
//
// Time complexity: O(1)
type Rename Base

// Rename a key
//
// Command: RENAME.
//
// Time complexity: O(1)
func (b Builder) Rename() Rename {
	c := Rename{command: emptyCommand(), cslot: b.slot}
	c.command.append("RENAME")
	return c
}

func (c Rename) Key(key string) RenameKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return RenameKey(c)
}

type RenameKey Base

func (c RenameKey) Newkey(newkey string) RenameNewkey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(newkey)
	} else {
		c.cslot.set(getSlot(newkey))
	}
	c.command.append(newkey)
	return RenameNewkey(c)
}

type RenameNewkey Base

// Return Completed Redis command.
func (c RenameNewkey) Build() Completed {
	return completed(c)
}

// Rename a key, only if the new key does not exist.
//
// Time complexity: O(1)
type Renamenx Base

// Rename a key, only if the new key does not exist
//
// Command: RENAMENX.
//
// Time complexity: O(1)
func (b Builder) Renamenx() Renamenx {
	c := Renamenx{command: emptyCommand(), cslot: b.slot}
	c.command.append("RENAMENX")
	return c
}

func (c Renamenx) Key(key string) RenamenxKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return RenamenxKey(c)
}

type RenamenxKey Base

func (c RenamenxKey) Newkey(newkey string) RenamenxNewkey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(newkey)
	} else {
		c.cslot.set(getSlot(newkey))
	}
	c.command.append(newkey)
	return RenamenxNewkey(c)
}

type RenamenxNewkey Base

// Return Completed Redis command.
func (c RenamenxNewkey) Build() Completed {
	return completed(c)
}

// Make the server a replica of another instance, or promote it as master..
type Replicaof Base

// Make the server a replica of another instance, or promote it as master.
//
// Command: REPLICAOF.
func (b Builder) Replicaof() Replicaof {
	c := Replicaof{command: emptyCommand(), cslot: b.slot}
	c.command.append("REPLICAOF")
	return c
}

func (c Replicaof) Host(host string) ReplicaofHost {
	c.command.append(host)
	return ReplicaofHost(c)
}

type ReplicaofHost Base

func (c ReplicaofHost) Port(port int64) ReplicaofPort {
	c.command.append(strconv.FormatInt(port, 10))
	return ReplicaofPort(c)
}

type ReplicaofPort Base

// Return Completed Redis command.
func (c ReplicaofPort) Build() Completed {
	return completed(c)
}

// Reset the connection.
type Reset Base

// Reset the connection
//
// Command: RESET.
func (b Builder) Reset() Reset {
	c := Reset{command: emptyCommand(), cslot: b.slot}
	c.command.append("RESET")
	return c
}

// Return Completed Redis command.
func (c Reset) Build() Completed {
	return completed(c)
}

// Create a key using the provided serialized value, previously obtained using DUMP..
//
// Time complexity: O(1) to create the new key and additional O(N*M) to reconstruct the serialized value, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1). However for sorted set values the complexity is O(N*M*log(N)) because inserting values into sorted sets is O(log(N)).
type Restore Base

// Create a key using the provided serialized value, previously obtained using DUMP.
//
// Command: RESTORE.
//
// Time complexity: O(1) to create the new key and additional O(N*M) to reconstruct the serialized value, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1). However for sorted set values the complexity is O(N*M*log(N)) because inserting values into sorted sets is O(log(N)).
func (b Builder) Restore() Restore {
	c := Restore{command: emptyCommand(), cslot: b.slot}
	c.command.append("RESTORE")
	return c
}

func (c Restore) Key(key string) RestoreKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return RestoreKey(c)
}

type RestoreAbsttl Base

func (c RestoreAbsttl) Idletime(seconds int64) RestoreIdletime {
	c.command.append("IDLETIME", strconv.FormatInt(seconds, 10))
	return RestoreIdletime(c)
}

func (c RestoreAbsttl) Freq(frequency int64) RestoreFreq {
	c.command.append("FREQ", strconv.FormatInt(frequency, 10))
	return RestoreFreq(c)
}

// Return Completed Redis command.
func (c RestoreAbsttl) Build() Completed {
	return completed(c)
}

type RestoreFreq Base

// Return Completed Redis command.
func (c RestoreFreq) Build() Completed {
	return completed(c)
}

type RestoreIdletime Base

func (c RestoreIdletime) Freq(frequency int64) RestoreFreq {
	c.command.append("FREQ", strconv.FormatInt(frequency, 10))
	return RestoreFreq(c)
}

// Return Completed Redis command.
func (c RestoreIdletime) Build() Completed {
	return completed(c)
}

type RestoreKey Base

func (c RestoreKey) Ttl(ttl int64) RestoreTtl {
	c.command.append(strconv.FormatInt(ttl, 10))
	return RestoreTtl(c)
}

type RestoreReplace Base

func (c RestoreReplace) Absttl() RestoreAbsttl {
	c.command.append("ABSTTL")
	return RestoreAbsttl(c)
}

func (c RestoreReplace) Idletime(seconds int64) RestoreIdletime {
	c.command.append("IDLETIME", strconv.FormatInt(seconds, 10))
	return RestoreIdletime(c)
}

func (c RestoreReplace) Freq(frequency int64) RestoreFreq {
	c.command.append("FREQ", strconv.FormatInt(frequency, 10))
	return RestoreFreq(c)
}

// Return Completed Redis command.
func (c RestoreReplace) Build() Completed {
	return completed(c)
}

type RestoreSerializedValue Base

func (c RestoreSerializedValue) Replace() RestoreReplace {
	c.command.append("REPLACE")
	return RestoreReplace(c)
}

func (c RestoreSerializedValue) Absttl() RestoreAbsttl {
	c.command.append("ABSTTL")
	return RestoreAbsttl(c)
}

func (c RestoreSerializedValue) Idletime(seconds int64) RestoreIdletime {
	c.command.append("IDLETIME", strconv.FormatInt(seconds, 10))
	return RestoreIdletime(c)
}

func (c RestoreSerializedValue) Freq(frequency int64) RestoreFreq {
	c.command.append("FREQ", strconv.FormatInt(frequency, 10))
	return RestoreFreq(c)
}

// Return Completed Redis command.
func (c RestoreSerializedValue) Build() Completed {
	return completed(c)
}

type RestoreTtl Base

func (c RestoreTtl) SerializedValue(serializedValue string) RestoreSerializedValue {
	c.command.append(serializedValue)
	return RestoreSerializedValue(c)
}

// The RG.ABORTEXECUTION command aborts the execution of a function in mid-flight..
//
// Time complexity: O(1)
type RgAbortexecution Base

// The RG.ABORTEXECUTION command aborts the execution of a function in mid-flight.
//
// Command: RG.ABORTEXECUTION.
//
// Time complexity: O(1)
func (b Builder) RgAbortexecution() RgAbortexecution {
	c := RgAbortexecution{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.ABORTEXECUTION")
	return c
}

func (c RgAbortexecution) Id(id string) RgAbortexecutionId {
	c.command.append(id)
	return RgAbortexecutionId(c)
}

type RgAbortexecutionId Base

// Return Completed Redis command.
func (c RgAbortexecutionId) Build() Completed {
	return completed(c)
}

// The RG.CONFIGGET command returns the value of one or more built-in configuration or a user-defined options..
//
// Time complexity: O(1)
type RgConfigget Base

// The RG.CONFIGGET command returns the value of one or more built-in configuration or a user-defined options.
//
// Command: RG.CONFIGGET.
//
// Time complexity: O(1)
func (b Builder) RgConfigget() RgConfigget {
	c := RgConfigget{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.CONFIGGET")
	return c
}

func (c RgConfigget) Key(key ...string) RgConfiggetKey {
	c.command.append(key...)
	return RgConfiggetKey(c)
}

type RgConfiggetKey Base

func (c RgConfiggetKey) Key(key ...string) RgConfiggetKey {
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c RgConfiggetKey) Build() Completed {
	return completed(c)
}

// The RG.CONFIGGET command sets the value of one ore more built-in configuration or a user-defined options..
//
// Time complexity: O(1)
type RgConfigset Base

// The RG.CONFIGGET command sets the value of one ore more built-in configuration or a user-defined options.
//
// Command: RG.CONFIGSET.
//
// Time complexity: O(1)
func (b Builder) RgConfigset() RgConfigset {
	c := RgConfigset{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.CONFIGSET")
	return c
}

func (c RgConfigset) KeyValue() RgConfigsetKeyValue {
	return RgConfigsetKeyValue(c)
}

type RgConfigsetKeyValue Base

func (c RgConfigsetKeyValue) KeyValue(key string, value string) RgConfigsetKeyValue {
	c.command.append(key, value)
	return c
}

// Return Completed Redis command.
func (c RgConfigsetKeyValue) Build() Completed {
	return completed(c)
}

// The RG.DROPEXECUTION command removes the execution of a function from the executions list..
//
// Time complexity: O(1)
type RgDropexecution Base

// The RG.DROPEXECUTION command removes the execution of a function from the executions list.
//
// Command: RG.DROPEXECUTION.
//
// Time complexity: O(1)
func (b Builder) RgDropexecution() RgDropexecution {
	c := RgDropexecution{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.DROPEXECUTION")
	return c
}

func (c RgDropexecution) Id(id string) RgDropexecutionId {
	c.command.append(id)
	return RgDropexecutionId(c)
}

type RgDropexecutionId Base

// Return Completed Redis command.
func (c RgDropexecutionId) Build() Completed {
	return completed(c)
}

// The RG.DUMPEXECUTIONS command outputs the list of function executions. The executions list's length is capped by the MaxExecutions configuration option..
//
// Time complexity: O(n) where n is the number of executions returned
type RgDumpexecutions Base

// The RG.DUMPEXECUTIONS command outputs the list of function executions. The executions list's length is capped by the MaxExecutions configuration option.
//
// Command: RG.DUMPEXECUTIONS.
//
// Time complexity: O(n) where n is the number of executions returned
func (b Builder) RgDumpexecutions() RgDumpexecutions {
	c := RgDumpexecutions{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.DUMPEXECUTIONS")
	return c
}

// Return Completed Redis command.
func (c RgDumpexecutions) Build() Completed {
	return completed(c)
}

// The RG.DUMPREGISTRATIONS command outputs the list of function registrations..
//
// Time complexity: O(n) where n is the number of registrations returned
type RgDumpregistrations Base

// The RG.DUMPREGISTRATIONS command outputs the list of function registrations.
//
// Command: RG.DUMPREGISTRATIONS.
//
// Time complexity: O(n) where n is the number of registrations returned
func (b Builder) RgDumpregistrations() RgDumpregistrations {
	c := RgDumpregistrations{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.DUMPREGISTRATIONS")
	return c
}

// Return Completed Redis command.
func (c RgDumpregistrations) Build() Completed {
	return completed(c)
}

// The RG.GETEXECUTION command returns the execution details of a function that's in the executions list..
//
// Time complexity: O(1)
type RgGetexecution Base

// The RG.GETEXECUTION command returns the execution details of a function that's in the executions list.
//
// Command: RG.GETEXECUTION.
//
// Time complexity: O(1)
func (b Builder) RgGetexecution() RgGetexecution {
	c := RgGetexecution{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.GETEXECUTION")
	return c
}

func (c RgGetexecution) Id(id string) RgGetexecutionId {
	c.command.append(id)
	return RgGetexecutionId(c)
}

type RgGetexecutionId Base

func (c RgGetexecutionId) Shard() RgGetexecutionModeShard {
	c.command.append("SHARD")
	return RgGetexecutionModeShard(c)
}

func (c RgGetexecutionId) Cluster() RgGetexecutionModeCluster {
	c.command.append("CLUSTER")
	return RgGetexecutionModeCluster(c)
}

// Return Completed Redis command.
func (c RgGetexecutionId) Build() Completed {
	return completed(c)
}

type RgGetexecutionModeCluster Base

// Return Completed Redis command.
func (c RgGetexecutionModeCluster) Build() Completed {
	return completed(c)
}

type RgGetexecutionModeShard Base

// Return Completed Redis command.
func (c RgGetexecutionModeShard) Build() Completed {
	return completed(c)
}

// The RG.GETRESULTS command returns the results and errors from of the execution execution details of a function that's in the executions list..
//
// Time complexity: O(1)
type RgGetresults Base

// The RG.GETRESULTS command returns the results and errors from of the execution execution details of a function that's in the executions list.
//
// Command: RG.GETRESULTS.
//
// Time complexity: O(1)
func (b Builder) RgGetresults() RgGetresults {
	c := RgGetresults{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.GETRESULTS")
	return c
}

func (c RgGetresults) Id(id string) RgGetresultsId {
	c.command.append(id)
	return RgGetresultsId(c)
}

type RgGetresultsId Base

// Return Completed Redis command.
func (c RgGetresultsId) Build() Completed {
	return completed(c)
}

// The RG.GETRESULTSBLOCKING command cancels the UNBLOCKING argument of the RG.PYEXECUTE command. The calling client is blocked until execution ends and is sent with any results and errors then..
//
// Time complexity: O(1)
type RgGetresultsblocking Base

// The RG.GETRESULTSBLOCKING command cancels the UNBLOCKING argument of the RG.PYEXECUTE command. The calling client is blocked until execution ends and is sent with any results and errors then.
//
// Command: RG.GETRESULTSBLOCKING.
//
// Time complexity: O(1)
func (b Builder) RgGetresultsblocking() RgGetresultsblocking {
	c := RgGetresultsblocking{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.GETRESULTSBLOCKING")
	return c
}

func (c RgGetresultsblocking) Id(id string) RgGetresultsblockingId {
	c.command.append(id)
	return RgGetresultsblockingId(c)
}

type RgGetresultsblockingId Base

// Return Completed Redis command.
func (c RgGetresultsblockingId) Build() Completed {
	return completed(c)
}

// The RG.INFOCLUSTER command outputs information about the cluster..
//
// Time complexity: O(1)
type RgInfocluster Base

// The RG.INFOCLUSTER command outputs information about the cluster.
//
// Command: RG.INFOCLUSTER.
//
// Time complexity: O(1)
func (b Builder) RgInfocluster() RgInfocluster {
	c := RgInfocluster{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.INFOCLUSTER")
	return c
}

// Return Completed Redis command.
func (c RgInfocluster) Build() Completed {
	return completed(c)
}

// The RG.PYDUMPREQS command returns a list of all the python requirements available (with information about each requirement)..
//
// Time complexity: O(n) when n is the number of requirements
type RgPydumpreqs Base

// The RG.PYDUMPREQS command returns a list of all the python requirements available (with information about each requirement).
//
// Command: RG.PYDUMPREQS.
//
// Time complexity: O(n) when n is the number of requirements
func (b Builder) RgPydumpreqs() RgPydumpreqs {
	c := RgPydumpreqs{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.PYDUMPREQS")
	return c
}

// Return Completed Redis command.
func (c RgPydumpreqs) Build() Completed {
	return completed(c)
}

// The RG.PYEXECUTE command executes a Python function..
//
// Time complexity: Depends on what the python code does
type RgPyexecute Base

// The RG.PYEXECUTE command executes a Python function.
//
// Command: RG.PYEXECUTE.
//
// Time complexity: Depends on what the python code does
func (b Builder) RgPyexecute() RgPyexecute {
	c := RgPyexecute{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.PYEXECUTE")
	return c
}

func (c RgPyexecute) Function(function string) RgPyexecuteFunction {
	c.command.append(function)
	return RgPyexecuteFunction(c)
}

type RgPyexecuteDescription Base

func (c RgPyexecuteDescription) Upgrade() RgPyexecuteUpgrade {
	c.command.append("UPGRADE")
	return RgPyexecuteUpgrade(c)
}

func (c RgPyexecuteDescription) ReplaceWith(replaceWith string) RgPyexecuteReplaceWith {
	c.command.append("REPLACE_WITH", replaceWith)
	return RgPyexecuteReplaceWith(c)
}

func (c RgPyexecuteDescription) Requirements(requirement ...string) RgPyexecuteRequirementsRequirements {
	c.command.append("REQUIREMENTS")
	c.command.append(requirement...)
	return RgPyexecuteRequirementsRequirements(c)
}

// Return Completed Redis command.
func (c RgPyexecuteDescription) Build() Completed {
	return completed(c)
}

type RgPyexecuteFunction Base

func (c RgPyexecuteFunction) Unblocking() RgPyexecuteUnblocking {
	c.command.append("UNBLOCKING")
	return RgPyexecuteUnblocking(c)
}

func (c RgPyexecuteFunction) Id(id string) RgPyexecuteId {
	c.command.append("ID", id)
	return RgPyexecuteId(c)
}

func (c RgPyexecuteFunction) Description(description string) RgPyexecuteDescription {
	c.command.append("DESCRIPTION", description)
	return RgPyexecuteDescription(c)
}

func (c RgPyexecuteFunction) Upgrade() RgPyexecuteUpgrade {
	c.command.append("UPGRADE")
	return RgPyexecuteUpgrade(c)
}

func (c RgPyexecuteFunction) ReplaceWith(replaceWith string) RgPyexecuteReplaceWith {
	c.command.append("REPLACE_WITH", replaceWith)
	return RgPyexecuteReplaceWith(c)
}

func (c RgPyexecuteFunction) Requirements(requirement ...string) RgPyexecuteRequirementsRequirements {
	c.command.append("REQUIREMENTS")
	c.command.append(requirement...)
	return RgPyexecuteRequirementsRequirements(c)
}

// Return Completed Redis command.
func (c RgPyexecuteFunction) Build() Completed {
	return completed(c)
}

type RgPyexecuteId Base

func (c RgPyexecuteId) Description(description string) RgPyexecuteDescription {
	c.command.append("DESCRIPTION", description)
	return RgPyexecuteDescription(c)
}

func (c RgPyexecuteId) Upgrade() RgPyexecuteUpgrade {
	c.command.append("UPGRADE")
	return RgPyexecuteUpgrade(c)
}

func (c RgPyexecuteId) ReplaceWith(replaceWith string) RgPyexecuteReplaceWith {
	c.command.append("REPLACE_WITH", replaceWith)
	return RgPyexecuteReplaceWith(c)
}

func (c RgPyexecuteId) Requirements(requirement ...string) RgPyexecuteRequirementsRequirements {
	c.command.append("REQUIREMENTS")
	c.command.append(requirement...)
	return RgPyexecuteRequirementsRequirements(c)
}

// Return Completed Redis command.
func (c RgPyexecuteId) Build() Completed {
	return completed(c)
}

type RgPyexecuteReplaceWith Base

func (c RgPyexecuteReplaceWith) Requirements(requirement ...string) RgPyexecuteRequirementsRequirements {
	c.command.append("REQUIREMENTS")
	c.command.append(requirement...)
	return RgPyexecuteRequirementsRequirements(c)
}

// Return Completed Redis command.
func (c RgPyexecuteReplaceWith) Build() Completed {
	return completed(c)
}

type RgPyexecuteRequirementsRequirements Base

func (c RgPyexecuteRequirementsRequirements) Requirements(requirement ...string) RgPyexecuteRequirementsRequirements {
	c.command.append("REQUIREMENTS")
	c.command.append(requirement...)
	return c
}

// Return Completed Redis command.
func (c RgPyexecuteRequirementsRequirements) Build() Completed {
	return completed(c)
}

type RgPyexecuteUnblocking Base

func (c RgPyexecuteUnblocking) Id(id string) RgPyexecuteId {
	c.command.append("ID", id)
	return RgPyexecuteId(c)
}

func (c RgPyexecuteUnblocking) Description(description string) RgPyexecuteDescription {
	c.command.append("DESCRIPTION", description)
	return RgPyexecuteDescription(c)
}

func (c RgPyexecuteUnblocking) Upgrade() RgPyexecuteUpgrade {
	c.command.append("UPGRADE")
	return RgPyexecuteUpgrade(c)
}

func (c RgPyexecuteUnblocking) ReplaceWith(replaceWith string) RgPyexecuteReplaceWith {
	c.command.append("REPLACE_WITH", replaceWith)
	return RgPyexecuteReplaceWith(c)
}

func (c RgPyexecuteUnblocking) Requirements(requirement ...string) RgPyexecuteRequirementsRequirements {
	c.command.append("REQUIREMENTS")
	c.command.append(requirement...)
	return RgPyexecuteRequirementsRequirements(c)
}

// Return Completed Redis command.
func (c RgPyexecuteUnblocking) Build() Completed {
	return completed(c)
}

type RgPyexecuteUpgrade Base

func (c RgPyexecuteUpgrade) ReplaceWith(replaceWith string) RgPyexecuteReplaceWith {
	c.command.append("REPLACE_WITH", replaceWith)
	return RgPyexecuteReplaceWith(c)
}

func (c RgPyexecuteUpgrade) Requirements(requirement ...string) RgPyexecuteRequirementsRequirements {
	c.command.append("REQUIREMENTS")
	c.command.append(requirement...)
	return RgPyexecuteRequirementsRequirements(c)
}

// Return Completed Redis command.
func (c RgPyexecuteUpgrade) Build() Completed {
	return completed(c)
}

// The RG.PYSTATS command returns memory usage statistics from the Python interpreter..
//
// Time complexity: O(1)
type RgPystats Base

// The RG.PYSTATS command returns memory usage statistics from the Python interpreter.
//
// Command: RG.PYSTATS.
//
// Time complexity: O(1)
func (b Builder) RgPystats() RgPystats {
	c := RgPystats{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.PYSTATS")
	return c
}

// Return Completed Redis command.
func (c RgPystats) Build() Completed {
	return completed(c)
}

// The RG.REFRESHCLUSTER command refreshes the node's view of the cluster's topology..
//
// Time complexity: O(1)
type RgRefreshcluster Base

// The RG.REFRESHCLUSTER command refreshes the node's view of the cluster's topology.
//
// Command: RG.REFRESHCLUSTER.
//
// Time complexity: O(1)
func (b Builder) RgRefreshcluster() RgRefreshcluster {
	c := RgRefreshcluster{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.REFRESHCLUSTER")
	return c
}

// Return Completed Redis command.
func (c RgRefreshcluster) Build() Completed {
	return completed(c)
}

// The RG.TRIGGER command triggers the execution of a registered CommandReader function..
//
// Time complexity: Depends on the function triggered
type RgTrigger Base

// The RG.TRIGGER command triggers the execution of a registered CommandReader function.
//
// Command: RG.TRIGGER.
//
// Time complexity: Depends on the function triggered
func (b Builder) RgTrigger() RgTrigger {
	c := RgTrigger{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.TRIGGER")
	return c
}

func (c RgTrigger) Trigger(trigger string) RgTriggerTrigger {
	c.command.append(trigger)
	return RgTriggerTrigger(c)
}

type RgTriggerArgument Base

func (c RgTriggerArgument) Argument(argument ...string) RgTriggerArgument {
	c.command.append(argument...)
	return c
}

// Return Completed Redis command.
func (c RgTriggerArgument) Build() Completed {
	return completed(c)
}

type RgTriggerTrigger Base

func (c RgTriggerTrigger) Argument(argument ...string) RgTriggerArgument {
	c.command.append(argument...)
	return RgTriggerArgument(c)
}

// The RG.UNREGISTER command removes the registration of a function..
//
// Time complexity: O(1)
type RgUnregister Base

// The RG.UNREGISTER command removes the registration of a function.
//
// Command: RG.UNREGISTER.
//
// Time complexity: O(1)
func (b Builder) RgUnregister() RgUnregister {
	c := RgUnregister{command: emptyCommand(), cslot: b.slot}
	c.command.append("RG.UNREGISTER")
	return c
}

func (c RgUnregister) Id(id string) RgUnregisterId {
	c.command.append(id)
	return RgUnregisterId(c)
}

type RgUnregisterId Base

// Return Completed Redis command.
func (c RgUnregisterId) Build() Completed {
	return completed(c)
}

// Return the role of the instance in the context of replication.
type Role Base

// Return the role of the instance in the context of replication
//
// Command: ROLE.
func (b Builder) Role() Role {
	c := Role{command: emptyCommand(), cslot: b.slot}
	c.command.append("ROLE")
	return c
}

// Return Completed Redis command.
func (c Role) Build() Completed {
	return completed(c)
}

// Remove and get the last elements in a list.
//
// Time complexity: O(N) where N is the number of elements returned
type Rpop Base

// Remove and get the last elements in a list
//
// Command: RPOP.
//
// Time complexity: O(N) where N is the number of elements returned
func (b Builder) Rpop() Rpop {
	c := Rpop{command: emptyCommand(), cslot: b.slot}
	c.command.append("RPOP")
	return c
}

func (c Rpop) Key(key string) RpopKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return RpopKey(c)
}

type RpopCount Base

// Return Completed Redis command.
func (c RpopCount) Build() Completed {
	return completed(c)
}

type RpopKey Base

func (c RpopKey) Count(count int64) RpopCount {
	c.command.append(strconv.FormatInt(count, 10))
	return RpopCount(c)
}

// Return Completed Redis command.
func (c RpopKey) Build() Completed {
	return completed(c)
}

// Remove the last element in a list, prepend it to another list and return it.
//
// Time complexity: O(1)
type Rpoplpush Base

// Remove the last element in a list, prepend it to another list and return it
//
// Command: RPOPLPUSH.
//
// Time complexity: O(1)
func (b Builder) Rpoplpush() Rpoplpush {
	c := Rpoplpush{command: emptyCommand(), cslot: b.slot}
	c.command.append("RPOPLPUSH")
	return c
}

func (c Rpoplpush) Source(source string) RpoplpushSource {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(source)
	} else {
		c.cslot.set(getSlot(source))
	}
	c.command.append(source)
	return RpoplpushSource(c)
}

type RpoplpushDestination Base

// Return Completed Redis command.
func (c RpoplpushDestination) Build() Completed {
	return completed(c)
}

type RpoplpushSource Base

func (c RpoplpushSource) Destination(destination string) RpoplpushDestination {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append(destination)
	return RpoplpushDestination(c)
}

// Append one or multiple elements to a list.
//
// Time complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.
type Rpush Base

// Append one or multiple elements to a list
//
// Command: RPUSH.
//
// Time complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.
func (b Builder) Rpush() Rpush {
	c := Rpush{command: emptyCommand(), cslot: b.slot}
	c.command.append("RPUSH")
	return c
}

func (c Rpush) Key(key string) RpushKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return RpushKey(c)
}

type RpushElement Base

func (c RpushElement) Element(element ...string) RpushElement {
	c.command.append(element...)
	return c
}

// Return Completed Redis command.
func (c RpushElement) Build() Completed {
	return completed(c)
}

type RpushKey Base

func (c RpushKey) Element(element ...string) RpushElement {
	c.command.append(element...)
	return RpushElement(c)
}

// Append an element to a list, only if the list exists.
//
// Time complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.
type Rpushx Base

// Append an element to a list, only if the list exists
//
// Command: RPUSHX.
//
// Time complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.
func (b Builder) Rpushx() Rpushx {
	c := Rpushx{command: emptyCommand(), cslot: b.slot}
	c.command.append("RPUSHX")
	return c
}

func (c Rpushx) Key(key string) RpushxKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return RpushxKey(c)
}

type RpushxElement Base

func (c RpushxElement) Element(element ...string) RpushxElement {
	c.command.append(element...)
	return c
}

// Return Completed Redis command.
func (c RpushxElement) Build() Completed {
	return completed(c)
}

type RpushxKey Base

func (c RpushxKey) Element(element ...string) RpushxElement {
	c.command.append(element...)
	return RpushxElement(c)
}

// Add one or more members to a set.
//
// Time complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.
type Sadd Base

// Add one or more members to a set
//
// Command: SADD.
//
// Time complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.
func (b Builder) Sadd() Sadd {
	c := Sadd{command: emptyCommand(), cslot: b.slot}
	c.command.append("SADD")
	return c
}

func (c Sadd) Key(key string) SaddKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return SaddKey(c)
}

type SaddKey Base

func (c SaddKey) Member(member ...string) SaddMember {
	c.command.append(member...)
	return SaddMember(c)
}

type SaddMember Base

func (c SaddMember) Member(member ...string) SaddMember {
	c.command.append(member...)
	return c
}

// Return Completed Redis command.
func (c SaddMember) Build() Completed {
	return completed(c)
}

// Synchronously save the dataset to disk.
type Save Base

// Synchronously save the dataset to disk
//
// Command: SAVE.
func (b Builder) Save() Save {
	c := Save{command: emptyCommand(), cslot: b.slot}
	c.command.append("SAVE")
	return c
}

// Return Completed Redis command.
func (c Save) Build() Completed {
	return completed(c)
}

// Incrementally iterate the keys space.
//
// Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection.
type Scan Base

// Incrementally iterate the keys space
//
// Command: SCAN.
//
// Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection.
func (b Builder) Scan() Scan {
	c := Scan{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("SCAN")
	return c
}

func (c Scan) Cursor(cursor int64) ScanCursor {
	c.command.append(strconv.FormatInt(cursor, 10))
	return ScanCursor(c)
}

type ScanCount Base

func (c ScanCount) Type(typ string) ScanType {
	c.command.append("TYPE", typ)
	return ScanType(c)
}

// Return Completed Redis command.
func (c ScanCount) Build() Completed {
	return completed(c)
}

type ScanCursor Base

func (c ScanCursor) Match(pattern string) ScanMatch {
	c.command.append("MATCH", pattern)
	return ScanMatch(c)
}

func (c ScanCursor) Count(count int64) ScanCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return ScanCount(c)
}

func (c ScanCursor) Type(typ string) ScanType {
	c.command.append("TYPE", typ)
	return ScanType(c)
}

// Return Completed Redis command.
func (c ScanCursor) Build() Completed {
	return completed(c)
}

type ScanMatch Base

func (c ScanMatch) Count(count int64) ScanCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return ScanCount(c)
}

func (c ScanMatch) Type(typ string) ScanType {
	c.command.append("TYPE", typ)
	return ScanType(c)
}

// Return Completed Redis command.
func (c ScanMatch) Build() Completed {
	return completed(c)
}

type ScanType Base

// Return Completed Redis command.
func (c ScanType) Build() Completed {
	return completed(c)
}

// Get the number of members in a set.
//
// Time complexity: O(1)
type Scard Base

// Get the number of members in a set
//
// Command: SCARD.
//
// Time complexity: O(1)
func (b Builder) Scard() Scard {
	c := Scard{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("SCARD")
	return c
}

func (c Scard) Key(key string) ScardKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ScardKey(c)
}

type ScardKey Base

// Return Completed Redis command.
func (c ScardKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ScardKey) Cache() Cacheable {
	return cacheable(c)
}

// Set the debug mode for executed scripts..
//
// Time complexity: O(1)
type ScriptDebug Base

// Set the debug mode for executed scripts.
//
// Command: SCRIPT DEBUG.
//
// Time complexity: O(1)
func (b Builder) ScriptDebug() ScriptDebug {
	c := ScriptDebug{command: emptyCommand(), cslot: b.slot}
	c.command.append("SCRIPT", "DEBUG")
	return c
}

func (c ScriptDebug) Yes() ScriptDebugModeYes {
	c.command.append("YES")
	return ScriptDebugModeYes(c)
}

func (c ScriptDebug) Sync() ScriptDebugModeSync {
	c.command.append("SYNC")
	return ScriptDebugModeSync(c)
}

func (c ScriptDebug) No() ScriptDebugModeNo {
	c.command.append("NO")
	return ScriptDebugModeNo(c)
}

type ScriptDebugModeNo Base

// Return Completed Redis command.
func (c ScriptDebugModeNo) Build() Completed {
	return completed(c)
}

type ScriptDebugModeSync Base

// Return Completed Redis command.
func (c ScriptDebugModeSync) Build() Completed {
	return completed(c)
}

type ScriptDebugModeYes Base

// Return Completed Redis command.
func (c ScriptDebugModeYes) Build() Completed {
	return completed(c)
}

// Check existence of scripts in the script cache..
//
// Time complexity: O(N) with N being the number of scripts to check (so checking a single script is an O(1) operation).
type ScriptExists Base

// Check existence of scripts in the script cache.
//
// Command: SCRIPT EXISTS.
//
// Time complexity: O(N) with N being the number of scripts to check (so checking a single script is an O(1) operation).
func (b Builder) ScriptExists() ScriptExists {
	c := ScriptExists{command: emptyCommand(), cslot: b.slot}
	c.command.append("SCRIPT", "EXISTS")
	return c
}

func (c ScriptExists) Sha1(sha1 ...string) ScriptExistsSha1 {
	c.command.append(sha1...)
	return ScriptExistsSha1(c)
}

type ScriptExistsSha1 Base

func (c ScriptExistsSha1) Sha1(sha1 ...string) ScriptExistsSha1 {
	c.command.append(sha1...)
	return c
}

// Return Completed Redis command.
func (c ScriptExistsSha1) Build() Completed {
	return completed(c)
}

// Remove all the scripts from the script cache..
//
// Time complexity: O(N) with N being the number of scripts in cache
type ScriptFlush Base

// Remove all the scripts from the script cache.
//
// Command: SCRIPT FLUSH.
//
// Time complexity: O(N) with N being the number of scripts in cache
func (b Builder) ScriptFlush() ScriptFlush {
	c := ScriptFlush{command: emptyCommand(), cslot: b.slot}
	c.command.append("SCRIPT", "FLUSH")
	return c
}

func (c ScriptFlush) Async() ScriptFlushAsync {
	c.command.append("ASYNC")
	return ScriptFlushAsync(c)
}

func (c ScriptFlush) Sync() ScriptFlushAsyncSync {
	c.command.append("SYNC")
	return ScriptFlushAsyncSync(c)
}

// Return Completed Redis command.
func (c ScriptFlush) Build() Completed {
	return completed(c)
}

type ScriptFlushAsync Base

// Return Completed Redis command.
func (c ScriptFlushAsync) Build() Completed {
	return completed(c)
}

type ScriptFlushAsyncSync Base

// Return Completed Redis command.
func (c ScriptFlushAsyncSync) Build() Completed {
	return completed(c)
}

// Kill the script currently in execution..
//
// Time complexity: O(1)
type ScriptKill Base

// Kill the script currently in execution.
//
// Command: SCRIPT KILL.
//
// Time complexity: O(1)
func (b Builder) ScriptKill() ScriptKill {
	c := ScriptKill{command: emptyCommand(), cslot: b.slot}
	c.command.append("SCRIPT", "KILL")
	return c
}

// Return Completed Redis command.
func (c ScriptKill) Build() Completed {
	return completed(c)
}

// Load the specified Lua script into the script cache..
//
// Time complexity: O(N) with N being the length in bytes of the script body.
type ScriptLoad Base

// Load the specified Lua script into the script cache.
//
// Command: SCRIPT LOAD.
//
// Time complexity: O(N) with N being the length in bytes of the script body.
func (b Builder) ScriptLoad() ScriptLoad {
	c := ScriptLoad{command: emptyCommand(), cslot: b.slot}
	c.command.append("SCRIPT", "LOAD")
	return c
}

func (c ScriptLoad) Script(script string) ScriptLoadScript {
	c.command.append(script)
	return ScriptLoadScript(c)
}

type ScriptLoadScript Base

// Return Completed Redis command.
func (c ScriptLoadScript) Build() Completed {
	return completed(c)
}

// Subtract multiple sets.
//
// Time complexity: O(N) where N is the total number of elements in all given sets.
type Sdiff Base

// Subtract multiple sets
//
// Command: SDIFF.
//
// Time complexity: O(N) where N is the total number of elements in all given sets.
func (b Builder) Sdiff() Sdiff {
	c := Sdiff{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("SDIFF")
	return c
}

func (c Sdiff) Key(key ...string) SdiffKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return SdiffKey(c)
}

type SdiffKey Base

func (c SdiffKey) Key(key ...string) SdiffKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c SdiffKey) Build() Completed {
	return completed(c)
}

// Subtract multiple sets and store the resulting set in a key.
//
// Time complexity: O(N) where N is the total number of elements in all given sets.
type Sdiffstore Base

// Subtract multiple sets and store the resulting set in a key
//
// Command: SDIFFSTORE.
//
// Time complexity: O(N) where N is the total number of elements in all given sets.
func (b Builder) Sdiffstore() Sdiffstore {
	c := Sdiffstore{command: emptyCommand(), cslot: b.slot}
	c.command.append("SDIFFSTORE")
	return c
}

func (c Sdiffstore) Destination(destination string) SdiffstoreDestination {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append(destination)
	return SdiffstoreDestination(c)
}

type SdiffstoreDestination Base

func (c SdiffstoreDestination) Key(key ...string) SdiffstoreKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return SdiffstoreKey(c)
}

type SdiffstoreKey Base

func (c SdiffstoreKey) Key(key ...string) SdiffstoreKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c SdiffstoreKey) Build() Completed {
	return completed(c)
}

// Change the selected database for the current connection.
type Select Base

// Change the selected database for the current connection
//
// Command: SELECT.
func (b Builder) Select() Select {
	c := Select{command: emptyCommand(), cslot: b.slot}
	c.command.append("SELECT")
	return c
}

func (c Select) Index(index int64) SelectIndex {
	c.command.append(strconv.FormatInt(index, 10))
	return SelectIndex(c)
}

type SelectIndex Base

// Return Completed Redis command.
func (c SelectIndex) Build() Completed {
	return completed(c)
}

type SentinelFailover Base

// Command: SENTINEL FAILOVER.
func (b Builder) SentinelFailover() SentinelFailover {
	c := SentinelFailover{command: emptyCommand(), cslot: b.slot}
	c.command.append("SENTINEL", "FAILOVER")
	return c
}

func (c SentinelFailover) Master(master string) SentinelFailoverMaster {
	c.command.append(master)
	return SentinelFailoverMaster(c)
}

type SentinelFailoverMaster Base

// Return Completed Redis command.
func (c SentinelFailoverMaster) Build() Completed {
	return completed(c)
}

type SentinelGetMasterAddrByName Base

// Command: SENTINEL GET-MASTER-ADDR-BY-NAME.
func (b Builder) SentinelGetMasterAddrByName() SentinelGetMasterAddrByName {
	c := SentinelGetMasterAddrByName{command: emptyCommand(), cslot: b.slot}
	c.command.append("SENTINEL", "GET-MASTER-ADDR-BY-NAME")
	return c
}

func (c SentinelGetMasterAddrByName) Master(master string) SentinelGetMasterAddrByNameMaster {
	c.command.append(master)
	return SentinelGetMasterAddrByNameMaster(c)
}

type SentinelGetMasterAddrByNameMaster Base

// Return Completed Redis command.
func (c SentinelGetMasterAddrByNameMaster) Build() Completed {
	return completed(c)
}

type SentinelSentinels Base

// Command: SENTINEL SENTINELS.
func (b Builder) SentinelSentinels() SentinelSentinels {
	c := SentinelSentinels{command: emptyCommand(), cslot: b.slot}
	c.command.append("SENTINEL", "SENTINELS")
	return c
}

func (c SentinelSentinels) Master(master string) SentinelSentinelsMaster {
	c.command.append(master)
	return SentinelSentinelsMaster(c)
}

type SentinelSentinelsMaster Base

// Return Completed Redis command.
func (c SentinelSentinelsMaster) Build() Completed {
	return completed(c)
}

// Set the string value of a key.
//
// Time complexity: O(1)
type Set Base

// Set the string value of a key
//
// Command: SET.
//
// Time complexity: O(1)
func (b Builder) Set() Set {
	c := Set{command: emptyCommand(), cslot: b.slot}
	c.command.append("SET")
	return c
}

func (c Set) Key(key string) SetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return SetKey(c)
}

type SetConditionNx Base

func (c SetConditionNx) Get() SetGet {
	c.command.append("GET")
	return SetGet(c)
}

func (c SetConditionNx) ExSeconds(seconds int64) SetExpirationExSeconds {
	c.command.append("EX", strconv.FormatInt(seconds, 10))
	return SetExpirationExSeconds(c)
}

func (c SetConditionNx) PxMilliseconds(milliseconds int64) SetExpirationPxMilliseconds {
	c.command.append("PX", strconv.FormatInt(milliseconds, 10))
	return SetExpirationPxMilliseconds(c)
}

func (c SetConditionNx) ExatTimestamp(timestamp int64) SetExpirationExatTimestamp {
	c.command.append("EXAT", strconv.FormatInt(timestamp, 10))
	return SetExpirationExatTimestamp(c)
}

func (c SetConditionNx) PxatMillisecondsTimestamp(millisecondsTimestamp int64) SetExpirationPxatMillisecondsTimestamp {
	c.command.append("PXAT", strconv.FormatInt(millisecondsTimestamp, 10))
	return SetExpirationPxatMillisecondsTimestamp(c)
}

func (c SetConditionNx) Keepttl() SetExpirationKeepttl {
	c.command.append("KEEPTTL")
	return SetExpirationKeepttl(c)
}

// Return Completed Redis command.
func (c SetConditionNx) Build() Completed {
	return completed(c)
}

type SetConditionXx Base

func (c SetConditionXx) Get() SetGet {
	c.command.append("GET")
	return SetGet(c)
}

func (c SetConditionXx) ExSeconds(seconds int64) SetExpirationExSeconds {
	c.command.append("EX", strconv.FormatInt(seconds, 10))
	return SetExpirationExSeconds(c)
}

func (c SetConditionXx) PxMilliseconds(milliseconds int64) SetExpirationPxMilliseconds {
	c.command.append("PX", strconv.FormatInt(milliseconds, 10))
	return SetExpirationPxMilliseconds(c)
}

func (c SetConditionXx) ExatTimestamp(timestamp int64) SetExpirationExatTimestamp {
	c.command.append("EXAT", strconv.FormatInt(timestamp, 10))
	return SetExpirationExatTimestamp(c)
}

func (c SetConditionXx) PxatMillisecondsTimestamp(millisecondsTimestamp int64) SetExpirationPxatMillisecondsTimestamp {
	c.command.append("PXAT", strconv.FormatInt(millisecondsTimestamp, 10))
	return SetExpirationPxatMillisecondsTimestamp(c)
}

func (c SetConditionXx) Keepttl() SetExpirationKeepttl {
	c.command.append("KEEPTTL")
	return SetExpirationKeepttl(c)
}

// Return Completed Redis command.
func (c SetConditionXx) Build() Completed {
	return completed(c)
}

type SetExpirationExSeconds Base

// Return Completed Redis command.
func (c SetExpirationExSeconds) Build() Completed {
	return completed(c)
}

type SetExpirationExatTimestamp Base

// Return Completed Redis command.
func (c SetExpirationExatTimestamp) Build() Completed {
	return completed(c)
}

type SetExpirationKeepttl Base

// Return Completed Redis command.
func (c SetExpirationKeepttl) Build() Completed {
	return completed(c)
}

type SetExpirationPxMilliseconds Base

// Return Completed Redis command.
func (c SetExpirationPxMilliseconds) Build() Completed {
	return completed(c)
}

type SetExpirationPxatMillisecondsTimestamp Base

// Return Completed Redis command.
func (c SetExpirationPxatMillisecondsTimestamp) Build() Completed {
	return completed(c)
}

type SetGet Base

func (c SetGet) ExSeconds(seconds int64) SetExpirationExSeconds {
	c.command.append("EX", strconv.FormatInt(seconds, 10))
	return SetExpirationExSeconds(c)
}

func (c SetGet) PxMilliseconds(milliseconds int64) SetExpirationPxMilliseconds {
	c.command.append("PX", strconv.FormatInt(milliseconds, 10))
	return SetExpirationPxMilliseconds(c)
}

func (c SetGet) ExatTimestamp(timestamp int64) SetExpirationExatTimestamp {
	c.command.append("EXAT", strconv.FormatInt(timestamp, 10))
	return SetExpirationExatTimestamp(c)
}

func (c SetGet) PxatMillisecondsTimestamp(millisecondsTimestamp int64) SetExpirationPxatMillisecondsTimestamp {
	c.command.append("PXAT", strconv.FormatInt(millisecondsTimestamp, 10))
	return SetExpirationPxatMillisecondsTimestamp(c)
}

func (c SetGet) Keepttl() SetExpirationKeepttl {
	c.command.append("KEEPTTL")
	return SetExpirationKeepttl(c)
}

// Return Completed Redis command.
func (c SetGet) Build() Completed {
	return completed(c)
}

type SetKey Base

func (c SetKey) Value(value string) SetValue {
	c.command.append(value)
	return SetValue(c)
}

type SetValue Base

func (c SetValue) Nx() SetConditionNx {
	c.command.append("NX")
	return SetConditionNx(c)
}

func (c SetValue) Xx() SetConditionXx {
	c.command.append("XX")
	return SetConditionXx(c)
}

func (c SetValue) Get() SetGet {
	c.command.append("GET")
	return SetGet(c)
}

func (c SetValue) ExSeconds(seconds int64) SetExpirationExSeconds {
	c.command.append("EX", strconv.FormatInt(seconds, 10))
	return SetExpirationExSeconds(c)
}

func (c SetValue) PxMilliseconds(milliseconds int64) SetExpirationPxMilliseconds {
	c.command.append("PX", strconv.FormatInt(milliseconds, 10))
	return SetExpirationPxMilliseconds(c)
}

func (c SetValue) ExatTimestamp(timestamp int64) SetExpirationExatTimestamp {
	c.command.append("EXAT", strconv.FormatInt(timestamp, 10))
	return SetExpirationExatTimestamp(c)
}

func (c SetValue) PxatMillisecondsTimestamp(millisecondsTimestamp int64) SetExpirationPxatMillisecondsTimestamp {
	c.command.append("PXAT", strconv.FormatInt(millisecondsTimestamp, 10))
	return SetExpirationPxatMillisecondsTimestamp(c)
}

func (c SetValue) Keepttl() SetExpirationKeepttl {
	c.command.append("KEEPTTL")
	return SetExpirationKeepttl(c)
}

// Return Completed Redis command.
func (c SetValue) Build() Completed {
	return completed(c)
}

// Sets or clears the bit at offset in the string value stored at key.
//
// Time complexity: O(1)
type Setbit Base

// Sets or clears the bit at offset in the string value stored at key
//
// Command: SETBIT.
//
// Time complexity: O(1)
func (b Builder) Setbit() Setbit {
	c := Setbit{command: emptyCommand(), cslot: b.slot}
	c.command.append("SETBIT")
	return c
}

func (c Setbit) Key(key string) SetbitKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return SetbitKey(c)
}

type SetbitKey Base

func (c SetbitKey) Offset(offset int64) SetbitOffset {
	c.command.append(strconv.FormatInt(offset, 10))
	return SetbitOffset(c)
}

type SetbitOffset Base

func (c SetbitOffset) Value(value int64) SetbitValue {
	c.command.append(strconv.FormatInt(value, 10))
	return SetbitValue(c)
}

type SetbitValue Base

// Return Completed Redis command.
func (c SetbitValue) Build() Completed {
	return completed(c)
}

// Set the value and expiration of a key.
//
// Time complexity: O(1)
type Setex Base

// Set the value and expiration of a key
//
// Command: SETEX.
//
// Time complexity: O(1)
func (b Builder) Setex() Setex {
	c := Setex{command: emptyCommand(), cslot: b.slot}
	c.command.append("SETEX")
	return c
}

func (c Setex) Key(key string) SetexKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return SetexKey(c)
}

type SetexKey Base

func (c SetexKey) Seconds(seconds int64) SetexSeconds {
	c.command.append(strconv.FormatInt(seconds, 10))
	return SetexSeconds(c)
}

type SetexSeconds Base

func (c SetexSeconds) Value(value string) SetexValue {
	c.command.append(value)
	return SetexValue(c)
}

type SetexValue Base

// Return Completed Redis command.
func (c SetexValue) Build() Completed {
	return completed(c)
}

// Set the value of a key, only if the key does not exist.
//
// Time complexity: O(1)
type Setnx Base

// Set the value of a key, only if the key does not exist
//
// Command: SETNX.
//
// Time complexity: O(1)
func (b Builder) Setnx() Setnx {
	c := Setnx{command: emptyCommand(), cslot: b.slot}
	c.command.append("SETNX")
	return c
}

func (c Setnx) Key(key string) SetnxKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return SetnxKey(c)
}

type SetnxKey Base

func (c SetnxKey) Value(value string) SetnxValue {
	c.command.append(value)
	return SetnxValue(c)
}

type SetnxValue Base

// Return Completed Redis command.
func (c SetnxValue) Build() Completed {
	return completed(c)
}

// Overwrite part of a string at key starting at the specified offset.
//
// Time complexity: O(1), not counting the time taken to copy the new string in place. Usually, this string is very small so the amortized complexity is O(1). Otherwise, complexity is O(M) with M being the length of the value argument.
type Setrange Base

// Overwrite part of a string at key starting at the specified offset
//
// Command: SETRANGE.
//
// Time complexity: O(1), not counting the time taken to copy the new string in place. Usually, this string is very small so the amortized complexity is O(1). Otherwise, complexity is O(M) with M being the length of the value argument.
func (b Builder) Setrange() Setrange {
	c := Setrange{command: emptyCommand(), cslot: b.slot}
	c.command.append("SETRANGE")
	return c
}

func (c Setrange) Key(key string) SetrangeKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return SetrangeKey(c)
}

type SetrangeKey Base

func (c SetrangeKey) Offset(offset int64) SetrangeOffset {
	c.command.append(strconv.FormatInt(offset, 10))
	return SetrangeOffset(c)
}

type SetrangeOffset Base

func (c SetrangeOffset) Value(value string) SetrangeValue {
	c.command.append(value)
	return SetrangeValue(c)
}

type SetrangeValue Base

// Return Completed Redis command.
func (c SetrangeValue) Build() Completed {
	return completed(c)
}

// Synchronously save the dataset to disk and then shut down the server.
type Shutdown Base

// Synchronously save the dataset to disk and then shut down the server
//
// Command: SHUTDOWN.
func (b Builder) Shutdown() Shutdown {
	c := Shutdown{command: emptyCommand(), cslot: b.slot}
	c.command.append("SHUTDOWN")
	return c
}

func (c Shutdown) Nosave() ShutdownSaveModeNosave {
	c.command.append("NOSAVE")
	return ShutdownSaveModeNosave(c)
}

func (c Shutdown) Save() ShutdownSaveModeSave {
	c.command.append("SAVE")
	return ShutdownSaveModeSave(c)
}

func (c Shutdown) Now() ShutdownNow {
	c.command.append("NOW")
	return ShutdownNow(c)
}

func (c Shutdown) Force() ShutdownForce {
	c.command.append("FORCE")
	return ShutdownForce(c)
}

func (c Shutdown) Abort() ShutdownAbort {
	c.command.append("ABORT")
	return ShutdownAbort(c)
}

// Return Completed Redis command.
func (c Shutdown) Build() Completed {
	return completed(c)
}

type ShutdownAbort Base

// Return Completed Redis command.
func (c ShutdownAbort) Build() Completed {
	return completed(c)
}

type ShutdownForce Base

func (c ShutdownForce) Abort() ShutdownAbort {
	c.command.append("ABORT")
	return ShutdownAbort(c)
}

// Return Completed Redis command.
func (c ShutdownForce) Build() Completed {
	return completed(c)
}

type ShutdownNow Base

func (c ShutdownNow) Force() ShutdownForce {
	c.command.append("FORCE")
	return ShutdownForce(c)
}

func (c ShutdownNow) Abort() ShutdownAbort {
	c.command.append("ABORT")
	return ShutdownAbort(c)
}

// Return Completed Redis command.
func (c ShutdownNow) Build() Completed {
	return completed(c)
}

type ShutdownSaveModeNosave Base

func (c ShutdownSaveModeNosave) Now() ShutdownNow {
	c.command.append("NOW")
	return ShutdownNow(c)
}

func (c ShutdownSaveModeNosave) Force() ShutdownForce {
	c.command.append("FORCE")
	return ShutdownForce(c)
}

func (c ShutdownSaveModeNosave) Abort() ShutdownAbort {
	c.command.append("ABORT")
	return ShutdownAbort(c)
}

// Return Completed Redis command.
func (c ShutdownSaveModeNosave) Build() Completed {
	return completed(c)
}

type ShutdownSaveModeSave Base

func (c ShutdownSaveModeSave) Now() ShutdownNow {
	c.command.append("NOW")
	return ShutdownNow(c)
}

func (c ShutdownSaveModeSave) Force() ShutdownForce {
	c.command.append("FORCE")
	return ShutdownForce(c)
}

func (c ShutdownSaveModeSave) Abort() ShutdownAbort {
	c.command.append("ABORT")
	return ShutdownAbort(c)
}

// Return Completed Redis command.
func (c ShutdownSaveModeSave) Build() Completed {
	return completed(c)
}

// Intersect multiple sets.
//
// Time complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets.
type Sinter Base

// Intersect multiple sets
//
// Command: SINTER.
//
// Time complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets.
func (b Builder) Sinter() Sinter {
	c := Sinter{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("SINTER")
	return c
}

func (c Sinter) Key(key ...string) SinterKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return SinterKey(c)
}

type SinterKey Base

func (c SinterKey) Key(key ...string) SinterKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c SinterKey) Build() Completed {
	return completed(c)
}

// Intersect multiple sets and return the cardinality of the result.
//
// Time complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets.
type Sintercard Base

// Intersect multiple sets and return the cardinality of the result
//
// Command: SINTERCARD.
//
// Time complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets.
func (b Builder) Sintercard() Sintercard {
	c := Sintercard{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("SINTERCARD")
	return c
}

func (c Sintercard) Numkeys(numkeys int64) SintercardNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return SintercardNumkeys(c)
}

type SintercardKey Base

func (c SintercardKey) Key(key ...string) SintercardKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c SintercardKey) Limit(limit int64) SintercardLimit {
	c.command.append("LIMIT", strconv.FormatInt(limit, 10))
	return SintercardLimit(c)
}

// Return Completed Redis command.
func (c SintercardKey) Build() Completed {
	return completed(c)
}

type SintercardLimit Base

// Return Completed Redis command.
func (c SintercardLimit) Build() Completed {
	return completed(c)
}

type SintercardNumkeys Base

func (c SintercardNumkeys) Key(key ...string) SintercardKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return SintercardKey(c)
}

// Intersect multiple sets and store the resulting set in a key.
//
// Time complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets.
type Sinterstore Base

// Intersect multiple sets and store the resulting set in a key
//
// Command: SINTERSTORE.
//
// Time complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets.
func (b Builder) Sinterstore() Sinterstore {
	c := Sinterstore{command: emptyCommand(), cslot: b.slot}
	c.command.append("SINTERSTORE")
	return c
}

func (c Sinterstore) Destination(destination string) SinterstoreDestination {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append(destination)
	return SinterstoreDestination(c)
}

type SinterstoreDestination Base

func (c SinterstoreDestination) Key(key ...string) SinterstoreKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return SinterstoreKey(c)
}

type SinterstoreKey Base

func (c SinterstoreKey) Key(key ...string) SinterstoreKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c SinterstoreKey) Build() Completed {
	return completed(c)
}

// Determine if a given value is a member of a set.
//
// Time complexity: O(1)
type Sismember Base

// Determine if a given value is a member of a set
//
// Command: SISMEMBER.
//
// Time complexity: O(1)
func (b Builder) Sismember() Sismember {
	c := Sismember{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("SISMEMBER")
	return c
}

func (c Sismember) Key(key string) SismemberKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return SismemberKey(c)
}

type SismemberKey Base

func (c SismemberKey) Member(member string) SismemberMember {
	c.command.append(member)
	return SismemberMember(c)
}

type SismemberMember Base

// Return Completed Redis command.
func (c SismemberMember) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c SismemberMember) Cache() Cacheable {
	return cacheable(c)
}

// Make the server a replica of another instance, or promote it as master. Deprecated starting with Redis 5. Use REPLICAOF instead..
type Slaveof Base

// Make the server a replica of another instance, or promote it as master. Deprecated starting with Redis 5. Use REPLICAOF instead.
//
// Command: SLAVEOF.
func (b Builder) Slaveof() Slaveof {
	c := Slaveof{command: emptyCommand(), cslot: b.slot}
	c.command.append("SLAVEOF")
	return c
}

func (c Slaveof) Host(host string) SlaveofHost {
	c.command.append(host)
	return SlaveofHost(c)
}

type SlaveofHost Base

func (c SlaveofHost) Port(port int64) SlaveofPort {
	c.command.append(strconv.FormatInt(port, 10))
	return SlaveofPort(c)
}

type SlaveofPort Base

// Return Completed Redis command.
func (c SlaveofPort) Build() Completed {
	return completed(c)
}

// Get the slow log's entries.
//
// Time complexity: O(N) where N is the number of entries returned
type SlowlogGet Base

// Get the slow log's entries
//
// Command: SLOWLOG GET.
//
// Time complexity: O(N) where N is the number of entries returned
func (b Builder) SlowlogGet() SlowlogGet {
	c := SlowlogGet{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("SLOWLOG", "GET")
	return c
}

func (c SlowlogGet) Count(count int64) SlowlogGetCount {
	c.command.append(strconv.FormatInt(count, 10))
	return SlowlogGetCount(c)
}

// Return Completed Redis command.
func (c SlowlogGet) Build() Completed {
	return completed(c)
}

type SlowlogGetCount Base

// Return Completed Redis command.
func (c SlowlogGetCount) Build() Completed {
	return completed(c)
}

// Show helpful text about the different subcommands.
//
// Time complexity: O(1)
type SlowlogHelp Base

// Show helpful text about the different subcommands
//
// Command: SLOWLOG HELP.
//
// Time complexity: O(1)
func (b Builder) SlowlogHelp() SlowlogHelp {
	c := SlowlogHelp{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("SLOWLOG", "HELP")
	return c
}

// Return Completed Redis command.
func (c SlowlogHelp) Build() Completed {
	return completed(c)
}

// Get the slow log's length.
//
// Time complexity: O(1)
type SlowlogLen Base

// Get the slow log's length
//
// Command: SLOWLOG LEN.
//
// Time complexity: O(1)
func (b Builder) SlowlogLen() SlowlogLen {
	c := SlowlogLen{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("SLOWLOG", "LEN")
	return c
}

// Return Completed Redis command.
func (c SlowlogLen) Build() Completed {
	return completed(c)
}

// Clear all entries from the slow log.
//
// Time complexity: O(N) where N is the number of entries in the slowlog
type SlowlogReset Base

// Clear all entries from the slow log
//
// Command: SLOWLOG RESET.
//
// Time complexity: O(N) where N is the number of entries in the slowlog
func (b Builder) SlowlogReset() SlowlogReset {
	c := SlowlogReset{command: emptyCommand(), cslot: b.slot}
	c.command.append("SLOWLOG", "RESET")
	return c
}

// Return Completed Redis command.
func (c SlowlogReset) Build() Completed {
	return completed(c)
}

// Get all the members in a set.
//
// Time complexity: O(N) where N is the set cardinality.
type Smembers Base

// Get all the members in a set
//
// Command: SMEMBERS.
//
// Time complexity: O(N) where N is the set cardinality.
func (b Builder) Smembers() Smembers {
	c := Smembers{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("SMEMBERS")
	return c
}

func (c Smembers) Key(key string) SmembersKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return SmembersKey(c)
}

type SmembersKey Base

// Return Completed Redis command.
func (c SmembersKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c SmembersKey) Cache() Cacheable {
	return cacheable(c)
}

// Returns the membership associated with the given elements for a set.
//
// Time complexity: O(N) where N is the number of elements being checked for membership
type Smismember Base

// Returns the membership associated with the given elements for a set
//
// Command: SMISMEMBER.
//
// Time complexity: O(N) where N is the number of elements being checked for membership
func (b Builder) Smismember() Smismember {
	c := Smismember{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("SMISMEMBER")
	return c
}

func (c Smismember) Key(key string) SmismemberKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return SmismemberKey(c)
}

type SmismemberKey Base

func (c SmismemberKey) Member(member ...string) SmismemberMember {
	c.command.append(member...)
	return SmismemberMember(c)
}

type SmismemberMember Base

func (c SmismemberMember) Member(member ...string) SmismemberMember {
	c.command.append(member...)
	return c
}

// Return Completed Redis command.
func (c SmismemberMember) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c SmismemberMember) Cache() Cacheable {
	return cacheable(c)
}

// Move a member from one set to another.
//
// Time complexity: O(1)
type Smove Base

// Move a member from one set to another
//
// Command: SMOVE.
//
// Time complexity: O(1)
func (b Builder) Smove() Smove {
	c := Smove{command: emptyCommand(), cslot: b.slot}
	c.command.append("SMOVE")
	return c
}

func (c Smove) Source(source string) SmoveSource {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(source)
	} else {
		c.cslot.set(getSlot(source))
	}
	c.command.append(source)
	return SmoveSource(c)
}

type SmoveDestination Base

func (c SmoveDestination) Member(member string) SmoveMember {
	c.command.append(member)
	return SmoveMember(c)
}

type SmoveMember Base

// Return Completed Redis command.
func (c SmoveMember) Build() Completed {
	return completed(c)
}

type SmoveSource Base

func (c SmoveSource) Destination(destination string) SmoveDestination {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append(destination)
	return SmoveDestination(c)
}

// Sort the elements in a list, set or sorted set.
//
// Time complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).
type Sort Base

// Sort the elements in a list, set or sorted set
//
// Command: SORT.
//
// Time complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).
func (b Builder) Sort() Sort {
	c := Sort{command: emptyCommand(), cslot: b.slot}
	c.command.append("SORT")
	return c
}

func (c Sort) Key(key string) SortKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return SortKey(c)
}

type SortBy Base

func (c SortBy) Limit(offset int64, count int64) SortLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return SortLimit(c)
}

func (c SortBy) Get() SortGet {
	return SortGet(c)
}

func (c SortBy) Asc() SortOrderAsc {
	c.command.append("ASC")
	return SortOrderAsc(c)
}

func (c SortBy) Desc() SortOrderDesc {
	c.command.append("DESC")
	return SortOrderDesc(c)
}

func (c SortBy) Alpha() SortSortingAlpha {
	c.command.append("ALPHA")
	return SortSortingAlpha(c)
}

func (c SortBy) Store(destination string) SortStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append("STORE", destination)
	return SortStore(c)
}

// Return Completed Redis command.
func (c SortBy) Build() Completed {
	return completed(c)
}

type SortGet Base

func (c SortGet) Get(pattern string) SortGet {
	c.command.append("GET", pattern)
	return c
}

func (c SortGet) Asc() SortOrderAsc {
	c.command.append("ASC")
	return SortOrderAsc(c)
}

func (c SortGet) Desc() SortOrderDesc {
	c.command.append("DESC")
	return SortOrderDesc(c)
}

func (c SortGet) Alpha() SortSortingAlpha {
	c.command.append("ALPHA")
	return SortSortingAlpha(c)
}

func (c SortGet) Store(destination string) SortStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append("STORE", destination)
	return SortStore(c)
}

// Return Completed Redis command.
func (c SortGet) Build() Completed {
	return completed(c)
}

type SortKey Base

func (c SortKey) By(pattern string) SortBy {
	c.command.append("BY", pattern)
	return SortBy(c)
}

func (c SortKey) Limit(offset int64, count int64) SortLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return SortLimit(c)
}

func (c SortKey) Get() SortGet {
	return SortGet(c)
}

func (c SortKey) Asc() SortOrderAsc {
	c.command.append("ASC")
	return SortOrderAsc(c)
}

func (c SortKey) Desc() SortOrderDesc {
	c.command.append("DESC")
	return SortOrderDesc(c)
}

func (c SortKey) Alpha() SortSortingAlpha {
	c.command.append("ALPHA")
	return SortSortingAlpha(c)
}

func (c SortKey) Store(destination string) SortStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append("STORE", destination)
	return SortStore(c)
}

// Return Completed Redis command.
func (c SortKey) Build() Completed {
	return completed(c)
}

type SortLimit Base

func (c SortLimit) Get() SortGet {
	return SortGet(c)
}

func (c SortLimit) Asc() SortOrderAsc {
	c.command.append("ASC")
	return SortOrderAsc(c)
}

func (c SortLimit) Desc() SortOrderDesc {
	c.command.append("DESC")
	return SortOrderDesc(c)
}

func (c SortLimit) Alpha() SortSortingAlpha {
	c.command.append("ALPHA")
	return SortSortingAlpha(c)
}

func (c SortLimit) Store(destination string) SortStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append("STORE", destination)
	return SortStore(c)
}

// Return Completed Redis command.
func (c SortLimit) Build() Completed {
	return completed(c)
}

type SortOrderAsc Base

func (c SortOrderAsc) Alpha() SortSortingAlpha {
	c.command.append("ALPHA")
	return SortSortingAlpha(c)
}

func (c SortOrderAsc) Store(destination string) SortStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append("STORE", destination)
	return SortStore(c)
}

// Return Completed Redis command.
func (c SortOrderAsc) Build() Completed {
	return completed(c)
}

type SortOrderDesc Base

func (c SortOrderDesc) Alpha() SortSortingAlpha {
	c.command.append("ALPHA")
	return SortSortingAlpha(c)
}

func (c SortOrderDesc) Store(destination string) SortStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append("STORE", destination)
	return SortStore(c)
}

// Return Completed Redis command.
func (c SortOrderDesc) Build() Completed {
	return completed(c)
}

// Sort the elements in a list, set or sorted set. Read-only variant of SORT..
//
// Time complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).
type SortRo Base

// Sort the elements in a list, set or sorted set. Read-only variant of SORT.
//
// Command: SORT_RO.
//
// Time complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).
func (b Builder) SortRo() SortRo {
	c := SortRo{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("SORT_RO")
	return c
}

func (c SortRo) Key(key string) SortRoKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return SortRoKey(c)
}

type SortRoBy Base

func (c SortRoBy) Limit(offset int64, count int64) SortRoLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return SortRoLimit(c)
}

func (c SortRoBy) Get() SortRoGet {
	return SortRoGet(c)
}

func (c SortRoBy) Asc() SortRoOrderAsc {
	c.command.append("ASC")
	return SortRoOrderAsc(c)
}

func (c SortRoBy) Desc() SortRoOrderDesc {
	c.command.append("DESC")
	return SortRoOrderDesc(c)
}

func (c SortRoBy) Alpha() SortRoSortingAlpha {
	c.command.append("ALPHA")
	return SortRoSortingAlpha(c)
}

// Return Completed Redis command.
func (c SortRoBy) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c SortRoBy) Cache() Cacheable {
	return cacheable(c)
}

type SortRoGet Base

func (c SortRoGet) Get(pattern string) SortRoGet {
	c.command.append("GET", pattern)
	return c
}

func (c SortRoGet) Asc() SortRoOrderAsc {
	c.command.append("ASC")
	return SortRoOrderAsc(c)
}

func (c SortRoGet) Desc() SortRoOrderDesc {
	c.command.append("DESC")
	return SortRoOrderDesc(c)
}

func (c SortRoGet) Alpha() SortRoSortingAlpha {
	c.command.append("ALPHA")
	return SortRoSortingAlpha(c)
}

// Return Completed Redis command.
func (c SortRoGet) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c SortRoGet) Cache() Cacheable {
	return cacheable(c)
}

type SortRoKey Base

func (c SortRoKey) By(pattern string) SortRoBy {
	c.command.append("BY", pattern)
	return SortRoBy(c)
}

func (c SortRoKey) Limit(offset int64, count int64) SortRoLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return SortRoLimit(c)
}

func (c SortRoKey) Get() SortRoGet {
	return SortRoGet(c)
}

func (c SortRoKey) Asc() SortRoOrderAsc {
	c.command.append("ASC")
	return SortRoOrderAsc(c)
}

func (c SortRoKey) Desc() SortRoOrderDesc {
	c.command.append("DESC")
	return SortRoOrderDesc(c)
}

func (c SortRoKey) Alpha() SortRoSortingAlpha {
	c.command.append("ALPHA")
	return SortRoSortingAlpha(c)
}

// Return Completed Redis command.
func (c SortRoKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c SortRoKey) Cache() Cacheable {
	return cacheable(c)
}

type SortRoLimit Base

func (c SortRoLimit) Get() SortRoGet {
	return SortRoGet(c)
}

func (c SortRoLimit) Asc() SortRoOrderAsc {
	c.command.append("ASC")
	return SortRoOrderAsc(c)
}

func (c SortRoLimit) Desc() SortRoOrderDesc {
	c.command.append("DESC")
	return SortRoOrderDesc(c)
}

func (c SortRoLimit) Alpha() SortRoSortingAlpha {
	c.command.append("ALPHA")
	return SortRoSortingAlpha(c)
}

// Return Completed Redis command.
func (c SortRoLimit) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c SortRoLimit) Cache() Cacheable {
	return cacheable(c)
}

type SortRoOrderAsc Base

func (c SortRoOrderAsc) Alpha() SortRoSortingAlpha {
	c.command.append("ALPHA")
	return SortRoSortingAlpha(c)
}

// Return Completed Redis command.
func (c SortRoOrderAsc) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c SortRoOrderAsc) Cache() Cacheable {
	return cacheable(c)
}

type SortRoOrderDesc Base

func (c SortRoOrderDesc) Alpha() SortRoSortingAlpha {
	c.command.append("ALPHA")
	return SortRoSortingAlpha(c)
}

// Return Completed Redis command.
func (c SortRoOrderDesc) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c SortRoOrderDesc) Cache() Cacheable {
	return cacheable(c)
}

type SortRoSortingAlpha Base

// Return Completed Redis command.
func (c SortRoSortingAlpha) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c SortRoSortingAlpha) Cache() Cacheable {
	return cacheable(c)
}

type SortSortingAlpha Base

func (c SortSortingAlpha) Store(destination string) SortStore {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append("STORE", destination)
	return SortStore(c)
}

// Return Completed Redis command.
func (c SortSortingAlpha) Build() Completed {
	return completed(c)
}

type SortStore Base

// Return Completed Redis command.
func (c SortStore) Build() Completed {
	return completed(c)
}

// Remove and return one or multiple random members from a set.
//
// Time complexity: Without the count argument O(1), otherwise O(N) where N is the value of the passed count.
type Spop Base

// Remove and return one or multiple random members from a set
//
// Command: SPOP.
//
// Time complexity: Without the count argument O(1), otherwise O(N) where N is the value of the passed count.
func (b Builder) Spop() Spop {
	c := Spop{command: emptyCommand(), cslot: b.slot}
	c.command.append("SPOP")
	return c
}

func (c Spop) Key(key string) SpopKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return SpopKey(c)
}

type SpopCount Base

// Return Completed Redis command.
func (c SpopCount) Build() Completed {
	return completed(c)
}

type SpopKey Base

func (c SpopKey) Count(count int64) SpopCount {
	c.command.append(strconv.FormatInt(count, 10))
	return SpopCount(c)
}

// Return Completed Redis command.
func (c SpopKey) Build() Completed {
	return completed(c)
}

type Spublish Base

// Command: SPUBLISH.
func (b Builder) Spublish() Spublish {
	c := Spublish{command: emptyCommand(), cslot: b.slot}
	c.command.append("SPUBLISH")
	return c
}

func (c Spublish) Channel(channel string) SpublishChannel {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(channel)
	} else {
		c.cslot.set(getSlot(channel))
	}
	c.command.append(channel)
	return SpublishChannel(c)
}

type SpublishChannel Base

func (c SpublishChannel) Message(message string) SpublishMessage {
	c.command.append(message)
	return SpublishMessage(c)
}

type SpublishMessage Base

// Return Completed Redis command.
func (c SpublishMessage) Build() Completed {
	return completed(c)
}

// Get one or multiple random members from a set.
//
// Time complexity: Without the count argument O(1), otherwise O(N) where N is the absolute value of the passed count.
type Srandmember Base

// Get one or multiple random members from a set
//
// Command: SRANDMEMBER.
//
// Time complexity: Without the count argument O(1), otherwise O(N) where N is the absolute value of the passed count.
func (b Builder) Srandmember() Srandmember {
	c := Srandmember{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("SRANDMEMBER")
	return c
}

func (c Srandmember) Key(key string) SrandmemberKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return SrandmemberKey(c)
}

type SrandmemberCount Base

// Return Completed Redis command.
func (c SrandmemberCount) Build() Completed {
	return completed(c)
}

type SrandmemberKey Base

func (c SrandmemberKey) Count(count int64) SrandmemberCount {
	c.command.append(strconv.FormatInt(count, 10))
	return SrandmemberCount(c)
}

// Return Completed Redis command.
func (c SrandmemberKey) Build() Completed {
	return completed(c)
}

// Remove one or more members from a set.
//
// Time complexity: O(N) where N is the number of members to be removed.
type Srem Base

// Remove one or more members from a set
//
// Command: SREM.
//
// Time complexity: O(N) where N is the number of members to be removed.
func (b Builder) Srem() Srem {
	c := Srem{command: emptyCommand(), cslot: b.slot}
	c.command.append("SREM")
	return c
}

func (c Srem) Key(key string) SremKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return SremKey(c)
}

type SremKey Base

func (c SremKey) Member(member ...string) SremMember {
	c.command.append(member...)
	return SremMember(c)
}

type SremMember Base

func (c SremMember) Member(member ...string) SremMember {
	c.command.append(member...)
	return c
}

// Return Completed Redis command.
func (c SremMember) Build() Completed {
	return completed(c)
}

// Incrementally iterate Set elements.
//
// Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..
type Sscan Base

// Incrementally iterate Set elements
//
// Command: SSCAN.
//
// Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..
func (b Builder) Sscan() Sscan {
	c := Sscan{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("SSCAN")
	return c
}

func (c Sscan) Key(key string) SscanKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return SscanKey(c)
}

type SscanCount Base

// Return Completed Redis command.
func (c SscanCount) Build() Completed {
	return completed(c)
}

type SscanCursor Base

func (c SscanCursor) Match(pattern string) SscanMatch {
	c.command.append("MATCH", pattern)
	return SscanMatch(c)
}

func (c SscanCursor) Count(count int64) SscanCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return SscanCount(c)
}

// Return Completed Redis command.
func (c SscanCursor) Build() Completed {
	return completed(c)
}

type SscanKey Base

func (c SscanKey) Cursor(cursor int64) SscanCursor {
	c.command.append(strconv.FormatInt(cursor, 10))
	return SscanCursor(c)
}

type SscanMatch Base

func (c SscanMatch) Count(count int64) SscanCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return SscanCount(c)
}

// Return Completed Redis command.
func (c SscanMatch) Build() Completed {
	return completed(c)
}

type Ssubscribe Base

// Command: SSUBSCRIBE.
func (b Builder) Ssubscribe() Ssubscribe {
	c := Ssubscribe{command: emptyCommand(), cslot: b.slot, ctags: ctagNoRet}
	c.command.append("SSUBSCRIBE")
	return c
}

func (c Ssubscribe) Channel(channel ...string) SsubscribeChannel {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range channel {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range channel {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(channel...)
	return SsubscribeChannel(c)
}

type SsubscribeChannel Base

func (c SsubscribeChannel) Channel(channel ...string) SsubscribeChannel {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range channel {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range channel {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(channel...)
	return c
}

// Return Completed Redis command.
func (c SsubscribeChannel) Build() Completed {
	return completed(c)
}

// Get the length of the value stored in a key.
//
// Time complexity: O(1)
type Strlen Base

// Get the length of the value stored in a key
//
// Command: STRLEN.
//
// Time complexity: O(1)
func (b Builder) Strlen() Strlen {
	c := Strlen{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("STRLEN")
	return c
}

func (c Strlen) Key(key string) StrlenKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return StrlenKey(c)
}

type StrlenKey Base

// Return Completed Redis command.
func (c StrlenKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c StrlenKey) Cache() Cacheable {
	return cacheable(c)
}

// Listen for messages published to the given channels.
//
// Time complexity: O(N) where N is the number of channels to subscribe to.
type Subscribe Base

// Listen for messages published to the given channels
//
// Command: SUBSCRIBE.
//
// Time complexity: O(N) where N is the number of channels to subscribe to.
func (b Builder) Subscribe() Subscribe {
	c := Subscribe{command: emptyCommand(), cslot: b.slot, ctags: ctagNoRet}
	c.command.append("SUBSCRIBE")
	return c
}

func (c Subscribe) Channel(channel ...string) SubscribeChannel {
	c.command.append(channel...)
	return SubscribeChannel(c)
}

type SubscribeChannel Base

func (c SubscribeChannel) Channel(channel ...string) SubscribeChannel {
	c.command.append(channel...)
	return c
}

// Return Completed Redis command.
func (c SubscribeChannel) Build() Completed {
	return completed(c)
}

// Add multiple sets.
//
// Time complexity: O(N) where N is the total number of elements in all given sets.
type Sunion Base

// Add multiple sets
//
// Command: SUNION.
//
// Time complexity: O(N) where N is the total number of elements in all given sets.
func (b Builder) Sunion() Sunion {
	c := Sunion{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("SUNION")
	return c
}

func (c Sunion) Key(key ...string) SunionKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return SunionKey(c)
}

type SunionKey Base

func (c SunionKey) Key(key ...string) SunionKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c SunionKey) Build() Completed {
	return completed(c)
}

// Add multiple sets and store the resulting set in a key.
//
// Time complexity: O(N) where N is the total number of elements in all given sets.
type Sunionstore Base

// Add multiple sets and store the resulting set in a key
//
// Command: SUNIONSTORE.
//
// Time complexity: O(N) where N is the total number of elements in all given sets.
func (b Builder) Sunionstore() Sunionstore {
	c := Sunionstore{command: emptyCommand(), cslot: b.slot}
	c.command.append("SUNIONSTORE")
	return c
}

func (c Sunionstore) Destination(destination string) SunionstoreDestination {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append(destination)
	return SunionstoreDestination(c)
}

type SunionstoreDestination Base

func (c SunionstoreDestination) Key(key ...string) SunionstoreKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return SunionstoreKey(c)
}

type SunionstoreKey Base

func (c SunionstoreKey) Key(key ...string) SunionstoreKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c SunionstoreKey) Build() Completed {
	return completed(c)
}

type Sunsubscribe Base

// Command: SUNSUBSCRIBE.
func (b Builder) Sunsubscribe() Sunsubscribe {
	c := Sunsubscribe{command: emptyCommand(), cslot: b.slot, ctags: ctagNoRet}
	c.command.append("SUNSUBSCRIBE")
	return c
}

func (c Sunsubscribe) Channel(channel ...string) SunsubscribeChannel {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range channel {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range channel {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(channel...)
	return SunsubscribeChannel(c)
}

// Return Completed Redis command.
func (c Sunsubscribe) Build() Completed {
	return completed(c)
}

type SunsubscribeChannel Base

func (c SunsubscribeChannel) Channel(channel ...string) SunsubscribeChannel {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range channel {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range channel {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(channel...)
	return c
}

// Return Completed Redis command.
func (c SunsubscribeChannel) Build() Completed {
	return completed(c)
}

// Swaps two Redis databases.
//
// Time complexity: O(N) where N is the count of clients watching or blocking on keys from both databases.
type Swapdb Base

// Swaps two Redis databases
//
// Command: SWAPDB.
//
// Time complexity: O(N) where N is the count of clients watching or blocking on keys from both databases.
func (b Builder) Swapdb() Swapdb {
	c := Swapdb{command: emptyCommand(), cslot: b.slot}
	c.command.append("SWAPDB")
	return c
}

func (c Swapdb) Index1(index1 int64) SwapdbIndex1 {
	c.command.append(strconv.FormatInt(index1, 10))
	return SwapdbIndex1(c)
}

type SwapdbIndex1 Base

func (c SwapdbIndex1) Index2(index2 int64) SwapdbIndex2 {
	c.command.append(strconv.FormatInt(index2, 10))
	return SwapdbIndex2(c)
}

type SwapdbIndex2 Base

// Return Completed Redis command.
func (c SwapdbIndex2) Build() Completed {
	return completed(c)
}

// Internal command used for replication.
type Sync Base

// Internal command used for replication
//
// Command: SYNC.
func (b Builder) Sync() Sync {
	c := Sync{command: emptyCommand(), cslot: b.slot}
	c.command.append("SYNC")
	return c
}

// Return Completed Redis command.
func (c Sync) Build() Completed {
	return completed(c)
}

// Adds one or more samples to a sketch.
//
// Time complexity: O(N) , where N is the number of samples to add
type TdigestAdd Base

// Adds one or more samples to a sketch
//
// Command: TDIGEST.ADD.
//
// Time complexity: O(N) , where N is the number of samples to add
func (b Builder) TdigestAdd() TdigestAdd {
	c := TdigestAdd{command: emptyCommand(), cslot: b.slot}
	c.command.append("TDIGEST.ADD")
	return c
}

func (c TdigestAdd) Key(key string) TdigestAddKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TdigestAddKey(c)
}

type TdigestAddKey Base

func (c TdigestAddKey) Value(value float64) TdigestAddValuesValue {
	c.command.append(strconv.FormatFloat(value, 'f', -1, 64))
	return TdigestAddValuesValue(c)
}

type TdigestAddValuesValue Base

func (c TdigestAddValuesValue) Value(value float64) TdigestAddValuesValue {
	c.command.append(strconv.FormatFloat(value, 'f', -1, 64))
	return c
}

// Return Completed Redis command.
func (c TdigestAddValuesValue) Build() Completed {
	return completed(c)
}

// Retrieve an estimation of the value with the given the rank. Multiple estimations can be returned with one call..
//
// Time complexity: O(1)
type TdigestByrank Base

// Retrieve an estimation of the value with the given the rank. Multiple estimations can be returned with one call.
//
// Command: TDIGEST.BYRANK.
//
// Time complexity: O(1)
func (b Builder) TdigestByrank() TdigestByrank {
	c := TdigestByrank{command: emptyCommand(), cslot: b.slot}
	c.command.append("TDIGEST.BYRANK")
	return c
}

func (c TdigestByrank) Key(key string) TdigestByrankKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TdigestByrankKey(c)
}

type TdigestByrankKey Base

func (c TdigestByrankKey) Rank(rank ...float64) TdigestByrankRank {
	for _, n := range rank {
		c.command.append(strconv.FormatFloat(n, 'f', -1, 64))
	}
	return TdigestByrankRank(c)
}

type TdigestByrankRank Base

func (c TdigestByrankRank) Rank(rank ...float64) TdigestByrankRank {
	for _, n := range rank {
		c.command.append(strconv.FormatFloat(n, 'f', -1, 64))
	}
	return c
}

// Return Completed Redis command.
func (c TdigestByrankRank) Build() Completed {
	return completed(c)
}

// Retrieve an estimation of the value with the given the reverse rank. Multiple estimations can be returned with one call..
//
// Time complexity: O(1)
type TdigestByrevrank Base

// Retrieve an estimation of the value with the given the reverse rank. Multiple estimations can be returned with one call.
//
// Command: TDIGEST.BYREVRANK.
//
// Time complexity: O(1)
func (b Builder) TdigestByrevrank() TdigestByrevrank {
	c := TdigestByrevrank{command: emptyCommand(), cslot: b.slot}
	c.command.append("TDIGEST.BYREVRANK")
	return c
}

func (c TdigestByrevrank) Key(key string) TdigestByrevrankKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TdigestByrevrankKey(c)
}

type TdigestByrevrankKey Base

func (c TdigestByrevrankKey) ReverseRank(reverseRank ...float64) TdigestByrevrankReverseRank {
	for _, n := range reverseRank {
		c.command.append(strconv.FormatFloat(n, 'f', -1, 64))
	}
	return TdigestByrevrankReverseRank(c)
}

type TdigestByrevrankReverseRank Base

func (c TdigestByrevrankReverseRank) ReverseRank(reverseRank ...float64) TdigestByrevrankReverseRank {
	for _, n := range reverseRank {
		c.command.append(strconv.FormatFloat(n, 'f', -1, 64))
	}
	return c
}

// Return Completed Redis command.
func (c TdigestByrevrankReverseRank) Build() Completed {
	return completed(c)
}

// Returns the fraction of all points added which are <= value. Multiple fractions can be returned with one call..
//
// Time complexity: O(1)
type TdigestCdf Base

// Returns the fraction of all points added which are <= value. Multiple fractions can be returned with one call.
//
// Command: TDIGEST.CDF.
//
// Time complexity: O(1)
func (b Builder) TdigestCdf() TdigestCdf {
	c := TdigestCdf{command: emptyCommand(), cslot: b.slot}
	c.command.append("TDIGEST.CDF")
	return c
}

func (c TdigestCdf) Key(key string) TdigestCdfKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TdigestCdfKey(c)
}

type TdigestCdfKey Base

func (c TdigestCdfKey) Value(value ...float64) TdigestCdfValue {
	for _, n := range value {
		c.command.append(strconv.FormatFloat(n, 'f', -1, 64))
	}
	return TdigestCdfValue(c)
}

type TdigestCdfValue Base

func (c TdigestCdfValue) Value(value ...float64) TdigestCdfValue {
	for _, n := range value {
		c.command.append(strconv.FormatFloat(n, 'f', -1, 64))
	}
	return c
}

// Return Completed Redis command.
func (c TdigestCdfValue) Build() Completed {
	return completed(c)
}

// Allocate the memory and initialize the t-digest.
//
// Time complexity: O(1)
type TdigestCreate Base

// Allocate the memory and initialize the t-digest
//
// Command: TDIGEST.CREATE.
//
// Time complexity: O(1)
func (b Builder) TdigestCreate() TdigestCreate {
	c := TdigestCreate{command: emptyCommand(), cslot: b.slot}
	c.command.append("TDIGEST.CREATE")
	return c
}

func (c TdigestCreate) Key(key string) TdigestCreateKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TdigestCreateKey(c)
}

type TdigestCreateCompression Base

// Return Completed Redis command.
func (c TdigestCreateCompression) Build() Completed {
	return completed(c)
}

type TdigestCreateKey Base

func (c TdigestCreateKey) Compression(compression int64) TdigestCreateCompression {
	c.command.append("COMPRESSION", strconv.FormatInt(compression, 10))
	return TdigestCreateCompression(c)
}

// Return Completed Redis command.
func (c TdigestCreateKey) Build() Completed {
	return completed(c)
}

// Returns information about a sketch.
//
// Time complexity: O(1)
type TdigestInfo Base

// Returns information about a sketch
//
// Command: TDIGEST.INFO.
//
// Time complexity: O(1)
func (b Builder) TdigestInfo() TdigestInfo {
	c := TdigestInfo{command: emptyCommand(), cslot: b.slot}
	c.command.append("TDIGEST.INFO")
	return c
}

func (c TdigestInfo) Key(key string) TdigestInfoKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TdigestInfoKey(c)
}

type TdigestInfoKey Base

// Return Completed Redis command.
func (c TdigestInfoKey) Build() Completed {
	return completed(c)
}

// Get maximum value from the sketch.
//
// Time complexity: O(1)
type TdigestMax Base

// Get maximum value from the sketch
//
// Command: TDIGEST.MAX.
//
// Time complexity: O(1)
func (b Builder) TdigestMax() TdigestMax {
	c := TdigestMax{command: emptyCommand(), cslot: b.slot}
	c.command.append("TDIGEST.MAX")
	return c
}

func (c TdigestMax) Key(key string) TdigestMaxKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TdigestMaxKey(c)
}

type TdigestMaxKey Base

// Return Completed Redis command.
func (c TdigestMaxKey) Build() Completed {
	return completed(c)
}

// Merges all of the values from 'source-key' keys to 'destination-key' sketch.
//
// Time complexity: O(N*K), where N is the number of centroids and K being the number of input sketches
type TdigestMerge Base

// Merges all of the values from 'source-key' keys to 'destination-key' sketch
//
// Command: TDIGEST.MERGE.
//
// Time complexity: O(N*K), where N is the number of centroids and K being the number of input sketches
func (b Builder) TdigestMerge() TdigestMerge {
	c := TdigestMerge{command: emptyCommand(), cslot: b.slot}
	c.command.append("TDIGEST.MERGE")
	return c
}

func (c TdigestMerge) DestinationKey(destinationKey string) TdigestMergeDestinationKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destinationKey)
	} else {
		c.cslot.set(getSlot(destinationKey))
	}
	c.command.append(destinationKey)
	return TdigestMergeDestinationKey(c)
}

type TdigestMergeConfigCompression Base

func (c TdigestMergeConfigCompression) Override() TdigestMergeOverride {
	c.command.append("OVERRIDE")
	return TdigestMergeOverride(c)
}

// Return Completed Redis command.
func (c TdigestMergeConfigCompression) Build() Completed {
	return completed(c)
}

type TdigestMergeDestinationKey Base

func (c TdigestMergeDestinationKey) Numkeys(numkeys int64) TdigestMergeNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return TdigestMergeNumkeys(c)
}

type TdigestMergeNumkeys Base

func (c TdigestMergeNumkeys) SourceKey(sourceKey ...string) TdigestMergeSourceKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range sourceKey {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range sourceKey {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(sourceKey...)
	return TdigestMergeSourceKey(c)
}

type TdigestMergeOverride Base

// Return Completed Redis command.
func (c TdigestMergeOverride) Build() Completed {
	return completed(c)
}

type TdigestMergeSourceKey Base

func (c TdigestMergeSourceKey) SourceKey(sourceKey ...string) TdigestMergeSourceKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range sourceKey {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range sourceKey {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(sourceKey...)
	return c
}

func (c TdigestMergeSourceKey) Compression(compression int64) TdigestMergeConfigCompression {
	c.command.append("COMPRESSION", strconv.FormatInt(compression, 10))
	return TdigestMergeConfigCompression(c)
}

func (c TdigestMergeSourceKey) Override() TdigestMergeOverride {
	c.command.append("OVERRIDE")
	return TdigestMergeOverride(c)
}

// Return Completed Redis command.
func (c TdigestMergeSourceKey) Build() Completed {
	return completed(c)
}

// Get minimum value from the sketch.
//
// Time complexity: O(1)
type TdigestMin Base

// Get minimum value from the sketch
//
// Command: TDIGEST.MIN.
//
// Time complexity: O(1)
func (b Builder) TdigestMin() TdigestMin {
	c := TdigestMin{command: emptyCommand(), cslot: b.slot}
	c.command.append("TDIGEST.MIN")
	return c
}

func (c TdigestMin) Key(key string) TdigestMinKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TdigestMinKey(c)
}

type TdigestMinKey Base

// Return Completed Redis command.
func (c TdigestMinKey) Build() Completed {
	return completed(c)
}

// Returns an estimate of the cutoff such that a specified fraction of the data added to this TDigest would be less than or equal to the specified cutoffs. Multiple quantiles can be returned with one call..
//
// Time complexity: O(1)
type TdigestQuantile Base

// Returns an estimate of the cutoff such that a specified fraction of the data added to this TDigest would be less than or equal to the specified cutoffs. Multiple quantiles can be returned with one call.
//
// Command: TDIGEST.QUANTILE.
//
// Time complexity: O(1)
func (b Builder) TdigestQuantile() TdigestQuantile {
	c := TdigestQuantile{command: emptyCommand(), cslot: b.slot}
	c.command.append("TDIGEST.QUANTILE")
	return c
}

func (c TdigestQuantile) Key(key string) TdigestQuantileKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TdigestQuantileKey(c)
}

type TdigestQuantileKey Base

func (c TdigestQuantileKey) Quantile(quantile ...float64) TdigestQuantileQuantile {
	for _, n := range quantile {
		c.command.append(strconv.FormatFloat(n, 'f', -1, 64))
	}
	return TdigestQuantileQuantile(c)
}

type TdigestQuantileQuantile Base

func (c TdigestQuantileQuantile) Quantile(quantile ...float64) TdigestQuantileQuantile {
	for _, n := range quantile {
		c.command.append(strconv.FormatFloat(n, 'f', -1, 64))
	}
	return c
}

// Return Completed Redis command.
func (c TdigestQuantileQuantile) Build() Completed {
	return completed(c)
}

// Retrieve the estimated rank of value (the number of observations in the sketch that are smaller than value + half the number of observations that are equal to value). Multiple ranks can be returned with one call..
//
// Time complexity: O(1)
type TdigestRank Base

// Retrieve the estimated rank of value (the number of observations in the sketch that are smaller than value + half the number of observations that are equal to value). Multiple ranks can be returned with one call.
//
// Command: TDIGEST.RANK.
//
// Time complexity: O(1)
func (b Builder) TdigestRank() TdigestRank {
	c := TdigestRank{command: emptyCommand(), cslot: b.slot}
	c.command.append("TDIGEST.RANK")
	return c
}

func (c TdigestRank) Key(key string) TdigestRankKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TdigestRankKey(c)
}

type TdigestRankKey Base

func (c TdigestRankKey) Value(value ...float64) TdigestRankValue {
	for _, n := range value {
		c.command.append(strconv.FormatFloat(n, 'f', -1, 64))
	}
	return TdigestRankValue(c)
}

type TdigestRankValue Base

func (c TdigestRankValue) Value(value ...float64) TdigestRankValue {
	for _, n := range value {
		c.command.append(strconv.FormatFloat(n, 'f', -1, 64))
	}
	return c
}

// Return Completed Redis command.
func (c TdigestRankValue) Build() Completed {
	return completed(c)
}

// Reset the sketch to zero - empty out the sketch and re-initialize it.
//
// Time complexity: O(1)
type TdigestReset Base

// Reset the sketch to zero - empty out the sketch and re-initialize it
//
// Command: TDIGEST.RESET.
//
// Time complexity: O(1)
func (b Builder) TdigestReset() TdigestReset {
	c := TdigestReset{command: emptyCommand(), cslot: b.slot}
	c.command.append("TDIGEST.RESET")
	return c
}

func (c TdigestReset) Key(key string) TdigestResetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TdigestResetKey(c)
}

type TdigestResetKey Base

// Return Completed Redis command.
func (c TdigestResetKey) Build() Completed {
	return completed(c)
}

// Retrieve the estimated rank of value (the number of observations in the sketch that are larger than value + half the number of observations that are equal to value). Multiple ranks can be returned with one call..
//
// Time complexity: O(1)
type TdigestRevrank Base

// Retrieve the estimated rank of value (the number of observations in the sketch that are larger than value + half the number of observations that are equal to value). Multiple ranks can be returned with one call.
//
// Command: TDIGEST.REVRANK.
//
// Time complexity: O(1)
func (b Builder) TdigestRevrank() TdigestRevrank {
	c := TdigestRevrank{command: emptyCommand(), cslot: b.slot}
	c.command.append("TDIGEST.REVRANK")
	return c
}

func (c TdigestRevrank) Key(key string) TdigestRevrankKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TdigestRevrankKey(c)
}

type TdigestRevrankKey Base

func (c TdigestRevrankKey) Value(value ...float64) TdigestRevrankValue {
	for _, n := range value {
		c.command.append(strconv.FormatFloat(n, 'f', -1, 64))
	}
	return TdigestRevrankValue(c)
}

type TdigestRevrankValue Base

func (c TdigestRevrankValue) Value(value ...float64) TdigestRevrankValue {
	for _, n := range value {
		c.command.append(strconv.FormatFloat(n, 'f', -1, 64))
	}
	return c
}

// Return Completed Redis command.
func (c TdigestRevrankValue) Build() Completed {
	return completed(c)
}

// Returns the trimmed mean ignoring values outside given cutoff upper and lower limits.
//
// Time complexity: O(n)
type TdigestTrimmedMean Base

// Returns the trimmed mean ignoring values outside given cutoff upper and lower limits
//
// Command: TDIGEST.TRIMMED_MEAN.
//
// Time complexity: O(n)
func (b Builder) TdigestTrimmedMean() TdigestTrimmedMean {
	c := TdigestTrimmedMean{command: emptyCommand(), cslot: b.slot}
	c.command.append("TDIGEST.TRIMMED_MEAN")
	return c
}

func (c TdigestTrimmedMean) Key(key string) TdigestTrimmedMeanKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TdigestTrimmedMeanKey(c)
}

type TdigestTrimmedMeanHighCutQuantile Base

// Return Completed Redis command.
func (c TdigestTrimmedMeanHighCutQuantile) Build() Completed {
	return completed(c)
}

type TdigestTrimmedMeanKey Base

func (c TdigestTrimmedMeanKey) LowCutQuantile(lowCutQuantile float64) TdigestTrimmedMeanLowCutQuantile {
	c.command.append(strconv.FormatFloat(lowCutQuantile, 'f', -1, 64))
	return TdigestTrimmedMeanLowCutQuantile(c)
}

type TdigestTrimmedMeanLowCutQuantile Base

func (c TdigestTrimmedMeanLowCutQuantile) HighCutQuantile(highCutQuantile float64) TdigestTrimmedMeanHighCutQuantile {
	c.command.append(strconv.FormatFloat(highCutQuantile, 'f', -1, 64))
	return TdigestTrimmedMeanHighCutQuantile(c)
}

// Return the current server time.
//
// Time complexity: O(1)
type Time Base

// Return the current server time
//
// Command: TIME.
//
// Time complexity: O(1)
func (b Builder) Time() Time {
	c := Time{command: emptyCommand(), cslot: b.slot}
	c.command.append("TIME")
	return c
}

// Return Completed Redis command.
func (c Time) Build() Completed {
	return completed(c)
}

// Increases the count of one or more items by increment.
//
// Time complexity: O(n * k) where n is the number of items and k is the depth
type TopkAdd Base

// Increases the count of one or more items by increment
//
// Command: TOPK.ADD.
//
// Time complexity: O(n * k) where n is the number of items and k is the depth
func (b Builder) TopkAdd() TopkAdd {
	c := TopkAdd{command: emptyCommand(), cslot: b.slot}
	c.command.append("TOPK.ADD")
	return c
}

func (c TopkAdd) Key(key string) TopkAddKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TopkAddKey(c)
}

type TopkAddItems Base

func (c TopkAddItems) Items(items ...string) TopkAddItems {
	c.command.append(items...)
	return c
}

// Return Completed Redis command.
func (c TopkAddItems) Build() Completed {
	return completed(c)
}

type TopkAddKey Base

func (c TopkAddKey) Items(items ...string) TopkAddItems {
	c.command.append(items...)
	return TopkAddItems(c)
}

// Return the count for one or more items are in a sketch.
//
// Time complexity: O(n) where n is the number of items
//
// Deprecated: [since 2.4]
type TopkCount Base

// Return the count for one or more items are in a sketch
//
// Command: TOPK.COUNT.
//
// Time complexity: O(n) where n is the number of items
//
// Deprecated: [since 2.4]
func (b Builder) TopkCount() TopkCount {
	c := TopkCount{command: emptyCommand(), cslot: b.slot}
	c.command.append("TOPK.COUNT")
	return c
}

func (c TopkCount) Key(key string) TopkCountKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TopkCountKey(c)
}

type TopkCountItem Base

func (c TopkCountItem) Item(item ...string) TopkCountItem {
	c.command.append(item...)
	return c
}

// Return Completed Redis command.
func (c TopkCountItem) Build() Completed {
	return completed(c)
}

type TopkCountKey Base

func (c TopkCountKey) Item(item ...string) TopkCountItem {
	c.command.append(item...)
	return TopkCountItem(c)
}

// Increases the count of one or more items by increment.
//
// Time complexity: O(n * k * incr) where n is the number of items, k is the depth and incr is the increment
type TopkIncrby Base

// Increases the count of one or more items by increment
//
// Command: TOPK.INCRBY.
//
// Time complexity: O(n * k * incr) where n is the number of items, k is the depth and incr is the increment
func (b Builder) TopkIncrby() TopkIncrby {
	c := TopkIncrby{command: emptyCommand(), cslot: b.slot}
	c.command.append("TOPK.INCRBY")
	return c
}

func (c TopkIncrby) Key(key string) TopkIncrbyKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TopkIncrbyKey(c)
}

type TopkIncrbyItemsIncrement Base

func (c TopkIncrbyItemsIncrement) Item(item string) TopkIncrbyItemsItem {
	c.command.append(item)
	return TopkIncrbyItemsItem(c)
}

// Return Completed Redis command.
func (c TopkIncrbyItemsIncrement) Build() Completed {
	return completed(c)
}

type TopkIncrbyItemsItem Base

func (c TopkIncrbyItemsItem) Increment(increment int64) TopkIncrbyItemsIncrement {
	c.command.append(strconv.FormatInt(increment, 10))
	return TopkIncrbyItemsIncrement(c)
}

type TopkIncrbyKey Base

func (c TopkIncrbyKey) Item(item string) TopkIncrbyItemsItem {
	c.command.append(item)
	return TopkIncrbyItemsItem(c)
}

// Returns information about a sketch.
//
// Time complexity: O(1)
type TopkInfo Base

// Returns information about a sketch
//
// Command: TOPK.INFO.
//
// Time complexity: O(1)
func (b Builder) TopkInfo() TopkInfo {
	c := TopkInfo{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("TOPK.INFO")
	return c
}

func (c TopkInfo) Key(key string) TopkInfoKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TopkInfoKey(c)
}

type TopkInfoKey Base

// Return Completed Redis command.
func (c TopkInfoKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c TopkInfoKey) Cache() Cacheable {
	return cacheable(c)
}

// Return full list of items in Top K list.
//
// Time complexity: O(k) where k is the value of top-k
type TopkList Base

// Return full list of items in Top K list
//
// Command: TOPK.LIST.
//
// Time complexity: O(k) where k is the value of top-k
func (b Builder) TopkList() TopkList {
	c := TopkList{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("TOPK.LIST")
	return c
}

func (c TopkList) Key(key string) TopkListKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TopkListKey(c)
}

type TopkListKey Base

func (c TopkListKey) Withcount() TopkListWithcount {
	c.command.append("WITHCOUNT")
	return TopkListWithcount(c)
}

// Return Completed Redis command.
func (c TopkListKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c TopkListKey) Cache() Cacheable {
	return cacheable(c)
}

type TopkListWithcount Base

// Return Completed Redis command.
func (c TopkListWithcount) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c TopkListWithcount) Cache() Cacheable {
	return cacheable(c)
}

// Checks whether one or more items are in a sketch.
//
// Time complexity: O(n) where n is the number of items
type TopkQuery Base

// Checks whether one or more items are in a sketch
//
// Command: TOPK.QUERY.
//
// Time complexity: O(n) where n is the number of items
func (b Builder) TopkQuery() TopkQuery {
	c := TopkQuery{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("TOPK.QUERY")
	return c
}

func (c TopkQuery) Key(key string) TopkQueryKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TopkQueryKey(c)
}

type TopkQueryItem Base

func (c TopkQueryItem) Item(item ...string) TopkQueryItem {
	c.command.append(item...)
	return c
}

// Return Completed Redis command.
func (c TopkQueryItem) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c TopkQueryItem) Cache() Cacheable {
	return cacheable(c)
}

type TopkQueryKey Base

func (c TopkQueryKey) Item(item ...string) TopkQueryItem {
	c.command.append(item...)
	return TopkQueryItem(c)
}

// Initializes a TopK with specified parameters.
//
// Time complexity: O(1)
type TopkReserve Base

// Initializes a TopK with specified parameters
//
// Command: TOPK.RESERVE.
//
// Time complexity: O(1)
func (b Builder) TopkReserve() TopkReserve {
	c := TopkReserve{command: emptyCommand(), cslot: b.slot}
	c.command.append("TOPK.RESERVE")
	return c
}

func (c TopkReserve) Key(key string) TopkReserveKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TopkReserveKey(c)
}

type TopkReserveKey Base

func (c TopkReserveKey) Topk(topk int64) TopkReserveTopk {
	c.command.append(strconv.FormatInt(topk, 10))
	return TopkReserveTopk(c)
}

type TopkReserveParamsDecay Base

// Return Completed Redis command.
func (c TopkReserveParamsDecay) Build() Completed {
	return completed(c)
}

type TopkReserveParamsDepth Base

func (c TopkReserveParamsDepth) Decay(decay float64) TopkReserveParamsDecay {
	c.command.append(strconv.FormatFloat(decay, 'f', -1, 64))
	return TopkReserveParamsDecay(c)
}

type TopkReserveParamsWidth Base

func (c TopkReserveParamsWidth) Depth(depth int64) TopkReserveParamsDepth {
	c.command.append(strconv.FormatInt(depth, 10))
	return TopkReserveParamsDepth(c)
}

type TopkReserveTopk Base

func (c TopkReserveTopk) Width(width int64) TopkReserveParamsWidth {
	c.command.append(strconv.FormatInt(width, 10))
	return TopkReserveParamsWidth(c)
}

// Return Completed Redis command.
func (c TopkReserveTopk) Build() Completed {
	return completed(c)
}

// Alters the last access time of a key(s). Returns the number of existing keys specified..
//
// Time complexity: O(N) where N is the number of keys that will be touched.
type Touch Base

// Alters the last access time of a key(s). Returns the number of existing keys specified.
//
// Command: TOUCH.
//
// Time complexity: O(N) where N is the number of keys that will be touched.
func (b Builder) Touch() Touch {
	c := Touch{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("TOUCH")
	return c
}

func (c Touch) Key(key ...string) TouchKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return TouchKey(c)
}

type TouchKey Base

func (c TouchKey) Key(key ...string) TouchKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c TouchKey) Build() Completed {
	return completed(c)
}

// Append a new sample to the series. If the series has not been created yet with TS.CREATE it will be automatically created..
//
// Time complexity: O(M) when M is the amount of compaction rules or O(1) with no compaction
type TsAdd Base

// Append a new sample to the series. If the series has not been created yet with TS.CREATE it will be automatically created.
//
// Command: TS.ADD.
//
// Time complexity: O(M) when M is the amount of compaction rules or O(1) with no compaction
func (b Builder) TsAdd() TsAdd {
	c := TsAdd{command: emptyCommand(), cslot: b.slot}
	c.command.append("TS.ADD")
	return c
}

func (c TsAdd) Key(key string) TsAddKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TsAddKey(c)
}

type TsAddChunkSize Base

func (c TsAddChunkSize) OnDuplicateBlock() TsAddOnDuplicateBlock {
	c.ctags = ctagBlock
	c.command.append("ON_DUPLICATE", "BLOCK")
	return TsAddOnDuplicateBlock(c)
}

func (c TsAddChunkSize) OnDuplicateFirst() TsAddOnDuplicateFirst {
	c.command.append("ON_DUPLICATE", "FIRST")
	return TsAddOnDuplicateFirst(c)
}

func (c TsAddChunkSize) OnDuplicateLast() TsAddOnDuplicateLast {
	c.command.append("ON_DUPLICATE", "LAST")
	return TsAddOnDuplicateLast(c)
}

func (c TsAddChunkSize) OnDuplicateMin() TsAddOnDuplicateMin {
	c.command.append("ON_DUPLICATE", "MIN")
	return TsAddOnDuplicateMin(c)
}

func (c TsAddChunkSize) OnDuplicateMax() TsAddOnDuplicateMax {
	c.command.append("ON_DUPLICATE", "MAX")
	return TsAddOnDuplicateMax(c)
}

func (c TsAddChunkSize) OnDuplicateSum() TsAddOnDuplicateSum {
	c.command.append("ON_DUPLICATE", "SUM")
	return TsAddOnDuplicateSum(c)
}

func (c TsAddChunkSize) Labels() TsAddLabels {
	c.command.append("LABELS")
	return TsAddLabels(c)
}

// Return Completed Redis command.
func (c TsAddChunkSize) Build() Completed {
	return completed(c)
}

type TsAddEncodingCompressed Base

func (c TsAddEncodingCompressed) ChunkSize(size int64) TsAddChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsAddChunkSize(c)
}

func (c TsAddEncodingCompressed) OnDuplicateBlock() TsAddOnDuplicateBlock {
	c.ctags = ctagBlock
	c.command.append("ON_DUPLICATE", "BLOCK")
	return TsAddOnDuplicateBlock(c)
}

func (c TsAddEncodingCompressed) OnDuplicateFirst() TsAddOnDuplicateFirst {
	c.command.append("ON_DUPLICATE", "FIRST")
	return TsAddOnDuplicateFirst(c)
}

func (c TsAddEncodingCompressed) OnDuplicateLast() TsAddOnDuplicateLast {
	c.command.append("ON_DUPLICATE", "LAST")
	return TsAddOnDuplicateLast(c)
}

func (c TsAddEncodingCompressed) OnDuplicateMin() TsAddOnDuplicateMin {
	c.command.append("ON_DUPLICATE", "MIN")
	return TsAddOnDuplicateMin(c)
}

func (c TsAddEncodingCompressed) OnDuplicateMax() TsAddOnDuplicateMax {
	c.command.append("ON_DUPLICATE", "MAX")
	return TsAddOnDuplicateMax(c)
}

func (c TsAddEncodingCompressed) OnDuplicateSum() TsAddOnDuplicateSum {
	c.command.append("ON_DUPLICATE", "SUM")
	return TsAddOnDuplicateSum(c)
}

func (c TsAddEncodingCompressed) Labels() TsAddLabels {
	c.command.append("LABELS")
	return TsAddLabels(c)
}

// Return Completed Redis command.
func (c TsAddEncodingCompressed) Build() Completed {
	return completed(c)
}

type TsAddEncodingUncompressed Base

func (c TsAddEncodingUncompressed) ChunkSize(size int64) TsAddChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsAddChunkSize(c)
}

func (c TsAddEncodingUncompressed) OnDuplicateBlock() TsAddOnDuplicateBlock {
	c.ctags = ctagBlock
	c.command.append("ON_DUPLICATE", "BLOCK")
	return TsAddOnDuplicateBlock(c)
}

func (c TsAddEncodingUncompressed) OnDuplicateFirst() TsAddOnDuplicateFirst {
	c.command.append("ON_DUPLICATE", "FIRST")
	return TsAddOnDuplicateFirst(c)
}

func (c TsAddEncodingUncompressed) OnDuplicateLast() TsAddOnDuplicateLast {
	c.command.append("ON_DUPLICATE", "LAST")
	return TsAddOnDuplicateLast(c)
}

func (c TsAddEncodingUncompressed) OnDuplicateMin() TsAddOnDuplicateMin {
	c.command.append("ON_DUPLICATE", "MIN")
	return TsAddOnDuplicateMin(c)
}

func (c TsAddEncodingUncompressed) OnDuplicateMax() TsAddOnDuplicateMax {
	c.command.append("ON_DUPLICATE", "MAX")
	return TsAddOnDuplicateMax(c)
}

func (c TsAddEncodingUncompressed) OnDuplicateSum() TsAddOnDuplicateSum {
	c.command.append("ON_DUPLICATE", "SUM")
	return TsAddOnDuplicateSum(c)
}

func (c TsAddEncodingUncompressed) Labels() TsAddLabels {
	c.command.append("LABELS")
	return TsAddLabels(c)
}

// Return Completed Redis command.
func (c TsAddEncodingUncompressed) Build() Completed {
	return completed(c)
}

type TsAddKey Base

func (c TsAddKey) Timestamp(timestamp int64) TsAddTimestamp {
	c.command.append(strconv.FormatInt(timestamp, 10))
	return TsAddTimestamp(c)
}

type TsAddLabels Base

func (c TsAddLabels) Labels(label string, value string) TsAddLabels {
	c.command.append(label, value)
	return c
}

// Return Completed Redis command.
func (c TsAddLabels) Build() Completed {
	return completed(c)
}

type TsAddOnDuplicateBlock Base

func (c TsAddOnDuplicateBlock) Labels() TsAddLabels {
	c.command.append("LABELS")
	return TsAddLabels(c)
}

// Return Completed Redis command.
func (c TsAddOnDuplicateBlock) Build() Completed {
	return completed(c)
}

type TsAddOnDuplicateFirst Base

func (c TsAddOnDuplicateFirst) Labels() TsAddLabels {
	c.command.append("LABELS")
	return TsAddLabels(c)
}

// Return Completed Redis command.
func (c TsAddOnDuplicateFirst) Build() Completed {
	return completed(c)
}

type TsAddOnDuplicateLast Base

func (c TsAddOnDuplicateLast) Labels() TsAddLabels {
	c.command.append("LABELS")
	return TsAddLabels(c)
}

// Return Completed Redis command.
func (c TsAddOnDuplicateLast) Build() Completed {
	return completed(c)
}

type TsAddOnDuplicateMax Base

func (c TsAddOnDuplicateMax) Labels() TsAddLabels {
	c.command.append("LABELS")
	return TsAddLabels(c)
}

// Return Completed Redis command.
func (c TsAddOnDuplicateMax) Build() Completed {
	return completed(c)
}

type TsAddOnDuplicateMin Base

func (c TsAddOnDuplicateMin) Labels() TsAddLabels {
	c.command.append("LABELS")
	return TsAddLabels(c)
}

// Return Completed Redis command.
func (c TsAddOnDuplicateMin) Build() Completed {
	return completed(c)
}

type TsAddOnDuplicateSum Base

func (c TsAddOnDuplicateSum) Labels() TsAddLabels {
	c.command.append("LABELS")
	return TsAddLabels(c)
}

// Return Completed Redis command.
func (c TsAddOnDuplicateSum) Build() Completed {
	return completed(c)
}

type TsAddRetention Base

func (c TsAddRetention) EncodingUncompressed() TsAddEncodingUncompressed {
	c.command.append("ENCODING", "UNCOMPRESSED")
	return TsAddEncodingUncompressed(c)
}

func (c TsAddRetention) EncodingCompressed() TsAddEncodingCompressed {
	c.command.append("ENCODING", "COMPRESSED")
	return TsAddEncodingCompressed(c)
}

func (c TsAddRetention) ChunkSize(size int64) TsAddChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsAddChunkSize(c)
}

func (c TsAddRetention) OnDuplicateBlock() TsAddOnDuplicateBlock {
	c.ctags = ctagBlock
	c.command.append("ON_DUPLICATE", "BLOCK")
	return TsAddOnDuplicateBlock(c)
}

func (c TsAddRetention) OnDuplicateFirst() TsAddOnDuplicateFirst {
	c.command.append("ON_DUPLICATE", "FIRST")
	return TsAddOnDuplicateFirst(c)
}

func (c TsAddRetention) OnDuplicateLast() TsAddOnDuplicateLast {
	c.command.append("ON_DUPLICATE", "LAST")
	return TsAddOnDuplicateLast(c)
}

func (c TsAddRetention) OnDuplicateMin() TsAddOnDuplicateMin {
	c.command.append("ON_DUPLICATE", "MIN")
	return TsAddOnDuplicateMin(c)
}

func (c TsAddRetention) OnDuplicateMax() TsAddOnDuplicateMax {
	c.command.append("ON_DUPLICATE", "MAX")
	return TsAddOnDuplicateMax(c)
}

func (c TsAddRetention) OnDuplicateSum() TsAddOnDuplicateSum {
	c.command.append("ON_DUPLICATE", "SUM")
	return TsAddOnDuplicateSum(c)
}

func (c TsAddRetention) Labels() TsAddLabels {
	c.command.append("LABELS")
	return TsAddLabels(c)
}

// Return Completed Redis command.
func (c TsAddRetention) Build() Completed {
	return completed(c)
}

type TsAddTimestamp Base

func (c TsAddTimestamp) Value(value float64) TsAddValue {
	c.command.append(strconv.FormatFloat(value, 'f', -1, 64))
	return TsAddValue(c)
}

type TsAddValue Base

func (c TsAddValue) Retention(retentionperiod int64) TsAddRetention {
	c.command.append("RETENTION", strconv.FormatInt(retentionperiod, 10))
	return TsAddRetention(c)
}

func (c TsAddValue) EncodingUncompressed() TsAddEncodingUncompressed {
	c.command.append("ENCODING", "UNCOMPRESSED")
	return TsAddEncodingUncompressed(c)
}

func (c TsAddValue) EncodingCompressed() TsAddEncodingCompressed {
	c.command.append("ENCODING", "COMPRESSED")
	return TsAddEncodingCompressed(c)
}

func (c TsAddValue) ChunkSize(size int64) TsAddChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsAddChunkSize(c)
}

func (c TsAddValue) OnDuplicateBlock() TsAddOnDuplicateBlock {
	c.ctags = ctagBlock
	c.command.append("ON_DUPLICATE", "BLOCK")
	return TsAddOnDuplicateBlock(c)
}

func (c TsAddValue) OnDuplicateFirst() TsAddOnDuplicateFirst {
	c.command.append("ON_DUPLICATE", "FIRST")
	return TsAddOnDuplicateFirst(c)
}

func (c TsAddValue) OnDuplicateLast() TsAddOnDuplicateLast {
	c.command.append("ON_DUPLICATE", "LAST")
	return TsAddOnDuplicateLast(c)
}

func (c TsAddValue) OnDuplicateMin() TsAddOnDuplicateMin {
	c.command.append("ON_DUPLICATE", "MIN")
	return TsAddOnDuplicateMin(c)
}

func (c TsAddValue) OnDuplicateMax() TsAddOnDuplicateMax {
	c.command.append("ON_DUPLICATE", "MAX")
	return TsAddOnDuplicateMax(c)
}

func (c TsAddValue) OnDuplicateSum() TsAddOnDuplicateSum {
	c.command.append("ON_DUPLICATE", "SUM")
	return TsAddOnDuplicateSum(c)
}

func (c TsAddValue) Labels() TsAddLabels {
	c.command.append("LABELS")
	return TsAddLabels(c)
}

// Return Completed Redis command.
func (c TsAddValue) Build() Completed {
	return completed(c)
}

// Update the retention, labels of an existing key.
//
// Time complexity: O(N) where N is the number of labels requested to update
type TsAlter Base

// Update the retention, labels of an existing key
//
// Command: TS.ALTER.
//
// Time complexity: O(N) where N is the number of labels requested to update
func (b Builder) TsAlter() TsAlter {
	c := TsAlter{command: emptyCommand(), cslot: b.slot}
	c.command.append("TS.ALTER")
	return c
}

func (c TsAlter) Key(key string) TsAlterKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TsAlterKey(c)
}

type TsAlterChunkSize Base

func (c TsAlterChunkSize) DuplicatePolicyBlock() TsAlterDuplicatePolicyBlock {
	c.ctags = ctagBlock
	c.command.append("DUPLICATE_POLICY", "BLOCK")
	return TsAlterDuplicatePolicyBlock(c)
}

func (c TsAlterChunkSize) DuplicatePolicyFirst() TsAlterDuplicatePolicyFirst {
	c.command.append("DUPLICATE_POLICY", "FIRST")
	return TsAlterDuplicatePolicyFirst(c)
}

func (c TsAlterChunkSize) DuplicatePolicyLast() TsAlterDuplicatePolicyLast {
	c.command.append("DUPLICATE_POLICY", "LAST")
	return TsAlterDuplicatePolicyLast(c)
}

func (c TsAlterChunkSize) DuplicatePolicyMin() TsAlterDuplicatePolicyMin {
	c.command.append("DUPLICATE_POLICY", "MIN")
	return TsAlterDuplicatePolicyMin(c)
}

func (c TsAlterChunkSize) DuplicatePolicyMax() TsAlterDuplicatePolicyMax {
	c.command.append("DUPLICATE_POLICY", "MAX")
	return TsAlterDuplicatePolicyMax(c)
}

func (c TsAlterChunkSize) DuplicatePolicySum() TsAlterDuplicatePolicySum {
	c.command.append("DUPLICATE_POLICY", "SUM")
	return TsAlterDuplicatePolicySum(c)
}

func (c TsAlterChunkSize) Labels() TsAlterLabels {
	c.command.append("LABELS")
	return TsAlterLabels(c)
}

// Return Completed Redis command.
func (c TsAlterChunkSize) Build() Completed {
	return completed(c)
}

type TsAlterDuplicatePolicyBlock Base

func (c TsAlterDuplicatePolicyBlock) Labels() TsAlterLabels {
	c.command.append("LABELS")
	return TsAlterLabels(c)
}

// Return Completed Redis command.
func (c TsAlterDuplicatePolicyBlock) Build() Completed {
	return completed(c)
}

type TsAlterDuplicatePolicyFirst Base

func (c TsAlterDuplicatePolicyFirst) Labels() TsAlterLabels {
	c.command.append("LABELS")
	return TsAlterLabels(c)
}

// Return Completed Redis command.
func (c TsAlterDuplicatePolicyFirst) Build() Completed {
	return completed(c)
}

type TsAlterDuplicatePolicyLast Base

func (c TsAlterDuplicatePolicyLast) Labels() TsAlterLabels {
	c.command.append("LABELS")
	return TsAlterLabels(c)
}

// Return Completed Redis command.
func (c TsAlterDuplicatePolicyLast) Build() Completed {
	return completed(c)
}

type TsAlterDuplicatePolicyMax Base

func (c TsAlterDuplicatePolicyMax) Labels() TsAlterLabels {
	c.command.append("LABELS")
	return TsAlterLabels(c)
}

// Return Completed Redis command.
func (c TsAlterDuplicatePolicyMax) Build() Completed {
	return completed(c)
}

type TsAlterDuplicatePolicyMin Base

func (c TsAlterDuplicatePolicyMin) Labels() TsAlterLabels {
	c.command.append("LABELS")
	return TsAlterLabels(c)
}

// Return Completed Redis command.
func (c TsAlterDuplicatePolicyMin) Build() Completed {
	return completed(c)
}

type TsAlterDuplicatePolicySum Base

func (c TsAlterDuplicatePolicySum) Labels() TsAlterLabels {
	c.command.append("LABELS")
	return TsAlterLabels(c)
}

// Return Completed Redis command.
func (c TsAlterDuplicatePolicySum) Build() Completed {
	return completed(c)
}

type TsAlterKey Base

func (c TsAlterKey) Retention(retentionperiod int64) TsAlterRetention {
	c.command.append("RETENTION", strconv.FormatInt(retentionperiod, 10))
	return TsAlterRetention(c)
}

func (c TsAlterKey) ChunkSize(size int64) TsAlterChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsAlterChunkSize(c)
}

func (c TsAlterKey) DuplicatePolicyBlock() TsAlterDuplicatePolicyBlock {
	c.ctags = ctagBlock
	c.command.append("DUPLICATE_POLICY", "BLOCK")
	return TsAlterDuplicatePolicyBlock(c)
}

func (c TsAlterKey) DuplicatePolicyFirst() TsAlterDuplicatePolicyFirst {
	c.command.append("DUPLICATE_POLICY", "FIRST")
	return TsAlterDuplicatePolicyFirst(c)
}

func (c TsAlterKey) DuplicatePolicyLast() TsAlterDuplicatePolicyLast {
	c.command.append("DUPLICATE_POLICY", "LAST")
	return TsAlterDuplicatePolicyLast(c)
}

func (c TsAlterKey) DuplicatePolicyMin() TsAlterDuplicatePolicyMin {
	c.command.append("DUPLICATE_POLICY", "MIN")
	return TsAlterDuplicatePolicyMin(c)
}

func (c TsAlterKey) DuplicatePolicyMax() TsAlterDuplicatePolicyMax {
	c.command.append("DUPLICATE_POLICY", "MAX")
	return TsAlterDuplicatePolicyMax(c)
}

func (c TsAlterKey) DuplicatePolicySum() TsAlterDuplicatePolicySum {
	c.command.append("DUPLICATE_POLICY", "SUM")
	return TsAlterDuplicatePolicySum(c)
}

func (c TsAlterKey) Labels() TsAlterLabels {
	c.command.append("LABELS")
	return TsAlterLabels(c)
}

// Return Completed Redis command.
func (c TsAlterKey) Build() Completed {
	return completed(c)
}

type TsAlterLabels Base

func (c TsAlterLabels) Labels(label string, value string) TsAlterLabels {
	c.command.append(label, value)
	return c
}

// Return Completed Redis command.
func (c TsAlterLabels) Build() Completed {
	return completed(c)
}

type TsAlterRetention Base

func (c TsAlterRetention) ChunkSize(size int64) TsAlterChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsAlterChunkSize(c)
}

func (c TsAlterRetention) DuplicatePolicyBlock() TsAlterDuplicatePolicyBlock {
	c.ctags = ctagBlock
	c.command.append("DUPLICATE_POLICY", "BLOCK")
	return TsAlterDuplicatePolicyBlock(c)
}

func (c TsAlterRetention) DuplicatePolicyFirst() TsAlterDuplicatePolicyFirst {
	c.command.append("DUPLICATE_POLICY", "FIRST")
	return TsAlterDuplicatePolicyFirst(c)
}

func (c TsAlterRetention) DuplicatePolicyLast() TsAlterDuplicatePolicyLast {
	c.command.append("DUPLICATE_POLICY", "LAST")
	return TsAlterDuplicatePolicyLast(c)
}

func (c TsAlterRetention) DuplicatePolicyMin() TsAlterDuplicatePolicyMin {
	c.command.append("DUPLICATE_POLICY", "MIN")
	return TsAlterDuplicatePolicyMin(c)
}

func (c TsAlterRetention) DuplicatePolicyMax() TsAlterDuplicatePolicyMax {
	c.command.append("DUPLICATE_POLICY", "MAX")
	return TsAlterDuplicatePolicyMax(c)
}

func (c TsAlterRetention) DuplicatePolicySum() TsAlterDuplicatePolicySum {
	c.command.append("DUPLICATE_POLICY", "SUM")
	return TsAlterDuplicatePolicySum(c)
}

func (c TsAlterRetention) Labels() TsAlterLabels {
	c.command.append("LABELS")
	return TsAlterLabels(c)
}

// Return Completed Redis command.
func (c TsAlterRetention) Build() Completed {
	return completed(c)
}

// Create a new time-series.
//
// Time complexity: O(1)
type TsCreate Base

// Create a new time-series
//
// Command: TS.CREATE.
//
// Time complexity: O(1)
func (b Builder) TsCreate() TsCreate {
	c := TsCreate{command: emptyCommand(), cslot: b.slot}
	c.command.append("TS.CREATE")
	return c
}

func (c TsCreate) Key(key string) TsCreateKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TsCreateKey(c)
}

type TsCreateChunkSize Base

func (c TsCreateChunkSize) DuplicatePolicyBlock() TsCreateDuplicatePolicyBlock {
	c.ctags = ctagBlock
	c.command.append("DUPLICATE_POLICY", "BLOCK")
	return TsCreateDuplicatePolicyBlock(c)
}

func (c TsCreateChunkSize) DuplicatePolicyFirst() TsCreateDuplicatePolicyFirst {
	c.command.append("DUPLICATE_POLICY", "FIRST")
	return TsCreateDuplicatePolicyFirst(c)
}

func (c TsCreateChunkSize) DuplicatePolicyLast() TsCreateDuplicatePolicyLast {
	c.command.append("DUPLICATE_POLICY", "LAST")
	return TsCreateDuplicatePolicyLast(c)
}

func (c TsCreateChunkSize) DuplicatePolicyMin() TsCreateDuplicatePolicyMin {
	c.command.append("DUPLICATE_POLICY", "MIN")
	return TsCreateDuplicatePolicyMin(c)
}

func (c TsCreateChunkSize) DuplicatePolicyMax() TsCreateDuplicatePolicyMax {
	c.command.append("DUPLICATE_POLICY", "MAX")
	return TsCreateDuplicatePolicyMax(c)
}

func (c TsCreateChunkSize) DuplicatePolicySum() TsCreateDuplicatePolicySum {
	c.command.append("DUPLICATE_POLICY", "SUM")
	return TsCreateDuplicatePolicySum(c)
}

func (c TsCreateChunkSize) Labels() TsCreateLabels {
	c.command.append("LABELS")
	return TsCreateLabels(c)
}

// Return Completed Redis command.
func (c TsCreateChunkSize) Build() Completed {
	return completed(c)
}

type TsCreateDuplicatePolicyBlock Base

func (c TsCreateDuplicatePolicyBlock) Labels() TsCreateLabels {
	c.command.append("LABELS")
	return TsCreateLabels(c)
}

// Return Completed Redis command.
func (c TsCreateDuplicatePolicyBlock) Build() Completed {
	return completed(c)
}

type TsCreateDuplicatePolicyFirst Base

func (c TsCreateDuplicatePolicyFirst) Labels() TsCreateLabels {
	c.command.append("LABELS")
	return TsCreateLabels(c)
}

// Return Completed Redis command.
func (c TsCreateDuplicatePolicyFirst) Build() Completed {
	return completed(c)
}

type TsCreateDuplicatePolicyLast Base

func (c TsCreateDuplicatePolicyLast) Labels() TsCreateLabels {
	c.command.append("LABELS")
	return TsCreateLabels(c)
}

// Return Completed Redis command.
func (c TsCreateDuplicatePolicyLast) Build() Completed {
	return completed(c)
}

type TsCreateDuplicatePolicyMax Base

func (c TsCreateDuplicatePolicyMax) Labels() TsCreateLabels {
	c.command.append("LABELS")
	return TsCreateLabels(c)
}

// Return Completed Redis command.
func (c TsCreateDuplicatePolicyMax) Build() Completed {
	return completed(c)
}

type TsCreateDuplicatePolicyMin Base

func (c TsCreateDuplicatePolicyMin) Labels() TsCreateLabels {
	c.command.append("LABELS")
	return TsCreateLabels(c)
}

// Return Completed Redis command.
func (c TsCreateDuplicatePolicyMin) Build() Completed {
	return completed(c)
}

type TsCreateDuplicatePolicySum Base

func (c TsCreateDuplicatePolicySum) Labels() TsCreateLabels {
	c.command.append("LABELS")
	return TsCreateLabels(c)
}

// Return Completed Redis command.
func (c TsCreateDuplicatePolicySum) Build() Completed {
	return completed(c)
}

type TsCreateEncodingCompressed Base

func (c TsCreateEncodingCompressed) ChunkSize(size int64) TsCreateChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsCreateChunkSize(c)
}

func (c TsCreateEncodingCompressed) DuplicatePolicyBlock() TsCreateDuplicatePolicyBlock {
	c.ctags = ctagBlock
	c.command.append("DUPLICATE_POLICY", "BLOCK")
	return TsCreateDuplicatePolicyBlock(c)
}

func (c TsCreateEncodingCompressed) DuplicatePolicyFirst() TsCreateDuplicatePolicyFirst {
	c.command.append("DUPLICATE_POLICY", "FIRST")
	return TsCreateDuplicatePolicyFirst(c)
}

func (c TsCreateEncodingCompressed) DuplicatePolicyLast() TsCreateDuplicatePolicyLast {
	c.command.append("DUPLICATE_POLICY", "LAST")
	return TsCreateDuplicatePolicyLast(c)
}

func (c TsCreateEncodingCompressed) DuplicatePolicyMin() TsCreateDuplicatePolicyMin {
	c.command.append("DUPLICATE_POLICY", "MIN")
	return TsCreateDuplicatePolicyMin(c)
}

func (c TsCreateEncodingCompressed) DuplicatePolicyMax() TsCreateDuplicatePolicyMax {
	c.command.append("DUPLICATE_POLICY", "MAX")
	return TsCreateDuplicatePolicyMax(c)
}

func (c TsCreateEncodingCompressed) DuplicatePolicySum() TsCreateDuplicatePolicySum {
	c.command.append("DUPLICATE_POLICY", "SUM")
	return TsCreateDuplicatePolicySum(c)
}

func (c TsCreateEncodingCompressed) Labels() TsCreateLabels {
	c.command.append("LABELS")
	return TsCreateLabels(c)
}

// Return Completed Redis command.
func (c TsCreateEncodingCompressed) Build() Completed {
	return completed(c)
}

type TsCreateEncodingUncompressed Base

func (c TsCreateEncodingUncompressed) ChunkSize(size int64) TsCreateChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsCreateChunkSize(c)
}

func (c TsCreateEncodingUncompressed) DuplicatePolicyBlock() TsCreateDuplicatePolicyBlock {
	c.ctags = ctagBlock
	c.command.append("DUPLICATE_POLICY", "BLOCK")
	return TsCreateDuplicatePolicyBlock(c)
}

func (c TsCreateEncodingUncompressed) DuplicatePolicyFirst() TsCreateDuplicatePolicyFirst {
	c.command.append("DUPLICATE_POLICY", "FIRST")
	return TsCreateDuplicatePolicyFirst(c)
}

func (c TsCreateEncodingUncompressed) DuplicatePolicyLast() TsCreateDuplicatePolicyLast {
	c.command.append("DUPLICATE_POLICY", "LAST")
	return TsCreateDuplicatePolicyLast(c)
}

func (c TsCreateEncodingUncompressed) DuplicatePolicyMin() TsCreateDuplicatePolicyMin {
	c.command.append("DUPLICATE_POLICY", "MIN")
	return TsCreateDuplicatePolicyMin(c)
}

func (c TsCreateEncodingUncompressed) DuplicatePolicyMax() TsCreateDuplicatePolicyMax {
	c.command.append("DUPLICATE_POLICY", "MAX")
	return TsCreateDuplicatePolicyMax(c)
}

func (c TsCreateEncodingUncompressed) DuplicatePolicySum() TsCreateDuplicatePolicySum {
	c.command.append("DUPLICATE_POLICY", "SUM")
	return TsCreateDuplicatePolicySum(c)
}

func (c TsCreateEncodingUncompressed) Labels() TsCreateLabels {
	c.command.append("LABELS")
	return TsCreateLabels(c)
}

// Return Completed Redis command.
func (c TsCreateEncodingUncompressed) Build() Completed {
	return completed(c)
}

type TsCreateKey Base

func (c TsCreateKey) Retention(retentionperiod int64) TsCreateRetention {
	c.command.append("RETENTION", strconv.FormatInt(retentionperiod, 10))
	return TsCreateRetention(c)
}

func (c TsCreateKey) EncodingUncompressed() TsCreateEncodingUncompressed {
	c.command.append("ENCODING", "UNCOMPRESSED")
	return TsCreateEncodingUncompressed(c)
}

func (c TsCreateKey) EncodingCompressed() TsCreateEncodingCompressed {
	c.command.append("ENCODING", "COMPRESSED")
	return TsCreateEncodingCompressed(c)
}

func (c TsCreateKey) ChunkSize(size int64) TsCreateChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsCreateChunkSize(c)
}

func (c TsCreateKey) DuplicatePolicyBlock() TsCreateDuplicatePolicyBlock {
	c.ctags = ctagBlock
	c.command.append("DUPLICATE_POLICY", "BLOCK")
	return TsCreateDuplicatePolicyBlock(c)
}

func (c TsCreateKey) DuplicatePolicyFirst() TsCreateDuplicatePolicyFirst {
	c.command.append("DUPLICATE_POLICY", "FIRST")
	return TsCreateDuplicatePolicyFirst(c)
}

func (c TsCreateKey) DuplicatePolicyLast() TsCreateDuplicatePolicyLast {
	c.command.append("DUPLICATE_POLICY", "LAST")
	return TsCreateDuplicatePolicyLast(c)
}

func (c TsCreateKey) DuplicatePolicyMin() TsCreateDuplicatePolicyMin {
	c.command.append("DUPLICATE_POLICY", "MIN")
	return TsCreateDuplicatePolicyMin(c)
}

func (c TsCreateKey) DuplicatePolicyMax() TsCreateDuplicatePolicyMax {
	c.command.append("DUPLICATE_POLICY", "MAX")
	return TsCreateDuplicatePolicyMax(c)
}

func (c TsCreateKey) DuplicatePolicySum() TsCreateDuplicatePolicySum {
	c.command.append("DUPLICATE_POLICY", "SUM")
	return TsCreateDuplicatePolicySum(c)
}

func (c TsCreateKey) Labels() TsCreateLabels {
	c.command.append("LABELS")
	return TsCreateLabels(c)
}

// Return Completed Redis command.
func (c TsCreateKey) Build() Completed {
	return completed(c)
}

type TsCreateLabels Base

func (c TsCreateLabels) Labels(label string, value string) TsCreateLabels {
	c.command.append(label, value)
	return c
}

// Return Completed Redis command.
func (c TsCreateLabels) Build() Completed {
	return completed(c)
}

type TsCreateRetention Base

func (c TsCreateRetention) EncodingUncompressed() TsCreateEncodingUncompressed {
	c.command.append("ENCODING", "UNCOMPRESSED")
	return TsCreateEncodingUncompressed(c)
}

func (c TsCreateRetention) EncodingCompressed() TsCreateEncodingCompressed {
	c.command.append("ENCODING", "COMPRESSED")
	return TsCreateEncodingCompressed(c)
}

func (c TsCreateRetention) ChunkSize(size int64) TsCreateChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsCreateChunkSize(c)
}

func (c TsCreateRetention) DuplicatePolicyBlock() TsCreateDuplicatePolicyBlock {
	c.ctags = ctagBlock
	c.command.append("DUPLICATE_POLICY", "BLOCK")
	return TsCreateDuplicatePolicyBlock(c)
}

func (c TsCreateRetention) DuplicatePolicyFirst() TsCreateDuplicatePolicyFirst {
	c.command.append("DUPLICATE_POLICY", "FIRST")
	return TsCreateDuplicatePolicyFirst(c)
}

func (c TsCreateRetention) DuplicatePolicyLast() TsCreateDuplicatePolicyLast {
	c.command.append("DUPLICATE_POLICY", "LAST")
	return TsCreateDuplicatePolicyLast(c)
}

func (c TsCreateRetention) DuplicatePolicyMin() TsCreateDuplicatePolicyMin {
	c.command.append("DUPLICATE_POLICY", "MIN")
	return TsCreateDuplicatePolicyMin(c)
}

func (c TsCreateRetention) DuplicatePolicyMax() TsCreateDuplicatePolicyMax {
	c.command.append("DUPLICATE_POLICY", "MAX")
	return TsCreateDuplicatePolicyMax(c)
}

func (c TsCreateRetention) DuplicatePolicySum() TsCreateDuplicatePolicySum {
	c.command.append("DUPLICATE_POLICY", "SUM")
	return TsCreateDuplicatePolicySum(c)
}

func (c TsCreateRetention) Labels() TsCreateLabels {
	c.command.append("LABELS")
	return TsCreateLabels(c)
}

// Return Completed Redis command.
func (c TsCreateRetention) Build() Completed {
	return completed(c)
}

// Create a compaction rule.
//
// Time complexity: O(1)
type TsCreaterule Base

// Create a compaction rule
//
// Command: TS.CREATERULE.
//
// Time complexity: O(1)
func (b Builder) TsCreaterule() TsCreaterule {
	c := TsCreaterule{command: emptyCommand(), cslot: b.slot}
	c.command.append("TS.CREATERULE")
	return c
}

func (c TsCreaterule) Sourcekey(sourcekey string) TsCreateruleSourcekey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(sourcekey)
	} else {
		c.cslot.set(getSlot(sourcekey))
	}
	c.command.append(sourcekey)
	return TsCreateruleSourcekey(c)
}

type TsCreateruleAggregationAvg Base

func (c TsCreateruleAggregationAvg) Bucketduration(bucketduration int64) TsCreateruleBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsCreateruleBucketduration(c)
}

type TsCreateruleAggregationCount Base

func (c TsCreateruleAggregationCount) Bucketduration(bucketduration int64) TsCreateruleBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsCreateruleBucketduration(c)
}

type TsCreateruleAggregationFirst Base

func (c TsCreateruleAggregationFirst) Bucketduration(bucketduration int64) TsCreateruleBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsCreateruleBucketduration(c)
}

type TsCreateruleAggregationLast Base

func (c TsCreateruleAggregationLast) Bucketduration(bucketduration int64) TsCreateruleBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsCreateruleBucketduration(c)
}

type TsCreateruleAggregationMax Base

func (c TsCreateruleAggregationMax) Bucketduration(bucketduration int64) TsCreateruleBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsCreateruleBucketduration(c)
}

type TsCreateruleAggregationMin Base

func (c TsCreateruleAggregationMin) Bucketduration(bucketduration int64) TsCreateruleBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsCreateruleBucketduration(c)
}

type TsCreateruleAggregationRange Base

func (c TsCreateruleAggregationRange) Bucketduration(bucketduration int64) TsCreateruleBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsCreateruleBucketduration(c)
}

type TsCreateruleAggregationStdP Base

func (c TsCreateruleAggregationStdP) Bucketduration(bucketduration int64) TsCreateruleBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsCreateruleBucketduration(c)
}

type TsCreateruleAggregationStdS Base

func (c TsCreateruleAggregationStdS) Bucketduration(bucketduration int64) TsCreateruleBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsCreateruleBucketduration(c)
}

type TsCreateruleAggregationSum Base

func (c TsCreateruleAggregationSum) Bucketduration(bucketduration int64) TsCreateruleBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsCreateruleBucketduration(c)
}

type TsCreateruleAggregationTwa Base

func (c TsCreateruleAggregationTwa) Bucketduration(bucketduration int64) TsCreateruleBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsCreateruleBucketduration(c)
}

type TsCreateruleAggregationVarP Base

func (c TsCreateruleAggregationVarP) Bucketduration(bucketduration int64) TsCreateruleBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsCreateruleBucketduration(c)
}

type TsCreateruleAggregationVarS Base

func (c TsCreateruleAggregationVarS) Bucketduration(bucketduration int64) TsCreateruleBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsCreateruleBucketduration(c)
}

type TsCreateruleAligntimestamp Base

// Return Completed Redis command.
func (c TsCreateruleAligntimestamp) Build() Completed {
	return completed(c)
}

type TsCreateruleBucketduration Base

func (c TsCreateruleBucketduration) Aligntimestamp(aligntimestamp int64) TsCreateruleAligntimestamp {
	c.command.append(strconv.FormatInt(aligntimestamp, 10))
	return TsCreateruleAligntimestamp(c)
}

// Return Completed Redis command.
func (c TsCreateruleBucketduration) Build() Completed {
	return completed(c)
}

type TsCreateruleDestkey Base

func (c TsCreateruleDestkey) AggregationAvg() TsCreateruleAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsCreateruleAggregationAvg(c)
}

func (c TsCreateruleDestkey) AggregationSum() TsCreateruleAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsCreateruleAggregationSum(c)
}

func (c TsCreateruleDestkey) AggregationMin() TsCreateruleAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsCreateruleAggregationMin(c)
}

func (c TsCreateruleDestkey) AggregationMax() TsCreateruleAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsCreateruleAggregationMax(c)
}

func (c TsCreateruleDestkey) AggregationRange() TsCreateruleAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsCreateruleAggregationRange(c)
}

func (c TsCreateruleDestkey) AggregationCount() TsCreateruleAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsCreateruleAggregationCount(c)
}

func (c TsCreateruleDestkey) AggregationFirst() TsCreateruleAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsCreateruleAggregationFirst(c)
}

func (c TsCreateruleDestkey) AggregationLast() TsCreateruleAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsCreateruleAggregationLast(c)
}

func (c TsCreateruleDestkey) AggregationStdP() TsCreateruleAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsCreateruleAggregationStdP(c)
}

func (c TsCreateruleDestkey) AggregationStdS() TsCreateruleAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsCreateruleAggregationStdS(c)
}

func (c TsCreateruleDestkey) AggregationVarP() TsCreateruleAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsCreateruleAggregationVarP(c)
}

func (c TsCreateruleDestkey) AggregationVarS() TsCreateruleAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsCreateruleAggregationVarS(c)
}

func (c TsCreateruleDestkey) AggregationTwa() TsCreateruleAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsCreateruleAggregationTwa(c)
}

type TsCreateruleSourcekey Base

func (c TsCreateruleSourcekey) Destkey(destkey string) TsCreateruleDestkey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destkey)
	} else {
		c.cslot.set(getSlot(destkey))
	}
	c.command.append(destkey)
	return TsCreateruleDestkey(c)
}

// Creates a new sample that decrements the latest sample's value.
//
// Time complexity: O(M) when M is the amount of compaction rules or O(1) with no compaction
type TsDecrby Base

// Creates a new sample that decrements the latest sample's value
//
// Command: TS.DECRBY.
//
// Time complexity: O(M) when M is the amount of compaction rules or O(1) with no compaction
func (b Builder) TsDecrby() TsDecrby {
	c := TsDecrby{command: emptyCommand(), cslot: b.slot}
	c.command.append("TS.DECRBY")
	return c
}

func (c TsDecrby) Key(key string) TsDecrbyKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TsDecrbyKey(c)
}

type TsDecrbyChunkSize Base

func (c TsDecrbyChunkSize) Labels() TsDecrbyLabels {
	c.command.append("LABELS")
	return TsDecrbyLabels(c)
}

// Return Completed Redis command.
func (c TsDecrbyChunkSize) Build() Completed {
	return completed(c)
}

type TsDecrbyKey Base

func (c TsDecrbyKey) Value(value float64) TsDecrbyValue {
	c.command.append(strconv.FormatFloat(value, 'f', -1, 64))
	return TsDecrbyValue(c)
}

type TsDecrbyLabels Base

func (c TsDecrbyLabels) Labels(label string, value string) TsDecrbyLabels {
	c.command.append(label, value)
	return c
}

// Return Completed Redis command.
func (c TsDecrbyLabels) Build() Completed {
	return completed(c)
}

type TsDecrbyRetention Base

func (c TsDecrbyRetention) Uncompressed() TsDecrbyUncompressed {
	c.command.append("UNCOMPRESSED")
	return TsDecrbyUncompressed(c)
}

func (c TsDecrbyRetention) ChunkSize(size int64) TsDecrbyChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsDecrbyChunkSize(c)
}

func (c TsDecrbyRetention) Labels() TsDecrbyLabels {
	c.command.append("LABELS")
	return TsDecrbyLabels(c)
}

// Return Completed Redis command.
func (c TsDecrbyRetention) Build() Completed {
	return completed(c)
}

type TsDecrbyTimestamp Base

func (c TsDecrbyTimestamp) Retention(retentionperiod int64) TsDecrbyRetention {
	c.command.append("RETENTION", strconv.FormatInt(retentionperiod, 10))
	return TsDecrbyRetention(c)
}

func (c TsDecrbyTimestamp) Uncompressed() TsDecrbyUncompressed {
	c.command.append("UNCOMPRESSED")
	return TsDecrbyUncompressed(c)
}

func (c TsDecrbyTimestamp) ChunkSize(size int64) TsDecrbyChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsDecrbyChunkSize(c)
}

func (c TsDecrbyTimestamp) Labels() TsDecrbyLabels {
	c.command.append("LABELS")
	return TsDecrbyLabels(c)
}

// Return Completed Redis command.
func (c TsDecrbyTimestamp) Build() Completed {
	return completed(c)
}

type TsDecrbyUncompressed Base

func (c TsDecrbyUncompressed) ChunkSize(size int64) TsDecrbyChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsDecrbyChunkSize(c)
}

func (c TsDecrbyUncompressed) Labels() TsDecrbyLabels {
	c.command.append("LABELS")
	return TsDecrbyLabels(c)
}

// Return Completed Redis command.
func (c TsDecrbyUncompressed) Build() Completed {
	return completed(c)
}

type TsDecrbyValue Base

func (c TsDecrbyValue) Timestamp(timestamp int64) TsDecrbyTimestamp {
	c.command.append("TIMESTAMP", strconv.FormatInt(timestamp, 10))
	return TsDecrbyTimestamp(c)
}

func (c TsDecrbyValue) Retention(retentionperiod int64) TsDecrbyRetention {
	c.command.append("RETENTION", strconv.FormatInt(retentionperiod, 10))
	return TsDecrbyRetention(c)
}

func (c TsDecrbyValue) Uncompressed() TsDecrbyUncompressed {
	c.command.append("UNCOMPRESSED")
	return TsDecrbyUncompressed(c)
}

func (c TsDecrbyValue) ChunkSize(size int64) TsDecrbyChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsDecrbyChunkSize(c)
}

func (c TsDecrbyValue) Labels() TsDecrbyLabels {
	c.command.append("LABELS")
	return TsDecrbyLabels(c)
}

// Return Completed Redis command.
func (c TsDecrbyValue) Build() Completed {
	return completed(c)
}

// Delete samples between two timestamps for a given key.
//
// Time complexity: O(N) where N is the number of data points that will be removed
type TsDel Base

// Delete samples between two timestamps for a given key
//
// Command: TS.DEL.
//
// Time complexity: O(N) where N is the number of data points that will be removed
func (b Builder) TsDel() TsDel {
	c := TsDel{command: emptyCommand(), cslot: b.slot}
	c.command.append("TS.DEL")
	return c
}

func (c TsDel) Key(key string) TsDelKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TsDelKey(c)
}

type TsDelFromTimestamp Base

func (c TsDelFromTimestamp) ToTimestamp(toTimestamp int64) TsDelToTimestamp {
	c.command.append(strconv.FormatInt(toTimestamp, 10))
	return TsDelToTimestamp(c)
}

type TsDelKey Base

func (c TsDelKey) FromTimestamp(fromTimestamp int64) TsDelFromTimestamp {
	c.command.append(strconv.FormatInt(fromTimestamp, 10))
	return TsDelFromTimestamp(c)
}

type TsDelToTimestamp Base

// Return Completed Redis command.
func (c TsDelToTimestamp) Build() Completed {
	return completed(c)
}

// Delete a compaction rule.
//
// Time complexity: O(1)
type TsDeleterule Base

// Delete a compaction rule
//
// Command: TS.DELETERULE.
//
// Time complexity: O(1)
func (b Builder) TsDeleterule() TsDeleterule {
	c := TsDeleterule{command: emptyCommand(), cslot: b.slot}
	c.command.append("TS.DELETERULE")
	return c
}

func (c TsDeleterule) Sourcekey(sourcekey string) TsDeleteruleSourcekey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(sourcekey)
	} else {
		c.cslot.set(getSlot(sourcekey))
	}
	c.command.append(sourcekey)
	return TsDeleteruleSourcekey(c)
}

type TsDeleteruleDestkey Base

// Return Completed Redis command.
func (c TsDeleteruleDestkey) Build() Completed {
	return completed(c)
}

type TsDeleteruleSourcekey Base

func (c TsDeleteruleSourcekey) Destkey(destkey string) TsDeleteruleDestkey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destkey)
	} else {
		c.cslot.set(getSlot(destkey))
	}
	c.command.append(destkey)
	return TsDeleteruleDestkey(c)
}

// Get the last sample.
//
// Time complexity: O(1)
type TsGet Base

// Get the last sample
//
// Command: TS.GET.
//
// Time complexity: O(1)
func (b Builder) TsGet() TsGet {
	c := TsGet{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("TS.GET")
	return c
}

func (c TsGet) Key(key string) TsGetKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TsGetKey(c)
}

type TsGetKey Base

func (c TsGetKey) Latest() TsGetLatest {
	c.command.append("LATEST")
	return TsGetLatest(c)
}

// Return Completed Redis command.
func (c TsGetKey) Build() Completed {
	return completed(c)
}

type TsGetLatest Base

// Return Completed Redis command.
func (c TsGetLatest) Build() Completed {
	return completed(c)
}

// Creates a new sample that increments the latest sample's value.
//
// Time complexity: O(M) when M is the amount of compaction rules or O(1) with no compaction
type TsIncrby Base

// Creates a new sample that increments the latest sample's value
//
// Command: TS.INCRBY.
//
// Time complexity: O(M) when M is the amount of compaction rules or O(1) with no compaction
func (b Builder) TsIncrby() TsIncrby {
	c := TsIncrby{command: emptyCommand(), cslot: b.slot}
	c.command.append("TS.INCRBY")
	return c
}

func (c TsIncrby) Key(key string) TsIncrbyKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TsIncrbyKey(c)
}

type TsIncrbyChunkSize Base

func (c TsIncrbyChunkSize) Labels() TsIncrbyLabels {
	c.command.append("LABELS")
	return TsIncrbyLabels(c)
}

// Return Completed Redis command.
func (c TsIncrbyChunkSize) Build() Completed {
	return completed(c)
}

type TsIncrbyKey Base

func (c TsIncrbyKey) Value(value float64) TsIncrbyValue {
	c.command.append(strconv.FormatFloat(value, 'f', -1, 64))
	return TsIncrbyValue(c)
}

type TsIncrbyLabels Base

func (c TsIncrbyLabels) Labels(label string, value string) TsIncrbyLabels {
	c.command.append(label, value)
	return c
}

// Return Completed Redis command.
func (c TsIncrbyLabels) Build() Completed {
	return completed(c)
}

type TsIncrbyRetention Base

func (c TsIncrbyRetention) Uncompressed() TsIncrbyUncompressed {
	c.command.append("UNCOMPRESSED")
	return TsIncrbyUncompressed(c)
}

func (c TsIncrbyRetention) ChunkSize(size int64) TsIncrbyChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsIncrbyChunkSize(c)
}

func (c TsIncrbyRetention) Labels() TsIncrbyLabels {
	c.command.append("LABELS")
	return TsIncrbyLabels(c)
}

// Return Completed Redis command.
func (c TsIncrbyRetention) Build() Completed {
	return completed(c)
}

type TsIncrbyTimestamp Base

func (c TsIncrbyTimestamp) Retention(retentionperiod int64) TsIncrbyRetention {
	c.command.append("RETENTION", strconv.FormatInt(retentionperiod, 10))
	return TsIncrbyRetention(c)
}

func (c TsIncrbyTimestamp) Uncompressed() TsIncrbyUncompressed {
	c.command.append("UNCOMPRESSED")
	return TsIncrbyUncompressed(c)
}

func (c TsIncrbyTimestamp) ChunkSize(size int64) TsIncrbyChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsIncrbyChunkSize(c)
}

func (c TsIncrbyTimestamp) Labels() TsIncrbyLabels {
	c.command.append("LABELS")
	return TsIncrbyLabels(c)
}

// Return Completed Redis command.
func (c TsIncrbyTimestamp) Build() Completed {
	return completed(c)
}

type TsIncrbyUncompressed Base

func (c TsIncrbyUncompressed) ChunkSize(size int64) TsIncrbyChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsIncrbyChunkSize(c)
}

func (c TsIncrbyUncompressed) Labels() TsIncrbyLabels {
	c.command.append("LABELS")
	return TsIncrbyLabels(c)
}

// Return Completed Redis command.
func (c TsIncrbyUncompressed) Build() Completed {
	return completed(c)
}

type TsIncrbyValue Base

func (c TsIncrbyValue) Timestamp(timestamp int64) TsIncrbyTimestamp {
	c.command.append("TIMESTAMP", strconv.FormatInt(timestamp, 10))
	return TsIncrbyTimestamp(c)
}

func (c TsIncrbyValue) Retention(retentionperiod int64) TsIncrbyRetention {
	c.command.append("RETENTION", strconv.FormatInt(retentionperiod, 10))
	return TsIncrbyRetention(c)
}

func (c TsIncrbyValue) Uncompressed() TsIncrbyUncompressed {
	c.command.append("UNCOMPRESSED")
	return TsIncrbyUncompressed(c)
}

func (c TsIncrbyValue) ChunkSize(size int64) TsIncrbyChunkSize {
	c.command.append("CHUNK_SIZE", strconv.FormatInt(size, 10))
	return TsIncrbyChunkSize(c)
}

func (c TsIncrbyValue) Labels() TsIncrbyLabels {
	c.command.append("LABELS")
	return TsIncrbyLabels(c)
}

// Return Completed Redis command.
func (c TsIncrbyValue) Build() Completed {
	return completed(c)
}

// Returns information and statistics on the time-series.
//
// Time complexity: O(1)
type TsInfo Base

// Returns information and statistics on the time-series
//
// Command: TS.INFO.
//
// Time complexity: O(1)
func (b Builder) TsInfo() TsInfo {
	c := TsInfo{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("TS.INFO")
	return c
}

func (c TsInfo) Key(key string) TsInfoKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TsInfoKey(c)
}

type TsInfoDebug Base

// Return Completed Redis command.
func (c TsInfoDebug) Build() Completed {
	return completed(c)
}

type TsInfoKey Base

func (c TsInfoKey) Debug(debug string) TsInfoDebug {
	c.command.append(debug)
	return TsInfoDebug(c)
}

// Return Completed Redis command.
func (c TsInfoKey) Build() Completed {
	return completed(c)
}

// Append new samples to a list of series.
//
// Time complexity: O(N*M) when N is the amount of series updated and M is the amount of compaction rules or O(N) with no compaction
type TsMadd Base

// Append new samples to a list of series
//
// Command: TS.MADD.
//
// Time complexity: O(N*M) when N is the amount of series updated and M is the amount of compaction rules or O(N) with no compaction
func (b Builder) TsMadd() TsMadd {
	c := TsMadd{command: emptyCommand(), cslot: b.slot}
	c.command.append("TS.MADD")
	return c
}

func (c TsMadd) KeyTimestampValue() TsMaddKeyTimestampValue {
	return TsMaddKeyTimestampValue(c)
}

type TsMaddKeyTimestampValue Base

func (c TsMaddKeyTimestampValue) KeyTimestampValue(key string, timestamp int64, value float64) TsMaddKeyTimestampValue {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key, strconv.FormatInt(timestamp, 10), strconv.FormatFloat(value, 'f', -1, 64))
	return c
}

// Return Completed Redis command.
func (c TsMaddKeyTimestampValue) Build() Completed {
	return completed(c)
}

// Get the last samples matching the specific filter.
//
// Time complexity: O(n) where n is the number of time-series that match the filters
type TsMget Base

// Get the last samples matching the specific filter
//
// Command: TS.MGET.
//
// Time complexity: O(n) where n is the number of time-series that match the filters
func (b Builder) TsMget() TsMget {
	c := TsMget{command: emptyCommand(), cslot: b.slot}
	c.command.append("TS.MGET")
	return c
}

func (c TsMget) Latest() TsMgetLatest {
	c.command.append("LATEST")
	return TsMgetLatest(c)
}

func (c TsMget) Withlabels() TsMgetWithlabels {
	c.command.append("WITHLABELS")
	return TsMgetWithlabels(c)
}

func (c TsMget) SelectedLabels(labels []string) TsMgetSelectedLabels {
	c.command.append("SELECTED_LABELS")
	c.command.append(labels...)
	return TsMgetSelectedLabels(c)
}

func (c TsMget) Filter(filter ...string) TsMgetFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMgetFilter(c)
}

type TsMgetFilter Base

func (c TsMgetFilter) Filter(filter ...string) TsMgetFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return c
}

// Return Completed Redis command.
func (c TsMgetFilter) Build() Completed {
	return completed(c)
}

type TsMgetLatest Base

func (c TsMgetLatest) Withlabels() TsMgetWithlabels {
	c.command.append("WITHLABELS")
	return TsMgetWithlabels(c)
}

func (c TsMgetLatest) SelectedLabels(labels []string) TsMgetSelectedLabels {
	c.command.append("SELECTED_LABELS")
	c.command.append(labels...)
	return TsMgetSelectedLabels(c)
}

func (c TsMgetLatest) Filter(filter ...string) TsMgetFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMgetFilter(c)
}

type TsMgetSelectedLabels Base

func (c TsMgetSelectedLabels) Filter(filter ...string) TsMgetFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMgetFilter(c)
}

type TsMgetWithlabels Base

func (c TsMgetWithlabels) Filter(filter ...string) TsMgetFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMgetFilter(c)
}

// Query a range across multiple time-series by filters in forward direction.
//
// Time complexity: O(n/m+k) where n = Number of data points, m = Chunk size (data points per chunk), k = Number of data points that are in the requested ranges
type TsMrange Base

// Query a range across multiple time-series by filters in forward direction
//
// Command: TS.MRANGE.
//
// Time complexity: O(n/m+k) where n = Number of data points, m = Chunk size (data points per chunk), k = Number of data points that are in the requested ranges
func (b Builder) TsMrange() TsMrange {
	c := TsMrange{command: emptyCommand(), cslot: b.slot}
	c.command.append("TS.MRANGE")
	return c
}

func (c TsMrange) Fromtimestamp(fromtimestamp int64) TsMrangeFromtimestamp {
	c.command.append(strconv.FormatInt(fromtimestamp, 10))
	return TsMrangeFromtimestamp(c)
}

type TsMrangeAggregationAggregationAvg Base

func (c TsMrangeAggregationAggregationAvg) Bucketduration(bucketduration int64) TsMrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrangeAggregationBucketduration(c)
}

type TsMrangeAggregationAggregationCount Base

func (c TsMrangeAggregationAggregationCount) Bucketduration(bucketduration int64) TsMrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrangeAggregationBucketduration(c)
}

type TsMrangeAggregationAggregationFirst Base

func (c TsMrangeAggregationAggregationFirst) Bucketduration(bucketduration int64) TsMrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrangeAggregationBucketduration(c)
}

type TsMrangeAggregationAggregationLast Base

func (c TsMrangeAggregationAggregationLast) Bucketduration(bucketduration int64) TsMrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrangeAggregationBucketduration(c)
}

type TsMrangeAggregationAggregationMax Base

func (c TsMrangeAggregationAggregationMax) Bucketduration(bucketduration int64) TsMrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrangeAggregationBucketduration(c)
}

type TsMrangeAggregationAggregationMin Base

func (c TsMrangeAggregationAggregationMin) Bucketduration(bucketduration int64) TsMrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrangeAggregationBucketduration(c)
}

type TsMrangeAggregationAggregationRange Base

func (c TsMrangeAggregationAggregationRange) Bucketduration(bucketduration int64) TsMrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrangeAggregationBucketduration(c)
}

type TsMrangeAggregationAggregationStdP Base

func (c TsMrangeAggregationAggregationStdP) Bucketduration(bucketduration int64) TsMrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrangeAggregationBucketduration(c)
}

type TsMrangeAggregationAggregationStdS Base

func (c TsMrangeAggregationAggregationStdS) Bucketduration(bucketduration int64) TsMrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrangeAggregationBucketduration(c)
}

type TsMrangeAggregationAggregationSum Base

func (c TsMrangeAggregationAggregationSum) Bucketduration(bucketduration int64) TsMrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrangeAggregationBucketduration(c)
}

type TsMrangeAggregationAggregationTwa Base

func (c TsMrangeAggregationAggregationTwa) Bucketduration(bucketduration int64) TsMrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrangeAggregationBucketduration(c)
}

type TsMrangeAggregationAggregationVarP Base

func (c TsMrangeAggregationAggregationVarP) Bucketduration(bucketduration int64) TsMrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrangeAggregationBucketduration(c)
}

type TsMrangeAggregationAggregationVarS Base

func (c TsMrangeAggregationAggregationVarS) Bucketduration(bucketduration int64) TsMrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrangeAggregationBucketduration(c)
}

type TsMrangeAggregationBucketduration Base

func (c TsMrangeAggregationBucketduration) Buckettimestamp(buckettimestamp string) TsMrangeAggregationBuckettimestamp {
	c.command.append("BUCKETTIMESTAMP", buckettimestamp)
	return TsMrangeAggregationBuckettimestamp(c)
}

func (c TsMrangeAggregationBucketduration) Empty() TsMrangeAggregationEmpty {
	c.command.append("EMPTY")
	return TsMrangeAggregationEmpty(c)
}

func (c TsMrangeAggregationBucketduration) Filter(filter ...string) TsMrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrangeFilter(c)
}

type TsMrangeAggregationBuckettimestamp Base

func (c TsMrangeAggregationBuckettimestamp) Empty() TsMrangeAggregationEmpty {
	c.command.append("EMPTY")
	return TsMrangeAggregationEmpty(c)
}

func (c TsMrangeAggregationBuckettimestamp) Filter(filter ...string) TsMrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrangeFilter(c)
}

type TsMrangeAggregationEmpty Base

func (c TsMrangeAggregationEmpty) Filter(filter ...string) TsMrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrangeFilter(c)
}

type TsMrangeAlign Base

func (c TsMrangeAlign) AggregationAvg() TsMrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrangeAggregationAggregationAvg(c)
}

func (c TsMrangeAlign) AggregationSum() TsMrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrangeAggregationAggregationSum(c)
}

func (c TsMrangeAlign) AggregationMin() TsMrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrangeAggregationAggregationMin(c)
}

func (c TsMrangeAlign) AggregationMax() TsMrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrangeAggregationAggregationMax(c)
}

func (c TsMrangeAlign) AggregationRange() TsMrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrangeAggregationAggregationRange(c)
}

func (c TsMrangeAlign) AggregationCount() TsMrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrangeAggregationAggregationCount(c)
}

func (c TsMrangeAlign) AggregationFirst() TsMrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrangeAggregationAggregationFirst(c)
}

func (c TsMrangeAlign) AggregationLast() TsMrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrangeAggregationAggregationLast(c)
}

func (c TsMrangeAlign) AggregationStdP() TsMrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrangeAggregationAggregationStdP(c)
}

func (c TsMrangeAlign) AggregationStdS() TsMrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrangeAggregationAggregationStdS(c)
}

func (c TsMrangeAlign) AggregationVarP() TsMrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrangeAggregationAggregationVarP(c)
}

func (c TsMrangeAlign) AggregationVarS() TsMrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrangeAggregationAggregationVarS(c)
}

func (c TsMrangeAlign) AggregationTwa() TsMrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrangeAggregationAggregationTwa(c)
}

func (c TsMrangeAlign) Filter(filter ...string) TsMrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrangeFilter(c)
}

type TsMrangeCount Base

func (c TsMrangeCount) Align(value string) TsMrangeAlign {
	c.command.append("ALIGN", value)
	return TsMrangeAlign(c)
}

func (c TsMrangeCount) AggregationAvg() TsMrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrangeAggregationAggregationAvg(c)
}

func (c TsMrangeCount) AggregationSum() TsMrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrangeAggregationAggregationSum(c)
}

func (c TsMrangeCount) AggregationMin() TsMrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrangeAggregationAggregationMin(c)
}

func (c TsMrangeCount) AggregationMax() TsMrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrangeAggregationAggregationMax(c)
}

func (c TsMrangeCount) AggregationRange() TsMrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrangeAggregationAggregationRange(c)
}

func (c TsMrangeCount) AggregationCount() TsMrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrangeAggregationAggregationCount(c)
}

func (c TsMrangeCount) AggregationFirst() TsMrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrangeAggregationAggregationFirst(c)
}

func (c TsMrangeCount) AggregationLast() TsMrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrangeAggregationAggregationLast(c)
}

func (c TsMrangeCount) AggregationStdP() TsMrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrangeAggregationAggregationStdP(c)
}

func (c TsMrangeCount) AggregationStdS() TsMrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrangeAggregationAggregationStdS(c)
}

func (c TsMrangeCount) AggregationVarP() TsMrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrangeAggregationAggregationVarP(c)
}

func (c TsMrangeCount) AggregationVarS() TsMrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrangeAggregationAggregationVarS(c)
}

func (c TsMrangeCount) AggregationTwa() TsMrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrangeAggregationAggregationTwa(c)
}

func (c TsMrangeCount) Filter(filter ...string) TsMrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrangeFilter(c)
}

type TsMrangeFilter Base

func (c TsMrangeFilter) Filter(filter ...string) TsMrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return c
}

func (c TsMrangeFilter) Groupby(label string, reduce string, reducer string) TsMrangeGroupby {
	c.command.append("GROUPBY", label, reduce, reducer)
	return TsMrangeGroupby(c)
}

// Return Completed Redis command.
func (c TsMrangeFilter) Build() Completed {
	return completed(c)
}

type TsMrangeFilterByTs Base

func (c TsMrangeFilterByTs) FilterByTs(timestamp ...int64) TsMrangeFilterByTs {
	c.command.append("FILTER_BY_TS")
	for _, n := range timestamp {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return c
}

func (c TsMrangeFilterByTs) FilterByValue(min float64, max float64) TsMrangeFilterByValue {
	c.command.append("FILTER_BY_VALUE", strconv.FormatFloat(min, 'f', -1, 64), strconv.FormatFloat(max, 'f', -1, 64))
	return TsMrangeFilterByValue(c)
}

func (c TsMrangeFilterByTs) Withlabels() TsMrangeWithlabels {
	c.command.append("WITHLABELS")
	return TsMrangeWithlabels(c)
}

func (c TsMrangeFilterByTs) SelectedLabels(labels []string) TsMrangeSelectedLabels {
	c.command.append("SELECTED_LABELS")
	c.command.append(labels...)
	return TsMrangeSelectedLabels(c)
}

func (c TsMrangeFilterByTs) Count(count int64) TsMrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsMrangeCount(c)
}

func (c TsMrangeFilterByTs) Align(value string) TsMrangeAlign {
	c.command.append("ALIGN", value)
	return TsMrangeAlign(c)
}

func (c TsMrangeFilterByTs) AggregationAvg() TsMrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrangeAggregationAggregationAvg(c)
}

func (c TsMrangeFilterByTs) AggregationSum() TsMrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrangeAggregationAggregationSum(c)
}

func (c TsMrangeFilterByTs) AggregationMin() TsMrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrangeAggregationAggregationMin(c)
}

func (c TsMrangeFilterByTs) AggregationMax() TsMrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrangeAggregationAggregationMax(c)
}

func (c TsMrangeFilterByTs) AggregationRange() TsMrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrangeAggregationAggregationRange(c)
}

func (c TsMrangeFilterByTs) AggregationCount() TsMrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrangeAggregationAggregationCount(c)
}

func (c TsMrangeFilterByTs) AggregationFirst() TsMrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrangeAggregationAggregationFirst(c)
}

func (c TsMrangeFilterByTs) AggregationLast() TsMrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrangeAggregationAggregationLast(c)
}

func (c TsMrangeFilterByTs) AggregationStdP() TsMrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrangeAggregationAggregationStdP(c)
}

func (c TsMrangeFilterByTs) AggregationStdS() TsMrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrangeAggregationAggregationStdS(c)
}

func (c TsMrangeFilterByTs) AggregationVarP() TsMrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrangeAggregationAggregationVarP(c)
}

func (c TsMrangeFilterByTs) AggregationVarS() TsMrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrangeAggregationAggregationVarS(c)
}

func (c TsMrangeFilterByTs) AggregationTwa() TsMrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrangeAggregationAggregationTwa(c)
}

func (c TsMrangeFilterByTs) Filter(filter ...string) TsMrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrangeFilter(c)
}

type TsMrangeFilterByValue Base

func (c TsMrangeFilterByValue) Withlabels() TsMrangeWithlabels {
	c.command.append("WITHLABELS")
	return TsMrangeWithlabels(c)
}

func (c TsMrangeFilterByValue) SelectedLabels(labels []string) TsMrangeSelectedLabels {
	c.command.append("SELECTED_LABELS")
	c.command.append(labels...)
	return TsMrangeSelectedLabels(c)
}

func (c TsMrangeFilterByValue) Count(count int64) TsMrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsMrangeCount(c)
}

func (c TsMrangeFilterByValue) Align(value string) TsMrangeAlign {
	c.command.append("ALIGN", value)
	return TsMrangeAlign(c)
}

func (c TsMrangeFilterByValue) AggregationAvg() TsMrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrangeAggregationAggregationAvg(c)
}

func (c TsMrangeFilterByValue) AggregationSum() TsMrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrangeAggregationAggregationSum(c)
}

func (c TsMrangeFilterByValue) AggregationMin() TsMrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrangeAggregationAggregationMin(c)
}

func (c TsMrangeFilterByValue) AggregationMax() TsMrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrangeAggregationAggregationMax(c)
}

func (c TsMrangeFilterByValue) AggregationRange() TsMrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrangeAggregationAggregationRange(c)
}

func (c TsMrangeFilterByValue) AggregationCount() TsMrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrangeAggregationAggregationCount(c)
}

func (c TsMrangeFilterByValue) AggregationFirst() TsMrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrangeAggregationAggregationFirst(c)
}

func (c TsMrangeFilterByValue) AggregationLast() TsMrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrangeAggregationAggregationLast(c)
}

func (c TsMrangeFilterByValue) AggregationStdP() TsMrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrangeAggregationAggregationStdP(c)
}

func (c TsMrangeFilterByValue) AggregationStdS() TsMrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrangeAggregationAggregationStdS(c)
}

func (c TsMrangeFilterByValue) AggregationVarP() TsMrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrangeAggregationAggregationVarP(c)
}

func (c TsMrangeFilterByValue) AggregationVarS() TsMrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrangeAggregationAggregationVarS(c)
}

func (c TsMrangeFilterByValue) AggregationTwa() TsMrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrangeAggregationAggregationTwa(c)
}

func (c TsMrangeFilterByValue) Filter(filter ...string) TsMrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrangeFilter(c)
}

type TsMrangeFromtimestamp Base

func (c TsMrangeFromtimestamp) Totimestamp(totimestamp int64) TsMrangeTotimestamp {
	c.command.append(strconv.FormatInt(totimestamp, 10))
	return TsMrangeTotimestamp(c)
}

type TsMrangeGroupby Base

// Return Completed Redis command.
func (c TsMrangeGroupby) Build() Completed {
	return completed(c)
}

type TsMrangeLatest Base

func (c TsMrangeLatest) FilterByTs(timestamp ...int64) TsMrangeFilterByTs {
	c.command.append("FILTER_BY_TS")
	for _, n := range timestamp {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return TsMrangeFilterByTs(c)
}

func (c TsMrangeLatest) FilterByValue(min float64, max float64) TsMrangeFilterByValue {
	c.command.append("FILTER_BY_VALUE", strconv.FormatFloat(min, 'f', -1, 64), strconv.FormatFloat(max, 'f', -1, 64))
	return TsMrangeFilterByValue(c)
}

func (c TsMrangeLatest) Withlabels() TsMrangeWithlabels {
	c.command.append("WITHLABELS")
	return TsMrangeWithlabels(c)
}

func (c TsMrangeLatest) SelectedLabels(labels []string) TsMrangeSelectedLabels {
	c.command.append("SELECTED_LABELS")
	c.command.append(labels...)
	return TsMrangeSelectedLabels(c)
}

func (c TsMrangeLatest) Count(count int64) TsMrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsMrangeCount(c)
}

func (c TsMrangeLatest) Align(value string) TsMrangeAlign {
	c.command.append("ALIGN", value)
	return TsMrangeAlign(c)
}

func (c TsMrangeLatest) AggregationAvg() TsMrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrangeAggregationAggregationAvg(c)
}

func (c TsMrangeLatest) AggregationSum() TsMrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrangeAggregationAggregationSum(c)
}

func (c TsMrangeLatest) AggregationMin() TsMrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrangeAggregationAggregationMin(c)
}

func (c TsMrangeLatest) AggregationMax() TsMrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrangeAggregationAggregationMax(c)
}

func (c TsMrangeLatest) AggregationRange() TsMrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrangeAggregationAggregationRange(c)
}

func (c TsMrangeLatest) AggregationCount() TsMrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrangeAggregationAggregationCount(c)
}

func (c TsMrangeLatest) AggregationFirst() TsMrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrangeAggregationAggregationFirst(c)
}

func (c TsMrangeLatest) AggregationLast() TsMrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrangeAggregationAggregationLast(c)
}

func (c TsMrangeLatest) AggregationStdP() TsMrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrangeAggregationAggregationStdP(c)
}

func (c TsMrangeLatest) AggregationStdS() TsMrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrangeAggregationAggregationStdS(c)
}

func (c TsMrangeLatest) AggregationVarP() TsMrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrangeAggregationAggregationVarP(c)
}

func (c TsMrangeLatest) AggregationVarS() TsMrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrangeAggregationAggregationVarS(c)
}

func (c TsMrangeLatest) AggregationTwa() TsMrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrangeAggregationAggregationTwa(c)
}

func (c TsMrangeLatest) Filter(filter ...string) TsMrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrangeFilter(c)
}

type TsMrangeSelectedLabels Base

func (c TsMrangeSelectedLabels) Count(count int64) TsMrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsMrangeCount(c)
}

func (c TsMrangeSelectedLabels) Align(value string) TsMrangeAlign {
	c.command.append("ALIGN", value)
	return TsMrangeAlign(c)
}

func (c TsMrangeSelectedLabels) AggregationAvg() TsMrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrangeAggregationAggregationAvg(c)
}

func (c TsMrangeSelectedLabels) AggregationSum() TsMrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrangeAggregationAggregationSum(c)
}

func (c TsMrangeSelectedLabels) AggregationMin() TsMrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrangeAggregationAggregationMin(c)
}

func (c TsMrangeSelectedLabels) AggregationMax() TsMrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrangeAggregationAggregationMax(c)
}

func (c TsMrangeSelectedLabels) AggregationRange() TsMrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrangeAggregationAggregationRange(c)
}

func (c TsMrangeSelectedLabels) AggregationCount() TsMrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrangeAggregationAggregationCount(c)
}

func (c TsMrangeSelectedLabels) AggregationFirst() TsMrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrangeAggregationAggregationFirst(c)
}

func (c TsMrangeSelectedLabels) AggregationLast() TsMrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrangeAggregationAggregationLast(c)
}

func (c TsMrangeSelectedLabels) AggregationStdP() TsMrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrangeAggregationAggregationStdP(c)
}

func (c TsMrangeSelectedLabels) AggregationStdS() TsMrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrangeAggregationAggregationStdS(c)
}

func (c TsMrangeSelectedLabels) AggregationVarP() TsMrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrangeAggregationAggregationVarP(c)
}

func (c TsMrangeSelectedLabels) AggregationVarS() TsMrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrangeAggregationAggregationVarS(c)
}

func (c TsMrangeSelectedLabels) AggregationTwa() TsMrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrangeAggregationAggregationTwa(c)
}

func (c TsMrangeSelectedLabels) Filter(filter ...string) TsMrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrangeFilter(c)
}

type TsMrangeTotimestamp Base

func (c TsMrangeTotimestamp) Latest() TsMrangeLatest {
	c.command.append("LATEST")
	return TsMrangeLatest(c)
}

func (c TsMrangeTotimestamp) FilterByTs(timestamp ...int64) TsMrangeFilterByTs {
	c.command.append("FILTER_BY_TS")
	for _, n := range timestamp {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return TsMrangeFilterByTs(c)
}

func (c TsMrangeTotimestamp) FilterByValue(min float64, max float64) TsMrangeFilterByValue {
	c.command.append("FILTER_BY_VALUE", strconv.FormatFloat(min, 'f', -1, 64), strconv.FormatFloat(max, 'f', -1, 64))
	return TsMrangeFilterByValue(c)
}

func (c TsMrangeTotimestamp) Withlabels() TsMrangeWithlabels {
	c.command.append("WITHLABELS")
	return TsMrangeWithlabels(c)
}

func (c TsMrangeTotimestamp) SelectedLabels(labels []string) TsMrangeSelectedLabels {
	c.command.append("SELECTED_LABELS")
	c.command.append(labels...)
	return TsMrangeSelectedLabels(c)
}

func (c TsMrangeTotimestamp) Count(count int64) TsMrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsMrangeCount(c)
}

func (c TsMrangeTotimestamp) Align(value string) TsMrangeAlign {
	c.command.append("ALIGN", value)
	return TsMrangeAlign(c)
}

func (c TsMrangeTotimestamp) AggregationAvg() TsMrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrangeAggregationAggregationAvg(c)
}

func (c TsMrangeTotimestamp) AggregationSum() TsMrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrangeAggregationAggregationSum(c)
}

func (c TsMrangeTotimestamp) AggregationMin() TsMrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrangeAggregationAggregationMin(c)
}

func (c TsMrangeTotimestamp) AggregationMax() TsMrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrangeAggregationAggregationMax(c)
}

func (c TsMrangeTotimestamp) AggregationRange() TsMrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrangeAggregationAggregationRange(c)
}

func (c TsMrangeTotimestamp) AggregationCount() TsMrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrangeAggregationAggregationCount(c)
}

func (c TsMrangeTotimestamp) AggregationFirst() TsMrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrangeAggregationAggregationFirst(c)
}

func (c TsMrangeTotimestamp) AggregationLast() TsMrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrangeAggregationAggregationLast(c)
}

func (c TsMrangeTotimestamp) AggregationStdP() TsMrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrangeAggregationAggregationStdP(c)
}

func (c TsMrangeTotimestamp) AggregationStdS() TsMrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrangeAggregationAggregationStdS(c)
}

func (c TsMrangeTotimestamp) AggregationVarP() TsMrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrangeAggregationAggregationVarP(c)
}

func (c TsMrangeTotimestamp) AggregationVarS() TsMrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrangeAggregationAggregationVarS(c)
}

func (c TsMrangeTotimestamp) AggregationTwa() TsMrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrangeAggregationAggregationTwa(c)
}

func (c TsMrangeTotimestamp) Filter(filter ...string) TsMrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrangeFilter(c)
}

type TsMrangeWithlabels Base

func (c TsMrangeWithlabels) Count(count int64) TsMrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsMrangeCount(c)
}

func (c TsMrangeWithlabels) Align(value string) TsMrangeAlign {
	c.command.append("ALIGN", value)
	return TsMrangeAlign(c)
}

func (c TsMrangeWithlabels) AggregationAvg() TsMrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrangeAggregationAggregationAvg(c)
}

func (c TsMrangeWithlabels) AggregationSum() TsMrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrangeAggregationAggregationSum(c)
}

func (c TsMrangeWithlabels) AggregationMin() TsMrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrangeAggregationAggregationMin(c)
}

func (c TsMrangeWithlabels) AggregationMax() TsMrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrangeAggregationAggregationMax(c)
}

func (c TsMrangeWithlabels) AggregationRange() TsMrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrangeAggregationAggregationRange(c)
}

func (c TsMrangeWithlabels) AggregationCount() TsMrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrangeAggregationAggregationCount(c)
}

func (c TsMrangeWithlabels) AggregationFirst() TsMrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrangeAggregationAggregationFirst(c)
}

func (c TsMrangeWithlabels) AggregationLast() TsMrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrangeAggregationAggregationLast(c)
}

func (c TsMrangeWithlabels) AggregationStdP() TsMrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrangeAggregationAggregationStdP(c)
}

func (c TsMrangeWithlabels) AggregationStdS() TsMrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrangeAggregationAggregationStdS(c)
}

func (c TsMrangeWithlabels) AggregationVarP() TsMrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrangeAggregationAggregationVarP(c)
}

func (c TsMrangeWithlabels) AggregationVarS() TsMrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrangeAggregationAggregationVarS(c)
}

func (c TsMrangeWithlabels) AggregationTwa() TsMrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrangeAggregationAggregationTwa(c)
}

func (c TsMrangeWithlabels) Filter(filter ...string) TsMrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrangeFilter(c)
}

// Query a range across multiple time-series by filters in reverse direction.
//
// Time complexity: O(n/m+k) where n = Number of data points, m = Chunk size (data points per chunk), k = Number of data points that are in the requested ranges
type TsMrevrange Base

// Query a range across multiple time-series by filters in reverse direction
//
// Command: TS.MREVRANGE.
//
// Time complexity: O(n/m+k) where n = Number of data points, m = Chunk size (data points per chunk), k = Number of data points that are in the requested ranges
func (b Builder) TsMrevrange() TsMrevrange {
	c := TsMrevrange{command: emptyCommand(), cslot: b.slot}
	c.command.append("TS.MREVRANGE")
	return c
}

func (c TsMrevrange) Fromtimestamp(fromtimestamp int64) TsMrevrangeFromtimestamp {
	c.command.append(strconv.FormatInt(fromtimestamp, 10))
	return TsMrevrangeFromtimestamp(c)
}

type TsMrevrangeAggregationAggregationAvg Base

func (c TsMrevrangeAggregationAggregationAvg) Bucketduration(bucketduration int64) TsMrevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrevrangeAggregationBucketduration(c)
}

type TsMrevrangeAggregationAggregationCount Base

func (c TsMrevrangeAggregationAggregationCount) Bucketduration(bucketduration int64) TsMrevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrevrangeAggregationBucketduration(c)
}

type TsMrevrangeAggregationAggregationFirst Base

func (c TsMrevrangeAggregationAggregationFirst) Bucketduration(bucketduration int64) TsMrevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrevrangeAggregationBucketduration(c)
}

type TsMrevrangeAggregationAggregationLast Base

func (c TsMrevrangeAggregationAggregationLast) Bucketduration(bucketduration int64) TsMrevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrevrangeAggregationBucketduration(c)
}

type TsMrevrangeAggregationAggregationMax Base

func (c TsMrevrangeAggregationAggregationMax) Bucketduration(bucketduration int64) TsMrevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrevrangeAggregationBucketduration(c)
}

type TsMrevrangeAggregationAggregationMin Base

func (c TsMrevrangeAggregationAggregationMin) Bucketduration(bucketduration int64) TsMrevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrevrangeAggregationBucketduration(c)
}

type TsMrevrangeAggregationAggregationRange Base

func (c TsMrevrangeAggregationAggregationRange) Bucketduration(bucketduration int64) TsMrevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrevrangeAggregationBucketduration(c)
}

type TsMrevrangeAggregationAggregationStdP Base

func (c TsMrevrangeAggregationAggregationStdP) Bucketduration(bucketduration int64) TsMrevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrevrangeAggregationBucketduration(c)
}

type TsMrevrangeAggregationAggregationStdS Base

func (c TsMrevrangeAggregationAggregationStdS) Bucketduration(bucketduration int64) TsMrevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrevrangeAggregationBucketduration(c)
}

type TsMrevrangeAggregationAggregationSum Base

func (c TsMrevrangeAggregationAggregationSum) Bucketduration(bucketduration int64) TsMrevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrevrangeAggregationBucketduration(c)
}

type TsMrevrangeAggregationAggregationTwa Base

func (c TsMrevrangeAggregationAggregationTwa) Bucketduration(bucketduration int64) TsMrevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrevrangeAggregationBucketduration(c)
}

type TsMrevrangeAggregationAggregationVarP Base

func (c TsMrevrangeAggregationAggregationVarP) Bucketduration(bucketduration int64) TsMrevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrevrangeAggregationBucketduration(c)
}

type TsMrevrangeAggregationAggregationVarS Base

func (c TsMrevrangeAggregationAggregationVarS) Bucketduration(bucketduration int64) TsMrevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsMrevrangeAggregationBucketduration(c)
}

type TsMrevrangeAggregationBucketduration Base

func (c TsMrevrangeAggregationBucketduration) Buckettimestamp(buckettimestamp string) TsMrevrangeAggregationBuckettimestamp {
	c.command.append("BUCKETTIMESTAMP", buckettimestamp)
	return TsMrevrangeAggregationBuckettimestamp(c)
}

func (c TsMrevrangeAggregationBucketduration) Empty() TsMrevrangeAggregationEmpty {
	c.command.append("EMPTY")
	return TsMrevrangeAggregationEmpty(c)
}

func (c TsMrevrangeAggregationBucketduration) Filter(filter ...string) TsMrevrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrevrangeFilter(c)
}

type TsMrevrangeAggregationBuckettimestamp Base

func (c TsMrevrangeAggregationBuckettimestamp) Empty() TsMrevrangeAggregationEmpty {
	c.command.append("EMPTY")
	return TsMrevrangeAggregationEmpty(c)
}

func (c TsMrevrangeAggregationBuckettimestamp) Filter(filter ...string) TsMrevrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrevrangeFilter(c)
}

type TsMrevrangeAggregationEmpty Base

func (c TsMrevrangeAggregationEmpty) Filter(filter ...string) TsMrevrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrevrangeFilter(c)
}

type TsMrevrangeAlign Base

func (c TsMrevrangeAlign) AggregationAvg() TsMrevrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrevrangeAggregationAggregationAvg(c)
}

func (c TsMrevrangeAlign) AggregationSum() TsMrevrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrevrangeAggregationAggregationSum(c)
}

func (c TsMrevrangeAlign) AggregationMin() TsMrevrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrevrangeAggregationAggregationMin(c)
}

func (c TsMrevrangeAlign) AggregationMax() TsMrevrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrevrangeAggregationAggregationMax(c)
}

func (c TsMrevrangeAlign) AggregationRange() TsMrevrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrevrangeAggregationAggregationRange(c)
}

func (c TsMrevrangeAlign) AggregationCount() TsMrevrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrevrangeAggregationAggregationCount(c)
}

func (c TsMrevrangeAlign) AggregationFirst() TsMrevrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrevrangeAggregationAggregationFirst(c)
}

func (c TsMrevrangeAlign) AggregationLast() TsMrevrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrevrangeAggregationAggregationLast(c)
}

func (c TsMrevrangeAlign) AggregationStdP() TsMrevrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrevrangeAggregationAggregationStdP(c)
}

func (c TsMrevrangeAlign) AggregationStdS() TsMrevrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrevrangeAggregationAggregationStdS(c)
}

func (c TsMrevrangeAlign) AggregationVarP() TsMrevrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrevrangeAggregationAggregationVarP(c)
}

func (c TsMrevrangeAlign) AggregationVarS() TsMrevrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrevrangeAggregationAggregationVarS(c)
}

func (c TsMrevrangeAlign) AggregationTwa() TsMrevrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrevrangeAggregationAggregationTwa(c)
}

func (c TsMrevrangeAlign) Filter(filter ...string) TsMrevrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrevrangeFilter(c)
}

type TsMrevrangeCount Base

func (c TsMrevrangeCount) Align(value string) TsMrevrangeAlign {
	c.command.append("ALIGN", value)
	return TsMrevrangeAlign(c)
}

func (c TsMrevrangeCount) AggregationAvg() TsMrevrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrevrangeAggregationAggregationAvg(c)
}

func (c TsMrevrangeCount) AggregationSum() TsMrevrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrevrangeAggregationAggregationSum(c)
}

func (c TsMrevrangeCount) AggregationMin() TsMrevrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrevrangeAggregationAggregationMin(c)
}

func (c TsMrevrangeCount) AggregationMax() TsMrevrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrevrangeAggregationAggregationMax(c)
}

func (c TsMrevrangeCount) AggregationRange() TsMrevrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrevrangeAggregationAggregationRange(c)
}

func (c TsMrevrangeCount) AggregationCount() TsMrevrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrevrangeAggregationAggregationCount(c)
}

func (c TsMrevrangeCount) AggregationFirst() TsMrevrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrevrangeAggregationAggregationFirst(c)
}

func (c TsMrevrangeCount) AggregationLast() TsMrevrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrevrangeAggregationAggregationLast(c)
}

func (c TsMrevrangeCount) AggregationStdP() TsMrevrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrevrangeAggregationAggregationStdP(c)
}

func (c TsMrevrangeCount) AggregationStdS() TsMrevrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrevrangeAggregationAggregationStdS(c)
}

func (c TsMrevrangeCount) AggregationVarP() TsMrevrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrevrangeAggregationAggregationVarP(c)
}

func (c TsMrevrangeCount) AggregationVarS() TsMrevrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrevrangeAggregationAggregationVarS(c)
}

func (c TsMrevrangeCount) AggregationTwa() TsMrevrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrevrangeAggregationAggregationTwa(c)
}

func (c TsMrevrangeCount) Filter(filter ...string) TsMrevrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrevrangeFilter(c)
}

type TsMrevrangeFilter Base

func (c TsMrevrangeFilter) Filter(filter ...string) TsMrevrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return c
}

func (c TsMrevrangeFilter) Groupby(label string, reduce string, reducer string) TsMrevrangeGroupby {
	c.command.append("GROUPBY", label, reduce, reducer)
	return TsMrevrangeGroupby(c)
}

// Return Completed Redis command.
func (c TsMrevrangeFilter) Build() Completed {
	return completed(c)
}

type TsMrevrangeFilterByTs Base

func (c TsMrevrangeFilterByTs) FilterByTs(timestamp ...int64) TsMrevrangeFilterByTs {
	c.command.append("FILTER_BY_TS")
	for _, n := range timestamp {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return c
}

func (c TsMrevrangeFilterByTs) FilterByValue(min float64, max float64) TsMrevrangeFilterByValue {
	c.command.append("FILTER_BY_VALUE", strconv.FormatFloat(min, 'f', -1, 64), strconv.FormatFloat(max, 'f', -1, 64))
	return TsMrevrangeFilterByValue(c)
}

func (c TsMrevrangeFilterByTs) Withlabels() TsMrevrangeWithlabels {
	c.command.append("WITHLABELS")
	return TsMrevrangeWithlabels(c)
}

func (c TsMrevrangeFilterByTs) SelectedLabels(labels []string) TsMrevrangeSelectedLabels {
	c.command.append("SELECTED_LABELS")
	c.command.append(labels...)
	return TsMrevrangeSelectedLabels(c)
}

func (c TsMrevrangeFilterByTs) Count(count int64) TsMrevrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsMrevrangeCount(c)
}

func (c TsMrevrangeFilterByTs) Align(value string) TsMrevrangeAlign {
	c.command.append("ALIGN", value)
	return TsMrevrangeAlign(c)
}

func (c TsMrevrangeFilterByTs) AggregationAvg() TsMrevrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrevrangeAggregationAggregationAvg(c)
}

func (c TsMrevrangeFilterByTs) AggregationSum() TsMrevrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrevrangeAggregationAggregationSum(c)
}

func (c TsMrevrangeFilterByTs) AggregationMin() TsMrevrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrevrangeAggregationAggregationMin(c)
}

func (c TsMrevrangeFilterByTs) AggregationMax() TsMrevrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrevrangeAggregationAggregationMax(c)
}

func (c TsMrevrangeFilterByTs) AggregationRange() TsMrevrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrevrangeAggregationAggregationRange(c)
}

func (c TsMrevrangeFilterByTs) AggregationCount() TsMrevrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrevrangeAggregationAggregationCount(c)
}

func (c TsMrevrangeFilterByTs) AggregationFirst() TsMrevrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrevrangeAggregationAggregationFirst(c)
}

func (c TsMrevrangeFilterByTs) AggregationLast() TsMrevrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrevrangeAggregationAggregationLast(c)
}

func (c TsMrevrangeFilterByTs) AggregationStdP() TsMrevrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrevrangeAggregationAggregationStdP(c)
}

func (c TsMrevrangeFilterByTs) AggregationStdS() TsMrevrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrevrangeAggregationAggregationStdS(c)
}

func (c TsMrevrangeFilterByTs) AggregationVarP() TsMrevrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrevrangeAggregationAggregationVarP(c)
}

func (c TsMrevrangeFilterByTs) AggregationVarS() TsMrevrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrevrangeAggregationAggregationVarS(c)
}

func (c TsMrevrangeFilterByTs) AggregationTwa() TsMrevrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrevrangeAggregationAggregationTwa(c)
}

func (c TsMrevrangeFilterByTs) Filter(filter ...string) TsMrevrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrevrangeFilter(c)
}

type TsMrevrangeFilterByValue Base

func (c TsMrevrangeFilterByValue) Withlabels() TsMrevrangeWithlabels {
	c.command.append("WITHLABELS")
	return TsMrevrangeWithlabels(c)
}

func (c TsMrevrangeFilterByValue) SelectedLabels(labels []string) TsMrevrangeSelectedLabels {
	c.command.append("SELECTED_LABELS")
	c.command.append(labels...)
	return TsMrevrangeSelectedLabels(c)
}

func (c TsMrevrangeFilterByValue) Count(count int64) TsMrevrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsMrevrangeCount(c)
}

func (c TsMrevrangeFilterByValue) Align(value string) TsMrevrangeAlign {
	c.command.append("ALIGN", value)
	return TsMrevrangeAlign(c)
}

func (c TsMrevrangeFilterByValue) AggregationAvg() TsMrevrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrevrangeAggregationAggregationAvg(c)
}

func (c TsMrevrangeFilterByValue) AggregationSum() TsMrevrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrevrangeAggregationAggregationSum(c)
}

func (c TsMrevrangeFilterByValue) AggregationMin() TsMrevrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrevrangeAggregationAggregationMin(c)
}

func (c TsMrevrangeFilterByValue) AggregationMax() TsMrevrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrevrangeAggregationAggregationMax(c)
}

func (c TsMrevrangeFilterByValue) AggregationRange() TsMrevrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrevrangeAggregationAggregationRange(c)
}

func (c TsMrevrangeFilterByValue) AggregationCount() TsMrevrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrevrangeAggregationAggregationCount(c)
}

func (c TsMrevrangeFilterByValue) AggregationFirst() TsMrevrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrevrangeAggregationAggregationFirst(c)
}

func (c TsMrevrangeFilterByValue) AggregationLast() TsMrevrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrevrangeAggregationAggregationLast(c)
}

func (c TsMrevrangeFilterByValue) AggregationStdP() TsMrevrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrevrangeAggregationAggregationStdP(c)
}

func (c TsMrevrangeFilterByValue) AggregationStdS() TsMrevrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrevrangeAggregationAggregationStdS(c)
}

func (c TsMrevrangeFilterByValue) AggregationVarP() TsMrevrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrevrangeAggregationAggregationVarP(c)
}

func (c TsMrevrangeFilterByValue) AggregationVarS() TsMrevrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrevrangeAggregationAggregationVarS(c)
}

func (c TsMrevrangeFilterByValue) AggregationTwa() TsMrevrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrevrangeAggregationAggregationTwa(c)
}

func (c TsMrevrangeFilterByValue) Filter(filter ...string) TsMrevrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrevrangeFilter(c)
}

type TsMrevrangeFromtimestamp Base

func (c TsMrevrangeFromtimestamp) Totimestamp(totimestamp int64) TsMrevrangeTotimestamp {
	c.command.append(strconv.FormatInt(totimestamp, 10))
	return TsMrevrangeTotimestamp(c)
}

type TsMrevrangeGroupby Base

// Return Completed Redis command.
func (c TsMrevrangeGroupby) Build() Completed {
	return completed(c)
}

type TsMrevrangeLatest Base

func (c TsMrevrangeLatest) FilterByTs(timestamp ...int64) TsMrevrangeFilterByTs {
	c.command.append("FILTER_BY_TS")
	for _, n := range timestamp {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return TsMrevrangeFilterByTs(c)
}

func (c TsMrevrangeLatest) FilterByValue(min float64, max float64) TsMrevrangeFilterByValue {
	c.command.append("FILTER_BY_VALUE", strconv.FormatFloat(min, 'f', -1, 64), strconv.FormatFloat(max, 'f', -1, 64))
	return TsMrevrangeFilterByValue(c)
}

func (c TsMrevrangeLatest) Withlabels() TsMrevrangeWithlabels {
	c.command.append("WITHLABELS")
	return TsMrevrangeWithlabels(c)
}

func (c TsMrevrangeLatest) SelectedLabels(labels []string) TsMrevrangeSelectedLabels {
	c.command.append("SELECTED_LABELS")
	c.command.append(labels...)
	return TsMrevrangeSelectedLabels(c)
}

func (c TsMrevrangeLatest) Count(count int64) TsMrevrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsMrevrangeCount(c)
}

func (c TsMrevrangeLatest) Align(value string) TsMrevrangeAlign {
	c.command.append("ALIGN", value)
	return TsMrevrangeAlign(c)
}

func (c TsMrevrangeLatest) AggregationAvg() TsMrevrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrevrangeAggregationAggregationAvg(c)
}

func (c TsMrevrangeLatest) AggregationSum() TsMrevrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrevrangeAggregationAggregationSum(c)
}

func (c TsMrevrangeLatest) AggregationMin() TsMrevrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrevrangeAggregationAggregationMin(c)
}

func (c TsMrevrangeLatest) AggregationMax() TsMrevrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrevrangeAggregationAggregationMax(c)
}

func (c TsMrevrangeLatest) AggregationRange() TsMrevrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrevrangeAggregationAggregationRange(c)
}

func (c TsMrevrangeLatest) AggregationCount() TsMrevrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrevrangeAggregationAggregationCount(c)
}

func (c TsMrevrangeLatest) AggregationFirst() TsMrevrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrevrangeAggregationAggregationFirst(c)
}

func (c TsMrevrangeLatest) AggregationLast() TsMrevrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrevrangeAggregationAggregationLast(c)
}

func (c TsMrevrangeLatest) AggregationStdP() TsMrevrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrevrangeAggregationAggregationStdP(c)
}

func (c TsMrevrangeLatest) AggregationStdS() TsMrevrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrevrangeAggregationAggregationStdS(c)
}

func (c TsMrevrangeLatest) AggregationVarP() TsMrevrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrevrangeAggregationAggregationVarP(c)
}

func (c TsMrevrangeLatest) AggregationVarS() TsMrevrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrevrangeAggregationAggregationVarS(c)
}

func (c TsMrevrangeLatest) AggregationTwa() TsMrevrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrevrangeAggregationAggregationTwa(c)
}

func (c TsMrevrangeLatest) Filter(filter ...string) TsMrevrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrevrangeFilter(c)
}

type TsMrevrangeSelectedLabels Base

func (c TsMrevrangeSelectedLabels) Count(count int64) TsMrevrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsMrevrangeCount(c)
}

func (c TsMrevrangeSelectedLabels) Align(value string) TsMrevrangeAlign {
	c.command.append("ALIGN", value)
	return TsMrevrangeAlign(c)
}

func (c TsMrevrangeSelectedLabels) AggregationAvg() TsMrevrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrevrangeAggregationAggregationAvg(c)
}

func (c TsMrevrangeSelectedLabels) AggregationSum() TsMrevrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrevrangeAggregationAggregationSum(c)
}

func (c TsMrevrangeSelectedLabels) AggregationMin() TsMrevrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrevrangeAggregationAggregationMin(c)
}

func (c TsMrevrangeSelectedLabels) AggregationMax() TsMrevrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrevrangeAggregationAggregationMax(c)
}

func (c TsMrevrangeSelectedLabels) AggregationRange() TsMrevrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrevrangeAggregationAggregationRange(c)
}

func (c TsMrevrangeSelectedLabels) AggregationCount() TsMrevrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrevrangeAggregationAggregationCount(c)
}

func (c TsMrevrangeSelectedLabels) AggregationFirst() TsMrevrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrevrangeAggregationAggregationFirst(c)
}

func (c TsMrevrangeSelectedLabels) AggregationLast() TsMrevrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrevrangeAggregationAggregationLast(c)
}

func (c TsMrevrangeSelectedLabels) AggregationStdP() TsMrevrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrevrangeAggregationAggregationStdP(c)
}

func (c TsMrevrangeSelectedLabels) AggregationStdS() TsMrevrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrevrangeAggregationAggregationStdS(c)
}

func (c TsMrevrangeSelectedLabels) AggregationVarP() TsMrevrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrevrangeAggregationAggregationVarP(c)
}

func (c TsMrevrangeSelectedLabels) AggregationVarS() TsMrevrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrevrangeAggregationAggregationVarS(c)
}

func (c TsMrevrangeSelectedLabels) AggregationTwa() TsMrevrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrevrangeAggregationAggregationTwa(c)
}

func (c TsMrevrangeSelectedLabels) Filter(filter ...string) TsMrevrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrevrangeFilter(c)
}

type TsMrevrangeTotimestamp Base

func (c TsMrevrangeTotimestamp) Latest() TsMrevrangeLatest {
	c.command.append("LATEST")
	return TsMrevrangeLatest(c)
}

func (c TsMrevrangeTotimestamp) FilterByTs(timestamp ...int64) TsMrevrangeFilterByTs {
	c.command.append("FILTER_BY_TS")
	for _, n := range timestamp {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return TsMrevrangeFilterByTs(c)
}

func (c TsMrevrangeTotimestamp) FilterByValue(min float64, max float64) TsMrevrangeFilterByValue {
	c.command.append("FILTER_BY_VALUE", strconv.FormatFloat(min, 'f', -1, 64), strconv.FormatFloat(max, 'f', -1, 64))
	return TsMrevrangeFilterByValue(c)
}

func (c TsMrevrangeTotimestamp) Withlabels() TsMrevrangeWithlabels {
	c.command.append("WITHLABELS")
	return TsMrevrangeWithlabels(c)
}

func (c TsMrevrangeTotimestamp) SelectedLabels(labels []string) TsMrevrangeSelectedLabels {
	c.command.append("SELECTED_LABELS")
	c.command.append(labels...)
	return TsMrevrangeSelectedLabels(c)
}

func (c TsMrevrangeTotimestamp) Count(count int64) TsMrevrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsMrevrangeCount(c)
}

func (c TsMrevrangeTotimestamp) Align(value string) TsMrevrangeAlign {
	c.command.append("ALIGN", value)
	return TsMrevrangeAlign(c)
}

func (c TsMrevrangeTotimestamp) AggregationAvg() TsMrevrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrevrangeAggregationAggregationAvg(c)
}

func (c TsMrevrangeTotimestamp) AggregationSum() TsMrevrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrevrangeAggregationAggregationSum(c)
}

func (c TsMrevrangeTotimestamp) AggregationMin() TsMrevrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrevrangeAggregationAggregationMin(c)
}

func (c TsMrevrangeTotimestamp) AggregationMax() TsMrevrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrevrangeAggregationAggregationMax(c)
}

func (c TsMrevrangeTotimestamp) AggregationRange() TsMrevrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrevrangeAggregationAggregationRange(c)
}

func (c TsMrevrangeTotimestamp) AggregationCount() TsMrevrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrevrangeAggregationAggregationCount(c)
}

func (c TsMrevrangeTotimestamp) AggregationFirst() TsMrevrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrevrangeAggregationAggregationFirst(c)
}

func (c TsMrevrangeTotimestamp) AggregationLast() TsMrevrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrevrangeAggregationAggregationLast(c)
}

func (c TsMrevrangeTotimestamp) AggregationStdP() TsMrevrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrevrangeAggregationAggregationStdP(c)
}

func (c TsMrevrangeTotimestamp) AggregationStdS() TsMrevrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrevrangeAggregationAggregationStdS(c)
}

func (c TsMrevrangeTotimestamp) AggregationVarP() TsMrevrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrevrangeAggregationAggregationVarP(c)
}

func (c TsMrevrangeTotimestamp) AggregationVarS() TsMrevrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrevrangeAggregationAggregationVarS(c)
}

func (c TsMrevrangeTotimestamp) AggregationTwa() TsMrevrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrevrangeAggregationAggregationTwa(c)
}

func (c TsMrevrangeTotimestamp) Filter(filter ...string) TsMrevrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrevrangeFilter(c)
}

type TsMrevrangeWithlabels Base

func (c TsMrevrangeWithlabels) Count(count int64) TsMrevrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsMrevrangeCount(c)
}

func (c TsMrevrangeWithlabels) Align(value string) TsMrevrangeAlign {
	c.command.append("ALIGN", value)
	return TsMrevrangeAlign(c)
}

func (c TsMrevrangeWithlabels) AggregationAvg() TsMrevrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsMrevrangeAggregationAggregationAvg(c)
}

func (c TsMrevrangeWithlabels) AggregationSum() TsMrevrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsMrevrangeAggregationAggregationSum(c)
}

func (c TsMrevrangeWithlabels) AggregationMin() TsMrevrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsMrevrangeAggregationAggregationMin(c)
}

func (c TsMrevrangeWithlabels) AggregationMax() TsMrevrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsMrevrangeAggregationAggregationMax(c)
}

func (c TsMrevrangeWithlabels) AggregationRange() TsMrevrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsMrevrangeAggregationAggregationRange(c)
}

func (c TsMrevrangeWithlabels) AggregationCount() TsMrevrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsMrevrangeAggregationAggregationCount(c)
}

func (c TsMrevrangeWithlabels) AggregationFirst() TsMrevrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsMrevrangeAggregationAggregationFirst(c)
}

func (c TsMrevrangeWithlabels) AggregationLast() TsMrevrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsMrevrangeAggregationAggregationLast(c)
}

func (c TsMrevrangeWithlabels) AggregationStdP() TsMrevrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsMrevrangeAggregationAggregationStdP(c)
}

func (c TsMrevrangeWithlabels) AggregationStdS() TsMrevrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsMrevrangeAggregationAggregationStdS(c)
}

func (c TsMrevrangeWithlabels) AggregationVarP() TsMrevrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsMrevrangeAggregationAggregationVarP(c)
}

func (c TsMrevrangeWithlabels) AggregationVarS() TsMrevrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsMrevrangeAggregationAggregationVarS(c)
}

func (c TsMrevrangeWithlabels) AggregationTwa() TsMrevrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsMrevrangeAggregationAggregationTwa(c)
}

func (c TsMrevrangeWithlabels) Filter(filter ...string) TsMrevrangeFilter {
	c.command.append("FILTER")
	c.command.append(filter...)
	return TsMrevrangeFilter(c)
}

// Get all the keys matching the filter list.
//
// Time complexity: O(n) where n is the number of time-series that match the filters
type TsQueryindex Base

// Get all the keys matching the filter list
//
// Command: TS.QUERYINDEX.
//
// Time complexity: O(n) where n is the number of time-series that match the filters
func (b Builder) TsQueryindex() TsQueryindex {
	c := TsQueryindex{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("TS.QUERYINDEX")
	return c
}

func (c TsQueryindex) Filter(filter ...string) TsQueryindexFilter {
	c.command.append(filter...)
	return TsQueryindexFilter(c)
}

type TsQueryindexFilter Base

func (c TsQueryindexFilter) Filter(filter ...string) TsQueryindexFilter {
	c.command.append(filter...)
	return c
}

// Return Completed Redis command.
func (c TsQueryindexFilter) Build() Completed {
	return completed(c)
}

// Query a range in forward direction.
//
// Time complexity: O(n/m+k) where n = Number of data points, m = Chunk size (data points per chunk), k = Number of data points that are in the requested range
type TsRange Base

// Query a range in forward direction
//
// Command: TS.RANGE.
//
// Time complexity: O(n/m+k) where n = Number of data points, m = Chunk size (data points per chunk), k = Number of data points that are in the requested range
func (b Builder) TsRange() TsRange {
	c := TsRange{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("TS.RANGE")
	return c
}

func (c TsRange) Key(key string) TsRangeKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TsRangeKey(c)
}

type TsRangeAggregationAggregationAvg Base

func (c TsRangeAggregationAggregationAvg) Bucketduration(bucketduration int64) TsRangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRangeAggregationBucketduration(c)
}

type TsRangeAggregationAggregationCount Base

func (c TsRangeAggregationAggregationCount) Bucketduration(bucketduration int64) TsRangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRangeAggregationBucketduration(c)
}

type TsRangeAggregationAggregationFirst Base

func (c TsRangeAggregationAggregationFirst) Bucketduration(bucketduration int64) TsRangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRangeAggregationBucketduration(c)
}

type TsRangeAggregationAggregationLast Base

func (c TsRangeAggregationAggregationLast) Bucketduration(bucketduration int64) TsRangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRangeAggregationBucketduration(c)
}

type TsRangeAggregationAggregationMax Base

func (c TsRangeAggregationAggregationMax) Bucketduration(bucketduration int64) TsRangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRangeAggregationBucketduration(c)
}

type TsRangeAggregationAggregationMin Base

func (c TsRangeAggregationAggregationMin) Bucketduration(bucketduration int64) TsRangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRangeAggregationBucketduration(c)
}

type TsRangeAggregationAggregationRange Base

func (c TsRangeAggregationAggregationRange) Bucketduration(bucketduration int64) TsRangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRangeAggregationBucketduration(c)
}

type TsRangeAggregationAggregationStdP Base

func (c TsRangeAggregationAggregationStdP) Bucketduration(bucketduration int64) TsRangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRangeAggregationBucketduration(c)
}

type TsRangeAggregationAggregationStdS Base

func (c TsRangeAggregationAggregationStdS) Bucketduration(bucketduration int64) TsRangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRangeAggregationBucketduration(c)
}

type TsRangeAggregationAggregationSum Base

func (c TsRangeAggregationAggregationSum) Bucketduration(bucketduration int64) TsRangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRangeAggregationBucketduration(c)
}

type TsRangeAggregationAggregationTwa Base

func (c TsRangeAggregationAggregationTwa) Bucketduration(bucketduration int64) TsRangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRangeAggregationBucketduration(c)
}

type TsRangeAggregationAggregationVarP Base

func (c TsRangeAggregationAggregationVarP) Bucketduration(bucketduration int64) TsRangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRangeAggregationBucketduration(c)
}

type TsRangeAggregationAggregationVarS Base

func (c TsRangeAggregationAggregationVarS) Bucketduration(bucketduration int64) TsRangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRangeAggregationBucketduration(c)
}

type TsRangeAggregationBucketduration Base

func (c TsRangeAggregationBucketduration) Buckettimestamp(buckettimestamp string) TsRangeAggregationBuckettimestamp {
	c.command.append("BUCKETTIMESTAMP", buckettimestamp)
	return TsRangeAggregationBuckettimestamp(c)
}

func (c TsRangeAggregationBucketduration) Empty() TsRangeAggregationEmpty {
	c.command.append("EMPTY")
	return TsRangeAggregationEmpty(c)
}

// Return Completed Redis command.
func (c TsRangeAggregationBucketduration) Build() Completed {
	return completed(c)
}

type TsRangeAggregationBuckettimestamp Base

func (c TsRangeAggregationBuckettimestamp) Empty() TsRangeAggregationEmpty {
	c.command.append("EMPTY")
	return TsRangeAggregationEmpty(c)
}

// Return Completed Redis command.
func (c TsRangeAggregationBuckettimestamp) Build() Completed {
	return completed(c)
}

type TsRangeAggregationEmpty Base

// Return Completed Redis command.
func (c TsRangeAggregationEmpty) Build() Completed {
	return completed(c)
}

type TsRangeAlign Base

func (c TsRangeAlign) AggregationAvg() TsRangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsRangeAggregationAggregationAvg(c)
}

func (c TsRangeAlign) AggregationSum() TsRangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsRangeAggregationAggregationSum(c)
}

func (c TsRangeAlign) AggregationMin() TsRangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsRangeAggregationAggregationMin(c)
}

func (c TsRangeAlign) AggregationMax() TsRangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsRangeAggregationAggregationMax(c)
}

func (c TsRangeAlign) AggregationRange() TsRangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsRangeAggregationAggregationRange(c)
}

func (c TsRangeAlign) AggregationCount() TsRangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsRangeAggregationAggregationCount(c)
}

func (c TsRangeAlign) AggregationFirst() TsRangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsRangeAggregationAggregationFirst(c)
}

func (c TsRangeAlign) AggregationLast() TsRangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsRangeAggregationAggregationLast(c)
}

func (c TsRangeAlign) AggregationStdP() TsRangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsRangeAggregationAggregationStdP(c)
}

func (c TsRangeAlign) AggregationStdS() TsRangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsRangeAggregationAggregationStdS(c)
}

func (c TsRangeAlign) AggregationVarP() TsRangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsRangeAggregationAggregationVarP(c)
}

func (c TsRangeAlign) AggregationVarS() TsRangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsRangeAggregationAggregationVarS(c)
}

func (c TsRangeAlign) AggregationTwa() TsRangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsRangeAggregationAggregationTwa(c)
}

// Return Completed Redis command.
func (c TsRangeAlign) Build() Completed {
	return completed(c)
}

type TsRangeCount Base

func (c TsRangeCount) Align(value string) TsRangeAlign {
	c.command.append("ALIGN", value)
	return TsRangeAlign(c)
}

func (c TsRangeCount) AggregationAvg() TsRangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsRangeAggregationAggregationAvg(c)
}

func (c TsRangeCount) AggregationSum() TsRangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsRangeAggregationAggregationSum(c)
}

func (c TsRangeCount) AggregationMin() TsRangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsRangeAggregationAggregationMin(c)
}

func (c TsRangeCount) AggregationMax() TsRangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsRangeAggregationAggregationMax(c)
}

func (c TsRangeCount) AggregationRange() TsRangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsRangeAggregationAggregationRange(c)
}

func (c TsRangeCount) AggregationCount() TsRangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsRangeAggregationAggregationCount(c)
}

func (c TsRangeCount) AggregationFirst() TsRangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsRangeAggregationAggregationFirst(c)
}

func (c TsRangeCount) AggregationLast() TsRangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsRangeAggregationAggregationLast(c)
}

func (c TsRangeCount) AggregationStdP() TsRangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsRangeAggregationAggregationStdP(c)
}

func (c TsRangeCount) AggregationStdS() TsRangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsRangeAggregationAggregationStdS(c)
}

func (c TsRangeCount) AggregationVarP() TsRangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsRangeAggregationAggregationVarP(c)
}

func (c TsRangeCount) AggregationVarS() TsRangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsRangeAggregationAggregationVarS(c)
}

func (c TsRangeCount) AggregationTwa() TsRangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsRangeAggregationAggregationTwa(c)
}

// Return Completed Redis command.
func (c TsRangeCount) Build() Completed {
	return completed(c)
}

type TsRangeFilterByTs Base

func (c TsRangeFilterByTs) FilterByTs(timestamp ...int64) TsRangeFilterByTs {
	c.command.append("FILTER_BY_TS")
	for _, n := range timestamp {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return c
}

func (c TsRangeFilterByTs) FilterByValue(min float64, max float64) TsRangeFilterByValue {
	c.command.append("FILTER_BY_VALUE", strconv.FormatFloat(min, 'f', -1, 64), strconv.FormatFloat(max, 'f', -1, 64))
	return TsRangeFilterByValue(c)
}

func (c TsRangeFilterByTs) Count(count int64) TsRangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsRangeCount(c)
}

func (c TsRangeFilterByTs) Align(value string) TsRangeAlign {
	c.command.append("ALIGN", value)
	return TsRangeAlign(c)
}

func (c TsRangeFilterByTs) AggregationAvg() TsRangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsRangeAggregationAggregationAvg(c)
}

func (c TsRangeFilterByTs) AggregationSum() TsRangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsRangeAggregationAggregationSum(c)
}

func (c TsRangeFilterByTs) AggregationMin() TsRangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsRangeAggregationAggregationMin(c)
}

func (c TsRangeFilterByTs) AggregationMax() TsRangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsRangeAggregationAggregationMax(c)
}

func (c TsRangeFilterByTs) AggregationRange() TsRangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsRangeAggregationAggregationRange(c)
}

func (c TsRangeFilterByTs) AggregationCount() TsRangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsRangeAggregationAggregationCount(c)
}

func (c TsRangeFilterByTs) AggregationFirst() TsRangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsRangeAggregationAggregationFirst(c)
}

func (c TsRangeFilterByTs) AggregationLast() TsRangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsRangeAggregationAggregationLast(c)
}

func (c TsRangeFilterByTs) AggregationStdP() TsRangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsRangeAggregationAggregationStdP(c)
}

func (c TsRangeFilterByTs) AggregationStdS() TsRangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsRangeAggregationAggregationStdS(c)
}

func (c TsRangeFilterByTs) AggregationVarP() TsRangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsRangeAggregationAggregationVarP(c)
}

func (c TsRangeFilterByTs) AggregationVarS() TsRangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsRangeAggregationAggregationVarS(c)
}

func (c TsRangeFilterByTs) AggregationTwa() TsRangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsRangeAggregationAggregationTwa(c)
}

// Return Completed Redis command.
func (c TsRangeFilterByTs) Build() Completed {
	return completed(c)
}

type TsRangeFilterByValue Base

func (c TsRangeFilterByValue) Count(count int64) TsRangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsRangeCount(c)
}

func (c TsRangeFilterByValue) Align(value string) TsRangeAlign {
	c.command.append("ALIGN", value)
	return TsRangeAlign(c)
}

func (c TsRangeFilterByValue) AggregationAvg() TsRangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsRangeAggregationAggregationAvg(c)
}

func (c TsRangeFilterByValue) AggregationSum() TsRangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsRangeAggregationAggregationSum(c)
}

func (c TsRangeFilterByValue) AggregationMin() TsRangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsRangeAggregationAggregationMin(c)
}

func (c TsRangeFilterByValue) AggregationMax() TsRangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsRangeAggregationAggregationMax(c)
}

func (c TsRangeFilterByValue) AggregationRange() TsRangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsRangeAggregationAggregationRange(c)
}

func (c TsRangeFilterByValue) AggregationCount() TsRangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsRangeAggregationAggregationCount(c)
}

func (c TsRangeFilterByValue) AggregationFirst() TsRangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsRangeAggregationAggregationFirst(c)
}

func (c TsRangeFilterByValue) AggregationLast() TsRangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsRangeAggregationAggregationLast(c)
}

func (c TsRangeFilterByValue) AggregationStdP() TsRangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsRangeAggregationAggregationStdP(c)
}

func (c TsRangeFilterByValue) AggregationStdS() TsRangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsRangeAggregationAggregationStdS(c)
}

func (c TsRangeFilterByValue) AggregationVarP() TsRangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsRangeAggregationAggregationVarP(c)
}

func (c TsRangeFilterByValue) AggregationVarS() TsRangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsRangeAggregationAggregationVarS(c)
}

func (c TsRangeFilterByValue) AggregationTwa() TsRangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsRangeAggregationAggregationTwa(c)
}

// Return Completed Redis command.
func (c TsRangeFilterByValue) Build() Completed {
	return completed(c)
}

type TsRangeFromtimestamp Base

func (c TsRangeFromtimestamp) Totimestamp(totimestamp int64) TsRangeTotimestamp {
	c.command.append(strconv.FormatInt(totimestamp, 10))
	return TsRangeTotimestamp(c)
}

type TsRangeKey Base

func (c TsRangeKey) Fromtimestamp(fromtimestamp int64) TsRangeFromtimestamp {
	c.command.append(strconv.FormatInt(fromtimestamp, 10))
	return TsRangeFromtimestamp(c)
}

type TsRangeLatest Base

func (c TsRangeLatest) FilterByTs(timestamp ...int64) TsRangeFilterByTs {
	c.command.append("FILTER_BY_TS")
	for _, n := range timestamp {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return TsRangeFilterByTs(c)
}

func (c TsRangeLatest) FilterByValue(min float64, max float64) TsRangeFilterByValue {
	c.command.append("FILTER_BY_VALUE", strconv.FormatFloat(min, 'f', -1, 64), strconv.FormatFloat(max, 'f', -1, 64))
	return TsRangeFilterByValue(c)
}

func (c TsRangeLatest) Count(count int64) TsRangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsRangeCount(c)
}

func (c TsRangeLatest) Align(value string) TsRangeAlign {
	c.command.append("ALIGN", value)
	return TsRangeAlign(c)
}

func (c TsRangeLatest) AggregationAvg() TsRangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsRangeAggregationAggregationAvg(c)
}

func (c TsRangeLatest) AggregationSum() TsRangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsRangeAggregationAggregationSum(c)
}

func (c TsRangeLatest) AggregationMin() TsRangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsRangeAggregationAggregationMin(c)
}

func (c TsRangeLatest) AggregationMax() TsRangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsRangeAggregationAggregationMax(c)
}

func (c TsRangeLatest) AggregationRange() TsRangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsRangeAggregationAggregationRange(c)
}

func (c TsRangeLatest) AggregationCount() TsRangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsRangeAggregationAggregationCount(c)
}

func (c TsRangeLatest) AggregationFirst() TsRangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsRangeAggregationAggregationFirst(c)
}

func (c TsRangeLatest) AggregationLast() TsRangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsRangeAggregationAggregationLast(c)
}

func (c TsRangeLatest) AggregationStdP() TsRangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsRangeAggregationAggregationStdP(c)
}

func (c TsRangeLatest) AggregationStdS() TsRangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsRangeAggregationAggregationStdS(c)
}

func (c TsRangeLatest) AggregationVarP() TsRangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsRangeAggregationAggregationVarP(c)
}

func (c TsRangeLatest) AggregationVarS() TsRangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsRangeAggregationAggregationVarS(c)
}

func (c TsRangeLatest) AggregationTwa() TsRangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsRangeAggregationAggregationTwa(c)
}

// Return Completed Redis command.
func (c TsRangeLatest) Build() Completed {
	return completed(c)
}

type TsRangeTotimestamp Base

func (c TsRangeTotimestamp) Latest() TsRangeLatest {
	c.command.append("LATEST")
	return TsRangeLatest(c)
}

func (c TsRangeTotimestamp) FilterByTs(timestamp ...int64) TsRangeFilterByTs {
	c.command.append("FILTER_BY_TS")
	for _, n := range timestamp {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return TsRangeFilterByTs(c)
}

func (c TsRangeTotimestamp) FilterByValue(min float64, max float64) TsRangeFilterByValue {
	c.command.append("FILTER_BY_VALUE", strconv.FormatFloat(min, 'f', -1, 64), strconv.FormatFloat(max, 'f', -1, 64))
	return TsRangeFilterByValue(c)
}

func (c TsRangeTotimestamp) Count(count int64) TsRangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsRangeCount(c)
}

func (c TsRangeTotimestamp) Align(value string) TsRangeAlign {
	c.command.append("ALIGN", value)
	return TsRangeAlign(c)
}

func (c TsRangeTotimestamp) AggregationAvg() TsRangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsRangeAggregationAggregationAvg(c)
}

func (c TsRangeTotimestamp) AggregationSum() TsRangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsRangeAggregationAggregationSum(c)
}

func (c TsRangeTotimestamp) AggregationMin() TsRangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsRangeAggregationAggregationMin(c)
}

func (c TsRangeTotimestamp) AggregationMax() TsRangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsRangeAggregationAggregationMax(c)
}

func (c TsRangeTotimestamp) AggregationRange() TsRangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsRangeAggregationAggregationRange(c)
}

func (c TsRangeTotimestamp) AggregationCount() TsRangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsRangeAggregationAggregationCount(c)
}

func (c TsRangeTotimestamp) AggregationFirst() TsRangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsRangeAggregationAggregationFirst(c)
}

func (c TsRangeTotimestamp) AggregationLast() TsRangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsRangeAggregationAggregationLast(c)
}

func (c TsRangeTotimestamp) AggregationStdP() TsRangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsRangeAggregationAggregationStdP(c)
}

func (c TsRangeTotimestamp) AggregationStdS() TsRangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsRangeAggregationAggregationStdS(c)
}

func (c TsRangeTotimestamp) AggregationVarP() TsRangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsRangeAggregationAggregationVarP(c)
}

func (c TsRangeTotimestamp) AggregationVarS() TsRangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsRangeAggregationAggregationVarS(c)
}

func (c TsRangeTotimestamp) AggregationTwa() TsRangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsRangeAggregationAggregationTwa(c)
}

// Return Completed Redis command.
func (c TsRangeTotimestamp) Build() Completed {
	return completed(c)
}

// Query a range in reverse direction.
//
// Time complexity: O(n/m+k) where n = Number of data points, m = Chunk size (data points per chunk), k = Number of data points that are in the requested range
type TsRevrange Base

// Query a range in reverse direction
//
// Command: TS.REVRANGE.
//
// Time complexity: O(n/m+k) where n = Number of data points, m = Chunk size (data points per chunk), k = Number of data points that are in the requested range
func (b Builder) TsRevrange() TsRevrange {
	c := TsRevrange{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("TS.REVRANGE")
	return c
}

func (c TsRevrange) Key(key string) TsRevrangeKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TsRevrangeKey(c)
}

type TsRevrangeAggregationAggregationAvg Base

func (c TsRevrangeAggregationAggregationAvg) Bucketduration(bucketduration int64) TsRevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRevrangeAggregationBucketduration(c)
}

type TsRevrangeAggregationAggregationCount Base

func (c TsRevrangeAggregationAggregationCount) Bucketduration(bucketduration int64) TsRevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRevrangeAggregationBucketduration(c)
}

type TsRevrangeAggregationAggregationFirst Base

func (c TsRevrangeAggregationAggregationFirst) Bucketduration(bucketduration int64) TsRevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRevrangeAggregationBucketduration(c)
}

type TsRevrangeAggregationAggregationLast Base

func (c TsRevrangeAggregationAggregationLast) Bucketduration(bucketduration int64) TsRevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRevrangeAggregationBucketduration(c)
}

type TsRevrangeAggregationAggregationMax Base

func (c TsRevrangeAggregationAggregationMax) Bucketduration(bucketduration int64) TsRevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRevrangeAggregationBucketduration(c)
}

type TsRevrangeAggregationAggregationMin Base

func (c TsRevrangeAggregationAggregationMin) Bucketduration(bucketduration int64) TsRevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRevrangeAggregationBucketduration(c)
}

type TsRevrangeAggregationAggregationRange Base

func (c TsRevrangeAggregationAggregationRange) Bucketduration(bucketduration int64) TsRevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRevrangeAggregationBucketduration(c)
}

type TsRevrangeAggregationAggregationStdP Base

func (c TsRevrangeAggregationAggregationStdP) Bucketduration(bucketduration int64) TsRevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRevrangeAggregationBucketduration(c)
}

type TsRevrangeAggregationAggregationStdS Base

func (c TsRevrangeAggregationAggregationStdS) Bucketduration(bucketduration int64) TsRevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRevrangeAggregationBucketduration(c)
}

type TsRevrangeAggregationAggregationSum Base

func (c TsRevrangeAggregationAggregationSum) Bucketduration(bucketduration int64) TsRevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRevrangeAggregationBucketduration(c)
}

type TsRevrangeAggregationAggregationTwa Base

func (c TsRevrangeAggregationAggregationTwa) Bucketduration(bucketduration int64) TsRevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRevrangeAggregationBucketduration(c)
}

type TsRevrangeAggregationAggregationVarP Base

func (c TsRevrangeAggregationAggregationVarP) Bucketduration(bucketduration int64) TsRevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRevrangeAggregationBucketduration(c)
}

type TsRevrangeAggregationAggregationVarS Base

func (c TsRevrangeAggregationAggregationVarS) Bucketduration(bucketduration int64) TsRevrangeAggregationBucketduration {
	c.command.append(strconv.FormatInt(bucketduration, 10))
	return TsRevrangeAggregationBucketduration(c)
}

type TsRevrangeAggregationBucketduration Base

func (c TsRevrangeAggregationBucketduration) Buckettimestamp(buckettimestamp string) TsRevrangeAggregationBuckettimestamp {
	c.command.append("BUCKETTIMESTAMP", buckettimestamp)
	return TsRevrangeAggregationBuckettimestamp(c)
}

func (c TsRevrangeAggregationBucketduration) Empty() TsRevrangeAggregationEmpty {
	c.command.append("EMPTY")
	return TsRevrangeAggregationEmpty(c)
}

// Return Completed Redis command.
func (c TsRevrangeAggregationBucketduration) Build() Completed {
	return completed(c)
}

type TsRevrangeAggregationBuckettimestamp Base

func (c TsRevrangeAggregationBuckettimestamp) Empty() TsRevrangeAggregationEmpty {
	c.command.append("EMPTY")
	return TsRevrangeAggregationEmpty(c)
}

// Return Completed Redis command.
func (c TsRevrangeAggregationBuckettimestamp) Build() Completed {
	return completed(c)
}

type TsRevrangeAggregationEmpty Base

// Return Completed Redis command.
func (c TsRevrangeAggregationEmpty) Build() Completed {
	return completed(c)
}

type TsRevrangeAlign Base

func (c TsRevrangeAlign) AggregationAvg() TsRevrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsRevrangeAggregationAggregationAvg(c)
}

func (c TsRevrangeAlign) AggregationSum() TsRevrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsRevrangeAggregationAggregationSum(c)
}

func (c TsRevrangeAlign) AggregationMin() TsRevrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsRevrangeAggregationAggregationMin(c)
}

func (c TsRevrangeAlign) AggregationMax() TsRevrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsRevrangeAggregationAggregationMax(c)
}

func (c TsRevrangeAlign) AggregationRange() TsRevrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsRevrangeAggregationAggregationRange(c)
}

func (c TsRevrangeAlign) AggregationCount() TsRevrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsRevrangeAggregationAggregationCount(c)
}

func (c TsRevrangeAlign) AggregationFirst() TsRevrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsRevrangeAggregationAggregationFirst(c)
}

func (c TsRevrangeAlign) AggregationLast() TsRevrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsRevrangeAggregationAggregationLast(c)
}

func (c TsRevrangeAlign) AggregationStdP() TsRevrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsRevrangeAggregationAggregationStdP(c)
}

func (c TsRevrangeAlign) AggregationStdS() TsRevrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsRevrangeAggregationAggregationStdS(c)
}

func (c TsRevrangeAlign) AggregationVarP() TsRevrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsRevrangeAggregationAggregationVarP(c)
}

func (c TsRevrangeAlign) AggregationVarS() TsRevrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsRevrangeAggregationAggregationVarS(c)
}

func (c TsRevrangeAlign) AggregationTwa() TsRevrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsRevrangeAggregationAggregationTwa(c)
}

// Return Completed Redis command.
func (c TsRevrangeAlign) Build() Completed {
	return completed(c)
}

type TsRevrangeCount Base

func (c TsRevrangeCount) Align(value string) TsRevrangeAlign {
	c.command.append("ALIGN", value)
	return TsRevrangeAlign(c)
}

func (c TsRevrangeCount) AggregationAvg() TsRevrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsRevrangeAggregationAggregationAvg(c)
}

func (c TsRevrangeCount) AggregationSum() TsRevrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsRevrangeAggregationAggregationSum(c)
}

func (c TsRevrangeCount) AggregationMin() TsRevrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsRevrangeAggregationAggregationMin(c)
}

func (c TsRevrangeCount) AggregationMax() TsRevrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsRevrangeAggregationAggregationMax(c)
}

func (c TsRevrangeCount) AggregationRange() TsRevrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsRevrangeAggregationAggregationRange(c)
}

func (c TsRevrangeCount) AggregationCount() TsRevrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsRevrangeAggregationAggregationCount(c)
}

func (c TsRevrangeCount) AggregationFirst() TsRevrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsRevrangeAggregationAggregationFirst(c)
}

func (c TsRevrangeCount) AggregationLast() TsRevrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsRevrangeAggregationAggregationLast(c)
}

func (c TsRevrangeCount) AggregationStdP() TsRevrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsRevrangeAggregationAggregationStdP(c)
}

func (c TsRevrangeCount) AggregationStdS() TsRevrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsRevrangeAggregationAggregationStdS(c)
}

func (c TsRevrangeCount) AggregationVarP() TsRevrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsRevrangeAggregationAggregationVarP(c)
}

func (c TsRevrangeCount) AggregationVarS() TsRevrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsRevrangeAggregationAggregationVarS(c)
}

func (c TsRevrangeCount) AggregationTwa() TsRevrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsRevrangeAggregationAggregationTwa(c)
}

// Return Completed Redis command.
func (c TsRevrangeCount) Build() Completed {
	return completed(c)
}

type TsRevrangeFilterByTs Base

func (c TsRevrangeFilterByTs) FilterByTs(timestamp ...int64) TsRevrangeFilterByTs {
	c.command.append("FILTER_BY_TS")
	for _, n := range timestamp {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return c
}

func (c TsRevrangeFilterByTs) FilterByValue(min float64, max float64) TsRevrangeFilterByValue {
	c.command.append("FILTER_BY_VALUE", strconv.FormatFloat(min, 'f', -1, 64), strconv.FormatFloat(max, 'f', -1, 64))
	return TsRevrangeFilterByValue(c)
}

func (c TsRevrangeFilterByTs) Count(count int64) TsRevrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsRevrangeCount(c)
}

func (c TsRevrangeFilterByTs) Align(value string) TsRevrangeAlign {
	c.command.append("ALIGN", value)
	return TsRevrangeAlign(c)
}

func (c TsRevrangeFilterByTs) AggregationAvg() TsRevrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsRevrangeAggregationAggregationAvg(c)
}

func (c TsRevrangeFilterByTs) AggregationSum() TsRevrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsRevrangeAggregationAggregationSum(c)
}

func (c TsRevrangeFilterByTs) AggregationMin() TsRevrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsRevrangeAggregationAggregationMin(c)
}

func (c TsRevrangeFilterByTs) AggregationMax() TsRevrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsRevrangeAggregationAggregationMax(c)
}

func (c TsRevrangeFilterByTs) AggregationRange() TsRevrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsRevrangeAggregationAggregationRange(c)
}

func (c TsRevrangeFilterByTs) AggregationCount() TsRevrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsRevrangeAggregationAggregationCount(c)
}

func (c TsRevrangeFilterByTs) AggregationFirst() TsRevrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsRevrangeAggregationAggregationFirst(c)
}

func (c TsRevrangeFilterByTs) AggregationLast() TsRevrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsRevrangeAggregationAggregationLast(c)
}

func (c TsRevrangeFilterByTs) AggregationStdP() TsRevrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsRevrangeAggregationAggregationStdP(c)
}

func (c TsRevrangeFilterByTs) AggregationStdS() TsRevrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsRevrangeAggregationAggregationStdS(c)
}

func (c TsRevrangeFilterByTs) AggregationVarP() TsRevrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsRevrangeAggregationAggregationVarP(c)
}

func (c TsRevrangeFilterByTs) AggregationVarS() TsRevrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsRevrangeAggregationAggregationVarS(c)
}

func (c TsRevrangeFilterByTs) AggregationTwa() TsRevrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsRevrangeAggregationAggregationTwa(c)
}

// Return Completed Redis command.
func (c TsRevrangeFilterByTs) Build() Completed {
	return completed(c)
}

type TsRevrangeFilterByValue Base

func (c TsRevrangeFilterByValue) Count(count int64) TsRevrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsRevrangeCount(c)
}

func (c TsRevrangeFilterByValue) Align(value string) TsRevrangeAlign {
	c.command.append("ALIGN", value)
	return TsRevrangeAlign(c)
}

func (c TsRevrangeFilterByValue) AggregationAvg() TsRevrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsRevrangeAggregationAggregationAvg(c)
}

func (c TsRevrangeFilterByValue) AggregationSum() TsRevrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsRevrangeAggregationAggregationSum(c)
}

func (c TsRevrangeFilterByValue) AggregationMin() TsRevrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsRevrangeAggregationAggregationMin(c)
}

func (c TsRevrangeFilterByValue) AggregationMax() TsRevrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsRevrangeAggregationAggregationMax(c)
}

func (c TsRevrangeFilterByValue) AggregationRange() TsRevrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsRevrangeAggregationAggregationRange(c)
}

func (c TsRevrangeFilterByValue) AggregationCount() TsRevrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsRevrangeAggregationAggregationCount(c)
}

func (c TsRevrangeFilterByValue) AggregationFirst() TsRevrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsRevrangeAggregationAggregationFirst(c)
}

func (c TsRevrangeFilterByValue) AggregationLast() TsRevrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsRevrangeAggregationAggregationLast(c)
}

func (c TsRevrangeFilterByValue) AggregationStdP() TsRevrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsRevrangeAggregationAggregationStdP(c)
}

func (c TsRevrangeFilterByValue) AggregationStdS() TsRevrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsRevrangeAggregationAggregationStdS(c)
}

func (c TsRevrangeFilterByValue) AggregationVarP() TsRevrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsRevrangeAggregationAggregationVarP(c)
}

func (c TsRevrangeFilterByValue) AggregationVarS() TsRevrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsRevrangeAggregationAggregationVarS(c)
}

func (c TsRevrangeFilterByValue) AggregationTwa() TsRevrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsRevrangeAggregationAggregationTwa(c)
}

// Return Completed Redis command.
func (c TsRevrangeFilterByValue) Build() Completed {
	return completed(c)
}

type TsRevrangeFromtimestamp Base

func (c TsRevrangeFromtimestamp) Totimestamp(totimestamp int64) TsRevrangeTotimestamp {
	c.command.append(strconv.FormatInt(totimestamp, 10))
	return TsRevrangeTotimestamp(c)
}

type TsRevrangeKey Base

func (c TsRevrangeKey) Fromtimestamp(fromtimestamp int64) TsRevrangeFromtimestamp {
	c.command.append(strconv.FormatInt(fromtimestamp, 10))
	return TsRevrangeFromtimestamp(c)
}

type TsRevrangeLatest Base

func (c TsRevrangeLatest) FilterByTs(timestamp ...int64) TsRevrangeFilterByTs {
	c.command.append("FILTER_BY_TS")
	for _, n := range timestamp {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return TsRevrangeFilterByTs(c)
}

func (c TsRevrangeLatest) FilterByValue(min float64, max float64) TsRevrangeFilterByValue {
	c.command.append("FILTER_BY_VALUE", strconv.FormatFloat(min, 'f', -1, 64), strconv.FormatFloat(max, 'f', -1, 64))
	return TsRevrangeFilterByValue(c)
}

func (c TsRevrangeLatest) Count(count int64) TsRevrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsRevrangeCount(c)
}

func (c TsRevrangeLatest) Align(value string) TsRevrangeAlign {
	c.command.append("ALIGN", value)
	return TsRevrangeAlign(c)
}

func (c TsRevrangeLatest) AggregationAvg() TsRevrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsRevrangeAggregationAggregationAvg(c)
}

func (c TsRevrangeLatest) AggregationSum() TsRevrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsRevrangeAggregationAggregationSum(c)
}

func (c TsRevrangeLatest) AggregationMin() TsRevrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsRevrangeAggregationAggregationMin(c)
}

func (c TsRevrangeLatest) AggregationMax() TsRevrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsRevrangeAggregationAggregationMax(c)
}

func (c TsRevrangeLatest) AggregationRange() TsRevrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsRevrangeAggregationAggregationRange(c)
}

func (c TsRevrangeLatest) AggregationCount() TsRevrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsRevrangeAggregationAggregationCount(c)
}

func (c TsRevrangeLatest) AggregationFirst() TsRevrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsRevrangeAggregationAggregationFirst(c)
}

func (c TsRevrangeLatest) AggregationLast() TsRevrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsRevrangeAggregationAggregationLast(c)
}

func (c TsRevrangeLatest) AggregationStdP() TsRevrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsRevrangeAggregationAggregationStdP(c)
}

func (c TsRevrangeLatest) AggregationStdS() TsRevrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsRevrangeAggregationAggregationStdS(c)
}

func (c TsRevrangeLatest) AggregationVarP() TsRevrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsRevrangeAggregationAggregationVarP(c)
}

func (c TsRevrangeLatest) AggregationVarS() TsRevrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsRevrangeAggregationAggregationVarS(c)
}

func (c TsRevrangeLatest) AggregationTwa() TsRevrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsRevrangeAggregationAggregationTwa(c)
}

// Return Completed Redis command.
func (c TsRevrangeLatest) Build() Completed {
	return completed(c)
}

type TsRevrangeTotimestamp Base

func (c TsRevrangeTotimestamp) Latest() TsRevrangeLatest {
	c.command.append("LATEST")
	return TsRevrangeLatest(c)
}

func (c TsRevrangeTotimestamp) FilterByTs(timestamp ...int64) TsRevrangeFilterByTs {
	c.command.append("FILTER_BY_TS")
	for _, n := range timestamp {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return TsRevrangeFilterByTs(c)
}

func (c TsRevrangeTotimestamp) FilterByValue(min float64, max float64) TsRevrangeFilterByValue {
	c.command.append("FILTER_BY_VALUE", strconv.FormatFloat(min, 'f', -1, 64), strconv.FormatFloat(max, 'f', -1, 64))
	return TsRevrangeFilterByValue(c)
}

func (c TsRevrangeTotimestamp) Count(count int64) TsRevrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return TsRevrangeCount(c)
}

func (c TsRevrangeTotimestamp) Align(value string) TsRevrangeAlign {
	c.command.append("ALIGN", value)
	return TsRevrangeAlign(c)
}

func (c TsRevrangeTotimestamp) AggregationAvg() TsRevrangeAggregationAggregationAvg {
	c.command.append("AGGREGATION", "AVG")
	return TsRevrangeAggregationAggregationAvg(c)
}

func (c TsRevrangeTotimestamp) AggregationSum() TsRevrangeAggregationAggregationSum {
	c.command.append("AGGREGATION", "SUM")
	return TsRevrangeAggregationAggregationSum(c)
}

func (c TsRevrangeTotimestamp) AggregationMin() TsRevrangeAggregationAggregationMin {
	c.command.append("AGGREGATION", "MIN")
	return TsRevrangeAggregationAggregationMin(c)
}

func (c TsRevrangeTotimestamp) AggregationMax() TsRevrangeAggregationAggregationMax {
	c.command.append("AGGREGATION", "MAX")
	return TsRevrangeAggregationAggregationMax(c)
}

func (c TsRevrangeTotimestamp) AggregationRange() TsRevrangeAggregationAggregationRange {
	c.command.append("AGGREGATION", "RANGE")
	return TsRevrangeAggregationAggregationRange(c)
}

func (c TsRevrangeTotimestamp) AggregationCount() TsRevrangeAggregationAggregationCount {
	c.command.append("AGGREGATION", "COUNT")
	return TsRevrangeAggregationAggregationCount(c)
}

func (c TsRevrangeTotimestamp) AggregationFirst() TsRevrangeAggregationAggregationFirst {
	c.command.append("AGGREGATION", "FIRST")
	return TsRevrangeAggregationAggregationFirst(c)
}

func (c TsRevrangeTotimestamp) AggregationLast() TsRevrangeAggregationAggregationLast {
	c.command.append("AGGREGATION", "LAST")
	return TsRevrangeAggregationAggregationLast(c)
}

func (c TsRevrangeTotimestamp) AggregationStdP() TsRevrangeAggregationAggregationStdP {
	c.command.append("AGGREGATION", "STD.P")
	return TsRevrangeAggregationAggregationStdP(c)
}

func (c TsRevrangeTotimestamp) AggregationStdS() TsRevrangeAggregationAggregationStdS {
	c.command.append("AGGREGATION", "STD.S")
	return TsRevrangeAggregationAggregationStdS(c)
}

func (c TsRevrangeTotimestamp) AggregationVarP() TsRevrangeAggregationAggregationVarP {
	c.command.append("AGGREGATION", "VAR.P")
	return TsRevrangeAggregationAggregationVarP(c)
}

func (c TsRevrangeTotimestamp) AggregationVarS() TsRevrangeAggregationAggregationVarS {
	c.command.append("AGGREGATION", "VAR.S")
	return TsRevrangeAggregationAggregationVarS(c)
}

func (c TsRevrangeTotimestamp) AggregationTwa() TsRevrangeAggregationAggregationTwa {
	c.command.append("AGGREGATION", "TWA")
	return TsRevrangeAggregationAggregationTwa(c)
}

// Return Completed Redis command.
func (c TsRevrangeTotimestamp) Build() Completed {
	return completed(c)
}

// Get the time to live for a key in seconds.
//
// Time complexity: O(1)
type Ttl Base

// Get the time to live for a key in seconds
//
// Command: TTL.
//
// Time complexity: O(1)
func (b Builder) Ttl() Ttl {
	c := Ttl{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("TTL")
	return c
}

func (c Ttl) Key(key string) TtlKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TtlKey(c)
}

type TtlKey Base

// Return Completed Redis command.
func (c TtlKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c TtlKey) Cache() Cacheable {
	return cacheable(c)
}

// Determine the type stored at key.
//
// Time complexity: O(1)
type Type Base

// Determine the type stored at key
//
// Command: TYPE.
//
// Time complexity: O(1)
func (b Builder) Type() Type {
	c := Type{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("TYPE")
	return c
}

func (c Type) Key(key string) TypeKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return TypeKey(c)
}

type TypeKey Base

// Return Completed Redis command.
func (c TypeKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c TypeKey) Cache() Cacheable {
	return cacheable(c)
}

// Delete a key asynchronously in another thread. Otherwise it is just as DEL, but non blocking..
//
// Time complexity: O(1) for each key removed regardless of its size. Then the command does O(N) work in a different thread in order to reclaim memory, where N is the number of allocations the deleted objects where composed of.
type Unlink Base

// Delete a key asynchronously in another thread. Otherwise it is just as DEL, but non blocking.
//
// Command: UNLINK.
//
// Time complexity: O(1) for each key removed regardless of its size. Then the command does O(N) work in a different thread in order to reclaim memory, where N is the number of allocations the deleted objects where composed of.
func (b Builder) Unlink() Unlink {
	c := Unlink{command: emptyCommand(), cslot: b.slot}
	c.command.append("UNLINK")
	return c
}

func (c Unlink) Key(key ...string) UnlinkKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return UnlinkKey(c)
}

type UnlinkKey Base

func (c UnlinkKey) Key(key ...string) UnlinkKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c UnlinkKey) Build() Completed {
	return completed(c)
}

// Stop listening for messages posted to the given channels.
//
// Time complexity: O(N) where N is the number of clients already subscribed to a channel.
type Unsubscribe Base

// Stop listening for messages posted to the given channels
//
// Command: UNSUBSCRIBE.
//
// Time complexity: O(N) where N is the number of clients already subscribed to a channel.
func (b Builder) Unsubscribe() Unsubscribe {
	c := Unsubscribe{command: emptyCommand(), cslot: b.slot, ctags: ctagNoRet}
	c.command.append("UNSUBSCRIBE")
	return c
}

func (c Unsubscribe) Channel(channel ...string) UnsubscribeChannel {
	c.command.append(channel...)
	return UnsubscribeChannel(c)
}

// Return Completed Redis command.
func (c Unsubscribe) Build() Completed {
	return completed(c)
}

type UnsubscribeChannel Base

func (c UnsubscribeChannel) Channel(channel ...string) UnsubscribeChannel {
	c.command.append(channel...)
	return c
}

// Return Completed Redis command.
func (c UnsubscribeChannel) Build() Completed {
	return completed(c)
}

// Forget about all watched keys.
//
// Time complexity: O(1)
type Unwatch Base

// Forget about all watched keys
//
// Command: UNWATCH.
//
// Time complexity: O(1)
func (b Builder) Unwatch() Unwatch {
	c := Unwatch{command: emptyCommand(), cslot: b.slot}
	c.command.append("UNWATCH")
	return c
}

// Return Completed Redis command.
func (c Unwatch) Build() Completed {
	return completed(c)
}

// Wait for the synchronous replication of all the write commands sent in the context of the current connection.
//
// Time complexity: O(1)
type Wait Base

// Wait for the synchronous replication of all the write commands sent in the context of the current connection
//
// Command: WAIT.
//
// Time complexity: O(1)
func (b Builder) Wait() Wait {
	c := Wait{command: emptyCommand(), cslot: b.slot, ctags: ctagBlock}
	c.command.append("WAIT")
	return c
}

func (c Wait) Numreplicas(numreplicas int64) WaitNumreplicas {
	c.command.append(strconv.FormatInt(numreplicas, 10))
	return WaitNumreplicas(c)
}

type WaitNumreplicas Base

func (c WaitNumreplicas) Timeout(timeout int64) WaitTimeout {
	c.command.append(strconv.FormatInt(timeout, 10))
	return WaitTimeout(c)
}

type WaitTimeout Base

// Return Completed Redis command.
func (c WaitTimeout) Build() Completed {
	return completed(c)
}

// Watch the given keys to determine execution of the MULTI/EXEC block.
//
// Time complexity: O(1) for every key.
type Watch Base

// Watch the given keys to determine execution of the MULTI/EXEC block
//
// Command: WATCH.
//
// Time complexity: O(1) for every key.
func (b Builder) Watch() Watch {
	c := Watch{command: emptyCommand(), cslot: b.slot}
	c.command.append("WATCH")
	return c
}

func (c Watch) Key(key ...string) WatchKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return WatchKey(c)
}

type WatchKey Base

func (c WatchKey) Key(key ...string) WatchKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c WatchKey) Build() Completed {
	return completed(c)
}

// Marks a pending message as correctly processed, effectively removing it from the pending entries list of the consumer group. Return value of the command is the number of messages successfully acknowledged, that is, the IDs we were actually able to resolve in the PEL..
//
// Time complexity: O(1) for each message ID processed.
type Xack Base

// Marks a pending message as correctly processed, effectively removing it from the pending entries list of the consumer group. Return value of the command is the number of messages successfully acknowledged, that is, the IDs we were actually able to resolve in the PEL.
//
// Command: XACK.
//
// Time complexity: O(1) for each message ID processed.
func (b Builder) Xack() Xack {
	c := Xack{command: emptyCommand(), cslot: b.slot}
	c.command.append("XACK")
	return c
}

func (c Xack) Key(key string) XackKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XackKey(c)
}

type XackGroup Base

func (c XackGroup) Id(id ...string) XackId {
	c.command.append(id...)
	return XackId(c)
}

type XackId Base

func (c XackId) Id(id ...string) XackId {
	c.command.append(id...)
	return c
}

// Return Completed Redis command.
func (c XackId) Build() Completed {
	return completed(c)
}

type XackKey Base

func (c XackKey) Group(group string) XackGroup {
	c.command.append(group)
	return XackGroup(c)
}

// Appends a new entry to a stream.
//
// Time complexity: O(1) when adding a new entry, O(N) when trimming where N being the number of entries evicted.
type Xadd Base

// Appends a new entry to a stream
//
// Command: XADD.
//
// Time complexity: O(1) when adding a new entry, O(N) when trimming where N being the number of entries evicted.
func (b Builder) Xadd() Xadd {
	c := Xadd{command: emptyCommand(), cslot: b.slot}
	c.command.append("XADD")
	return c
}

func (c Xadd) Key(key string) XaddKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XaddKey(c)
}

type XaddFieldValue Base

func (c XaddFieldValue) FieldValue(field string, value string) XaddFieldValue {
	c.command.append(field, value)
	return c
}

// Return Completed Redis command.
func (c XaddFieldValue) Build() Completed {
	return completed(c)
}

type XaddId Base

func (c XaddId) FieldValue() XaddFieldValue {
	return XaddFieldValue(c)
}

type XaddKey Base

func (c XaddKey) Nomkstream() XaddNomkstream {
	c.command.append("NOMKSTREAM")
	return XaddNomkstream(c)
}

func (c XaddKey) Maxlen() XaddTrimStrategyMaxlen {
	c.command.append("MAXLEN")
	return XaddTrimStrategyMaxlen(c)
}

func (c XaddKey) Minid() XaddTrimStrategyMinid {
	c.command.append("MINID")
	return XaddTrimStrategyMinid(c)
}

func (c XaddKey) Id(id string) XaddId {
	c.command.append(id)
	return XaddId(c)
}

type XaddNomkstream Base

func (c XaddNomkstream) Maxlen() XaddTrimStrategyMaxlen {
	c.command.append("MAXLEN")
	return XaddTrimStrategyMaxlen(c)
}

func (c XaddNomkstream) Minid() XaddTrimStrategyMinid {
	c.command.append("MINID")
	return XaddTrimStrategyMinid(c)
}

func (c XaddNomkstream) Id(id string) XaddId {
	c.command.append(id)
	return XaddId(c)
}

type XaddTrimLimit Base

func (c XaddTrimLimit) Id(id string) XaddId {
	c.command.append(id)
	return XaddId(c)
}

type XaddTrimOperatorAlmost Base

func (c XaddTrimOperatorAlmost) Threshold(threshold string) XaddTrimThreshold {
	c.command.append(threshold)
	return XaddTrimThreshold(c)
}

type XaddTrimOperatorExact Base

func (c XaddTrimOperatorExact) Threshold(threshold string) XaddTrimThreshold {
	c.command.append(threshold)
	return XaddTrimThreshold(c)
}

type XaddTrimStrategyMaxlen Base

func (c XaddTrimStrategyMaxlen) Exact() XaddTrimOperatorExact {
	c.command.append("=")
	return XaddTrimOperatorExact(c)
}

func (c XaddTrimStrategyMaxlen) Almost() XaddTrimOperatorAlmost {
	c.command.append("~")
	return XaddTrimOperatorAlmost(c)
}

func (c XaddTrimStrategyMaxlen) Threshold(threshold string) XaddTrimThreshold {
	c.command.append(threshold)
	return XaddTrimThreshold(c)
}

type XaddTrimStrategyMinid Base

func (c XaddTrimStrategyMinid) Exact() XaddTrimOperatorExact {
	c.command.append("=")
	return XaddTrimOperatorExact(c)
}

func (c XaddTrimStrategyMinid) Almost() XaddTrimOperatorAlmost {
	c.command.append("~")
	return XaddTrimOperatorAlmost(c)
}

func (c XaddTrimStrategyMinid) Threshold(threshold string) XaddTrimThreshold {
	c.command.append(threshold)
	return XaddTrimThreshold(c)
}

type XaddTrimThreshold Base

func (c XaddTrimThreshold) Limit(count int64) XaddTrimLimit {
	c.command.append("LIMIT", strconv.FormatInt(count, 10))
	return XaddTrimLimit(c)
}

func (c XaddTrimThreshold) Id(id string) XaddId {
	c.command.append(id)
	return XaddId(c)
}

// Changes (or acquires) ownership of messages in a consumer group, as if the messages were delivered to the specified consumer..
//
// Time complexity: O(1) if COUNT is small.
type Xautoclaim Base

// Changes (or acquires) ownership of messages in a consumer group, as if the messages were delivered to the specified consumer.
//
// Command: XAUTOCLAIM.
//
// Time complexity: O(1) if COUNT is small.
func (b Builder) Xautoclaim() Xautoclaim {
	c := Xautoclaim{command: emptyCommand(), cslot: b.slot}
	c.command.append("XAUTOCLAIM")
	return c
}

func (c Xautoclaim) Key(key string) XautoclaimKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XautoclaimKey(c)
}

type XautoclaimConsumer Base

func (c XautoclaimConsumer) MinIdleTime(minIdleTime string) XautoclaimMinIdleTime {
	c.command.append(minIdleTime)
	return XautoclaimMinIdleTime(c)
}

type XautoclaimCount Base

func (c XautoclaimCount) Justid() XautoclaimJustid {
	c.command.append("JUSTID")
	return XautoclaimJustid(c)
}

// Return Completed Redis command.
func (c XautoclaimCount) Build() Completed {
	return completed(c)
}

type XautoclaimGroup Base

func (c XautoclaimGroup) Consumer(consumer string) XautoclaimConsumer {
	c.command.append(consumer)
	return XautoclaimConsumer(c)
}

type XautoclaimJustid Base

// Return Completed Redis command.
func (c XautoclaimJustid) Build() Completed {
	return completed(c)
}

type XautoclaimKey Base

func (c XautoclaimKey) Group(group string) XautoclaimGroup {
	c.command.append(group)
	return XautoclaimGroup(c)
}

type XautoclaimMinIdleTime Base

func (c XautoclaimMinIdleTime) Start(start string) XautoclaimStart {
	c.command.append(start)
	return XautoclaimStart(c)
}

type XautoclaimStart Base

func (c XautoclaimStart) Count(count int64) XautoclaimCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return XautoclaimCount(c)
}

func (c XautoclaimStart) Justid() XautoclaimJustid {
	c.command.append("JUSTID")
	return XautoclaimJustid(c)
}

// Return Completed Redis command.
func (c XautoclaimStart) Build() Completed {
	return completed(c)
}

// Changes (or acquires) ownership of a message in a consumer group, as if the message was delivered to the specified consumer..
//
// Time complexity: O(log N) with N being the number of messages in the PEL of the consumer group.
type Xclaim Base

// Changes (or acquires) ownership of a message in a consumer group, as if the message was delivered to the specified consumer.
//
// Command: XCLAIM.
//
// Time complexity: O(log N) with N being the number of messages in the PEL of the consumer group.
func (b Builder) Xclaim() Xclaim {
	c := Xclaim{command: emptyCommand(), cslot: b.slot}
	c.command.append("XCLAIM")
	return c
}

func (c Xclaim) Key(key string) XclaimKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XclaimKey(c)
}

type XclaimConsumer Base

func (c XclaimConsumer) MinIdleTime(minIdleTime string) XclaimMinIdleTime {
	c.command.append(minIdleTime)
	return XclaimMinIdleTime(c)
}

type XclaimForce Base

func (c XclaimForce) Justid() XclaimJustid {
	c.command.append("JUSTID")
	return XclaimJustid(c)
}

func (c XclaimForce) Lastid() XclaimLastid {
	c.command.append("LASTID")
	return XclaimLastid(c)
}

// Return Completed Redis command.
func (c XclaimForce) Build() Completed {
	return completed(c)
}

type XclaimGroup Base

func (c XclaimGroup) Consumer(consumer string) XclaimConsumer {
	c.command.append(consumer)
	return XclaimConsumer(c)
}

type XclaimId Base

func (c XclaimId) Id(id ...string) XclaimId {
	c.command.append(id...)
	return c
}

func (c XclaimId) Idle(ms int64) XclaimIdle {
	c.command.append("IDLE", strconv.FormatInt(ms, 10))
	return XclaimIdle(c)
}

func (c XclaimId) Time(msUnixTime int64) XclaimTime {
	c.command.append("TIME", strconv.FormatInt(msUnixTime, 10))
	return XclaimTime(c)
}

func (c XclaimId) Retrycount(count int64) XclaimRetrycount {
	c.command.append("RETRYCOUNT", strconv.FormatInt(count, 10))
	return XclaimRetrycount(c)
}

func (c XclaimId) Force() XclaimForce {
	c.command.append("FORCE")
	return XclaimForce(c)
}

func (c XclaimId) Justid() XclaimJustid {
	c.command.append("JUSTID")
	return XclaimJustid(c)
}

func (c XclaimId) Lastid() XclaimLastid {
	c.command.append("LASTID")
	return XclaimLastid(c)
}

// Return Completed Redis command.
func (c XclaimId) Build() Completed {
	return completed(c)
}

type XclaimIdle Base

func (c XclaimIdle) Time(msUnixTime int64) XclaimTime {
	c.command.append("TIME", strconv.FormatInt(msUnixTime, 10))
	return XclaimTime(c)
}

func (c XclaimIdle) Retrycount(count int64) XclaimRetrycount {
	c.command.append("RETRYCOUNT", strconv.FormatInt(count, 10))
	return XclaimRetrycount(c)
}

func (c XclaimIdle) Force() XclaimForce {
	c.command.append("FORCE")
	return XclaimForce(c)
}

func (c XclaimIdle) Justid() XclaimJustid {
	c.command.append("JUSTID")
	return XclaimJustid(c)
}

func (c XclaimIdle) Lastid() XclaimLastid {
	c.command.append("LASTID")
	return XclaimLastid(c)
}

// Return Completed Redis command.
func (c XclaimIdle) Build() Completed {
	return completed(c)
}

type XclaimJustid Base

func (c XclaimJustid) Lastid() XclaimLastid {
	c.command.append("LASTID")
	return XclaimLastid(c)
}

// Return Completed Redis command.
func (c XclaimJustid) Build() Completed {
	return completed(c)
}

type XclaimKey Base

func (c XclaimKey) Group(group string) XclaimGroup {
	c.command.append(group)
	return XclaimGroup(c)
}

type XclaimLastid Base

// Return Completed Redis command.
func (c XclaimLastid) Build() Completed {
	return completed(c)
}

type XclaimMinIdleTime Base

func (c XclaimMinIdleTime) Id(id ...string) XclaimId {
	c.command.append(id...)
	return XclaimId(c)
}

type XclaimRetrycount Base

func (c XclaimRetrycount) Force() XclaimForce {
	c.command.append("FORCE")
	return XclaimForce(c)
}

func (c XclaimRetrycount) Justid() XclaimJustid {
	c.command.append("JUSTID")
	return XclaimJustid(c)
}

func (c XclaimRetrycount) Lastid() XclaimLastid {
	c.command.append("LASTID")
	return XclaimLastid(c)
}

// Return Completed Redis command.
func (c XclaimRetrycount) Build() Completed {
	return completed(c)
}

type XclaimTime Base

func (c XclaimTime) Retrycount(count int64) XclaimRetrycount {
	c.command.append("RETRYCOUNT", strconv.FormatInt(count, 10))
	return XclaimRetrycount(c)
}

func (c XclaimTime) Force() XclaimForce {
	c.command.append("FORCE")
	return XclaimForce(c)
}

func (c XclaimTime) Justid() XclaimJustid {
	c.command.append("JUSTID")
	return XclaimJustid(c)
}

func (c XclaimTime) Lastid() XclaimLastid {
	c.command.append("LASTID")
	return XclaimLastid(c)
}

// Return Completed Redis command.
func (c XclaimTime) Build() Completed {
	return completed(c)
}

// Removes the specified entries from the stream. Returns the number of items actually deleted, that may be different from the number of IDs passed in case certain IDs do not exist..
//
// Time complexity: O(1) for each single item to delete in the stream, regardless of the stream size.
type Xdel Base

// Removes the specified entries from the stream. Returns the number of items actually deleted, that may be different from the number of IDs passed in case certain IDs do not exist.
//
// Command: XDEL.
//
// Time complexity: O(1) for each single item to delete in the stream, regardless of the stream size.
func (b Builder) Xdel() Xdel {
	c := Xdel{command: emptyCommand(), cslot: b.slot}
	c.command.append("XDEL")
	return c
}

func (c Xdel) Key(key string) XdelKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XdelKey(c)
}

type XdelId Base

func (c XdelId) Id(id ...string) XdelId {
	c.command.append(id...)
	return c
}

// Return Completed Redis command.
func (c XdelId) Build() Completed {
	return completed(c)
}

type XdelKey Base

func (c XdelKey) Id(id ...string) XdelId {
	c.command.append(id...)
	return XdelId(c)
}

// Create a consumer group..
//
// Time complexity: O(1)
type XgroupCreate Base

// Create a consumer group.
//
// Command: XGROUP CREATE.
//
// Time complexity: O(1)
func (b Builder) XgroupCreate() XgroupCreate {
	c := XgroupCreate{command: emptyCommand(), cslot: b.slot}
	c.command.append("XGROUP", "CREATE")
	return c
}

func (c XgroupCreate) Key(key string) XgroupCreateKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XgroupCreateKey(c)
}

type XgroupCreateEntriesread Base

// Return Completed Redis command.
func (c XgroupCreateEntriesread) Build() Completed {
	return completed(c)
}

type XgroupCreateGroupname Base

func (c XgroupCreateGroupname) Id(id string) XgroupCreateId {
	c.command.append(id)
	return XgroupCreateId(c)
}

type XgroupCreateId Base

func (c XgroupCreateId) Mkstream() XgroupCreateMkstream {
	c.command.append("MKSTREAM")
	return XgroupCreateMkstream(c)
}

func (c XgroupCreateId) Entriesread(entriesRead int64) XgroupCreateEntriesread {
	c.command.append("ENTRIESREAD", strconv.FormatInt(entriesRead, 10))
	return XgroupCreateEntriesread(c)
}

// Return Completed Redis command.
func (c XgroupCreateId) Build() Completed {
	return completed(c)
}

type XgroupCreateKey Base

func (c XgroupCreateKey) Groupname(groupname string) XgroupCreateGroupname {
	c.command.append(groupname)
	return XgroupCreateGroupname(c)
}

type XgroupCreateMkstream Base

func (c XgroupCreateMkstream) Entriesread(entriesRead int64) XgroupCreateEntriesread {
	c.command.append("ENTRIESREAD", strconv.FormatInt(entriesRead, 10))
	return XgroupCreateEntriesread(c)
}

// Return Completed Redis command.
func (c XgroupCreateMkstream) Build() Completed {
	return completed(c)
}

// Create a consumer in a consumer group..
//
// Time complexity: O(1)
type XgroupCreateconsumer Base

// Create a consumer in a consumer group.
//
// Command: XGROUP CREATECONSUMER.
//
// Time complexity: O(1)
func (b Builder) XgroupCreateconsumer() XgroupCreateconsumer {
	c := XgroupCreateconsumer{command: emptyCommand(), cslot: b.slot}
	c.command.append("XGROUP", "CREATECONSUMER")
	return c
}

func (c XgroupCreateconsumer) Key(key string) XgroupCreateconsumerKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XgroupCreateconsumerKey(c)
}

type XgroupCreateconsumerConsumername Base

// Return Completed Redis command.
func (c XgroupCreateconsumerConsumername) Build() Completed {
	return completed(c)
}

type XgroupCreateconsumerGroupname Base

func (c XgroupCreateconsumerGroupname) Consumername(consumername string) XgroupCreateconsumerConsumername {
	c.command.append(consumername)
	return XgroupCreateconsumerConsumername(c)
}

type XgroupCreateconsumerKey Base

func (c XgroupCreateconsumerKey) Groupname(groupname string) XgroupCreateconsumerGroupname {
	c.command.append(groupname)
	return XgroupCreateconsumerGroupname(c)
}

// Delete a consumer from a consumer group..
//
// Time complexity: O(1)
type XgroupDelconsumer Base

// Delete a consumer from a consumer group.
//
// Command: XGROUP DELCONSUMER.
//
// Time complexity: O(1)
func (b Builder) XgroupDelconsumer() XgroupDelconsumer {
	c := XgroupDelconsumer{command: emptyCommand(), cslot: b.slot}
	c.command.append("XGROUP", "DELCONSUMER")
	return c
}

func (c XgroupDelconsumer) Key(key string) XgroupDelconsumerKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XgroupDelconsumerKey(c)
}

type XgroupDelconsumerConsumername Base

// Return Completed Redis command.
func (c XgroupDelconsumerConsumername) Build() Completed {
	return completed(c)
}

type XgroupDelconsumerGroupname Base

func (c XgroupDelconsumerGroupname) Consumername(consumername string) XgroupDelconsumerConsumername {
	c.command.append(consumername)
	return XgroupDelconsumerConsumername(c)
}

type XgroupDelconsumerKey Base

func (c XgroupDelconsumerKey) Groupname(groupname string) XgroupDelconsumerGroupname {
	c.command.append(groupname)
	return XgroupDelconsumerGroupname(c)
}

// Destroy a consumer group..
//
// Time complexity: O(N) where N is the number of entries in the group's pending entries list (PEL).
type XgroupDestroy Base

// Destroy a consumer group.
//
// Command: XGROUP DESTROY.
//
// Time complexity: O(N) where N is the number of entries in the group's pending entries list (PEL).
func (b Builder) XgroupDestroy() XgroupDestroy {
	c := XgroupDestroy{command: emptyCommand(), cslot: b.slot}
	c.command.append("XGROUP", "DESTROY")
	return c
}

func (c XgroupDestroy) Key(key string) XgroupDestroyKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XgroupDestroyKey(c)
}

type XgroupDestroyGroupname Base

// Return Completed Redis command.
func (c XgroupDestroyGroupname) Build() Completed {
	return completed(c)
}

type XgroupDestroyKey Base

func (c XgroupDestroyKey) Groupname(groupname string) XgroupDestroyGroupname {
	c.command.append(groupname)
	return XgroupDestroyGroupname(c)
}

// Show helpful text about the different subcommands.
//
// Time complexity: O(1)
type XgroupHelp Base

// Show helpful text about the different subcommands
//
// Command: XGROUP HELP.
//
// Time complexity: O(1)
func (b Builder) XgroupHelp() XgroupHelp {
	c := XgroupHelp{command: emptyCommand(), cslot: b.slot}
	c.command.append("XGROUP", "HELP")
	return c
}

// Return Completed Redis command.
func (c XgroupHelp) Build() Completed {
	return completed(c)
}

// Set a consumer group to an arbitrary last delivered ID value..
//
// Time complexity: O(1)
type XgroupSetid Base

// Set a consumer group to an arbitrary last delivered ID value.
//
// Command: XGROUP SETID.
//
// Time complexity: O(1)
func (b Builder) XgroupSetid() XgroupSetid {
	c := XgroupSetid{command: emptyCommand(), cslot: b.slot}
	c.command.append("XGROUP", "SETID")
	return c
}

func (c XgroupSetid) Key(key string) XgroupSetidKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XgroupSetidKey(c)
}

type XgroupSetidEntriesread Base

// Return Completed Redis command.
func (c XgroupSetidEntriesread) Build() Completed {
	return completed(c)
}

type XgroupSetidGroupname Base

func (c XgroupSetidGroupname) Id(id string) XgroupSetidId {
	c.command.append(id)
	return XgroupSetidId(c)
}

type XgroupSetidId Base

func (c XgroupSetidId) Entriesread(entriesRead int64) XgroupSetidEntriesread {
	c.command.append("ENTRIESREAD", strconv.FormatInt(entriesRead, 10))
	return XgroupSetidEntriesread(c)
}

// Return Completed Redis command.
func (c XgroupSetidId) Build() Completed {
	return completed(c)
}

type XgroupSetidKey Base

func (c XgroupSetidKey) Groupname(groupname string) XgroupSetidGroupname {
	c.command.append(groupname)
	return XgroupSetidGroupname(c)
}

// List the consumers in a consumer group.
//
// Time complexity: O(1)
type XinfoConsumers Base

// List the consumers in a consumer group
//
// Command: XINFO CONSUMERS.
//
// Time complexity: O(1)
func (b Builder) XinfoConsumers() XinfoConsumers {
	c := XinfoConsumers{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("XINFO", "CONSUMERS")
	return c
}

func (c XinfoConsumers) Key(key string) XinfoConsumersKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XinfoConsumersKey(c)
}

type XinfoConsumersGroupname Base

// Return Completed Redis command.
func (c XinfoConsumersGroupname) Build() Completed {
	return completed(c)
}

type XinfoConsumersKey Base

func (c XinfoConsumersKey) Groupname(groupname string) XinfoConsumersGroupname {
	c.command.append(groupname)
	return XinfoConsumersGroupname(c)
}

// List the consumer groups of a stream.
//
// Time complexity: O(1)
type XinfoGroups Base

// List the consumer groups of a stream
//
// Command: XINFO GROUPS.
//
// Time complexity: O(1)
func (b Builder) XinfoGroups() XinfoGroups {
	c := XinfoGroups{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("XINFO", "GROUPS")
	return c
}

func (c XinfoGroups) Key(key string) XinfoGroupsKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XinfoGroupsKey(c)
}

type XinfoGroupsKey Base

// Return Completed Redis command.
func (c XinfoGroupsKey) Build() Completed {
	return completed(c)
}

// Show helpful text about the different subcommands.
//
// Time complexity: O(1)
type XinfoHelp Base

// Show helpful text about the different subcommands
//
// Command: XINFO HELP.
//
// Time complexity: O(1)
func (b Builder) XinfoHelp() XinfoHelp {
	c := XinfoHelp{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("XINFO", "HELP")
	return c
}

// Return Completed Redis command.
func (c XinfoHelp) Build() Completed {
	return completed(c)
}

// Get information about a stream.
//
// Time complexity: O(1)
type XinfoStream Base

// Get information about a stream
//
// Command: XINFO STREAM.
//
// Time complexity: O(1)
func (b Builder) XinfoStream() XinfoStream {
	c := XinfoStream{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("XINFO", "STREAM")
	return c
}

func (c XinfoStream) Key(key string) XinfoStreamKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XinfoStreamKey(c)
}

type XinfoStreamFullCount Base

// Return Completed Redis command.
func (c XinfoStreamFullCount) Build() Completed {
	return completed(c)
}

type XinfoStreamFullFull Base

func (c XinfoStreamFullFull) Count(count int64) XinfoStreamFullCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return XinfoStreamFullCount(c)
}

// Return Completed Redis command.
func (c XinfoStreamFullFull) Build() Completed {
	return completed(c)
}

type XinfoStreamKey Base

func (c XinfoStreamKey) Full() XinfoStreamFullFull {
	c.command.append("FULL")
	return XinfoStreamFullFull(c)
}

// Return Completed Redis command.
func (c XinfoStreamKey) Build() Completed {
	return completed(c)
}

// Return the number of entries in a stream.
//
// Time complexity: O(1)
type Xlen Base

// Return the number of entries in a stream
//
// Command: XLEN.
//
// Time complexity: O(1)
func (b Builder) Xlen() Xlen {
	c := Xlen{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("XLEN")
	return c
}

func (c Xlen) Key(key string) XlenKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XlenKey(c)
}

type XlenKey Base

// Return Completed Redis command.
func (c XlenKey) Build() Completed {
	return completed(c)
}

// Return information and entries from a stream consumer group pending entries list, that are messages fetched but never acknowledged..
//
// Time complexity: O(N) with N being the number of elements returned, so asking for a small fixed number of entries per call is O(1). O(M), where M is the total number of entries scanned when used with the IDLE filter. When the command returns just the summary and the list of consumers is small, it runs in O(1) time; otherwise, an additional O(N) time for iterating every consumer.
type Xpending Base

// Return information and entries from a stream consumer group pending entries list, that are messages fetched but never acknowledged.
//
// Command: XPENDING.
//
// Time complexity: O(N) with N being the number of elements returned, so asking for a small fixed number of entries per call is O(1). O(M), where M is the total number of entries scanned when used with the IDLE filter. When the command returns just the summary and the list of consumers is small, it runs in O(1) time; otherwise, an additional O(N) time for iterating every consumer.
func (b Builder) Xpending() Xpending {
	c := Xpending{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("XPENDING")
	return c
}

func (c Xpending) Key(key string) XpendingKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XpendingKey(c)
}

type XpendingFiltersConsumer Base

// Return Completed Redis command.
func (c XpendingFiltersConsumer) Build() Completed {
	return completed(c)
}

type XpendingFiltersCount Base

func (c XpendingFiltersCount) Consumer(consumer string) XpendingFiltersConsumer {
	c.command.append(consumer)
	return XpendingFiltersConsumer(c)
}

// Return Completed Redis command.
func (c XpendingFiltersCount) Build() Completed {
	return completed(c)
}

type XpendingFiltersEnd Base

func (c XpendingFiltersEnd) Count(count int64) XpendingFiltersCount {
	c.command.append(strconv.FormatInt(count, 10))
	return XpendingFiltersCount(c)
}

type XpendingFiltersIdle Base

func (c XpendingFiltersIdle) Start(start string) XpendingFiltersStart {
	c.command.append(start)
	return XpendingFiltersStart(c)
}

type XpendingFiltersStart Base

func (c XpendingFiltersStart) End(end string) XpendingFiltersEnd {
	c.command.append(end)
	return XpendingFiltersEnd(c)
}

type XpendingGroup Base

func (c XpendingGroup) Idle(minIdleTime int64) XpendingFiltersIdle {
	c.command.append("IDLE", strconv.FormatInt(minIdleTime, 10))
	return XpendingFiltersIdle(c)
}

func (c XpendingGroup) Start(start string) XpendingFiltersStart {
	c.command.append(start)
	return XpendingFiltersStart(c)
}

// Return Completed Redis command.
func (c XpendingGroup) Build() Completed {
	return completed(c)
}

type XpendingKey Base

func (c XpendingKey) Group(group string) XpendingGroup {
	c.command.append(group)
	return XpendingGroup(c)
}

// Return a range of elements in a stream, with IDs matching the specified IDs interval.
//
// Time complexity: O(N) with N being the number of elements being returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).
type Xrange Base

// Return a range of elements in a stream, with IDs matching the specified IDs interval
//
// Command: XRANGE.
//
// Time complexity: O(N) with N being the number of elements being returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).
func (b Builder) Xrange() Xrange {
	c := Xrange{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("XRANGE")
	return c
}

func (c Xrange) Key(key string) XrangeKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XrangeKey(c)
}

type XrangeCount Base

// Return Completed Redis command.
func (c XrangeCount) Build() Completed {
	return completed(c)
}

type XrangeEnd Base

func (c XrangeEnd) Count(count int64) XrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return XrangeCount(c)
}

// Return Completed Redis command.
func (c XrangeEnd) Build() Completed {
	return completed(c)
}

type XrangeKey Base

func (c XrangeKey) Start(start string) XrangeStart {
	c.command.append(start)
	return XrangeStart(c)
}

type XrangeStart Base

func (c XrangeStart) End(end string) XrangeEnd {
	c.command.append(end)
	return XrangeEnd(c)
}

// Return never seen elements in multiple streams, with IDs greater than the ones reported by the caller for each stream. Can block..
//
// Time complexity: For each stream mentioned: O(N) with N being the number of elements being returned, it means that XREAD-ing with a fixed COUNT is O(1). Note that when the BLOCK option is used, XADD will pay O(M) time in order to serve the M clients blocked on the stream getting new data.
type Xread Base

// Return never seen elements in multiple streams, with IDs greater than the ones reported by the caller for each stream. Can block.
//
// Command: XREAD.
//
// Time complexity: For each stream mentioned: O(N) with N being the number of elements being returned, it means that XREAD-ing with a fixed COUNT is O(1). Note that when the BLOCK option is used, XADD will pay O(M) time in order to serve the M clients blocked on the stream getting new data.
func (b Builder) Xread() Xread {
	c := Xread{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("XREAD")
	return c
}

func (c Xread) Count(count int64) XreadCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return XreadCount(c)
}

func (c Xread) Block(milliseconds int64) XreadBlock {
	c.ctags = ctagBlock
	c.command.append("BLOCK", strconv.FormatInt(milliseconds, 10))
	return XreadBlock(c)
}

func (c Xread) Streams() XreadStreams {
	c.command.append("STREAMS")
	return XreadStreams(c)
}

type XreadBlock Base

func (c XreadBlock) Streams() XreadStreams {
	c.command.append("STREAMS")
	return XreadStreams(c)
}

type XreadCount Base

func (c XreadCount) Block(milliseconds int64) XreadBlock {
	c.ctags = ctagBlock
	c.command.append("BLOCK", strconv.FormatInt(milliseconds, 10))
	return XreadBlock(c)
}

func (c XreadCount) Streams() XreadStreams {
	c.command.append("STREAMS")
	return XreadStreams(c)
}

type XreadId Base

func (c XreadId) Id(id ...string) XreadId {
	c.command.append(id...)
	return c
}

// Return Completed Redis command.
func (c XreadId) Build() Completed {
	return completed(c)
}

type XreadKey Base

func (c XreadKey) Key(key ...string) XreadKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c XreadKey) Id(id ...string) XreadId {
	c.command.append(id...)
	return XreadId(c)
}

type XreadStreams Base

func (c XreadStreams) Key(key ...string) XreadKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return XreadKey(c)
}

// Return new entries from a stream using a consumer group, or access the history of the pending entries for a given consumer. Can block..
//
// Time complexity: For each stream mentioned: O(M) with M being the number of elements returned. If M is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1). On the other side when XREADGROUP blocks, XADD will pay the O(N) time in order to serve the N clients blocked on the stream getting new data.
type Xreadgroup Base

// Return new entries from a stream using a consumer group, or access the history of the pending entries for a given consumer. Can block.
//
// Command: XREADGROUP.
//
// Time complexity: For each stream mentioned: O(M) with M being the number of elements returned. If M is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1). On the other side when XREADGROUP blocks, XADD will pay the O(N) time in order to serve the N clients blocked on the stream getting new data.
func (b Builder) Xreadgroup() Xreadgroup {
	c := Xreadgroup{command: emptyCommand(), cslot: b.slot}
	c.command.append("XREADGROUP")
	return c
}

func (c Xreadgroup) Group(group string, consumer string) XreadgroupGroup {
	c.command.append("GROUP", group, consumer)
	return XreadgroupGroup(c)
}

type XreadgroupBlock Base

func (c XreadgroupBlock) Noack() XreadgroupNoack {
	c.command.append("NOACK")
	return XreadgroupNoack(c)
}

func (c XreadgroupBlock) Streams() XreadgroupStreams {
	c.command.append("STREAMS")
	return XreadgroupStreams(c)
}

type XreadgroupCount Base

func (c XreadgroupCount) Block(milliseconds int64) XreadgroupBlock {
	c.ctags = ctagBlock
	c.command.append("BLOCK", strconv.FormatInt(milliseconds, 10))
	return XreadgroupBlock(c)
}

func (c XreadgroupCount) Noack() XreadgroupNoack {
	c.command.append("NOACK")
	return XreadgroupNoack(c)
}

func (c XreadgroupCount) Streams() XreadgroupStreams {
	c.command.append("STREAMS")
	return XreadgroupStreams(c)
}

type XreadgroupGroup Base

func (c XreadgroupGroup) Count(count int64) XreadgroupCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return XreadgroupCount(c)
}

func (c XreadgroupGroup) Block(milliseconds int64) XreadgroupBlock {
	c.ctags = ctagBlock
	c.command.append("BLOCK", strconv.FormatInt(milliseconds, 10))
	return XreadgroupBlock(c)
}

func (c XreadgroupGroup) Noack() XreadgroupNoack {
	c.command.append("NOACK")
	return XreadgroupNoack(c)
}

func (c XreadgroupGroup) Streams() XreadgroupStreams {
	c.command.append("STREAMS")
	return XreadgroupStreams(c)
}

type XreadgroupId Base

func (c XreadgroupId) Id(id ...string) XreadgroupId {
	c.command.append(id...)
	return c
}

// Return Completed Redis command.
func (c XreadgroupId) Build() Completed {
	return completed(c)
}

type XreadgroupKey Base

func (c XreadgroupKey) Key(key ...string) XreadgroupKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c XreadgroupKey) Id(id ...string) XreadgroupId {
	c.command.append(id...)
	return XreadgroupId(c)
}

type XreadgroupNoack Base

func (c XreadgroupNoack) Streams() XreadgroupStreams {
	c.command.append("STREAMS")
	return XreadgroupStreams(c)
}

type XreadgroupStreams Base

func (c XreadgroupStreams) Key(key ...string) XreadgroupKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return XreadgroupKey(c)
}

// Return a range of elements in a stream, with IDs matching the specified IDs interval, in reverse order (from greater to smaller IDs) compared to XRANGE.
//
// Time complexity: O(N) with N being the number of elements returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).
type Xrevrange Base

// Return a range of elements in a stream, with IDs matching the specified IDs interval, in reverse order (from greater to smaller IDs) compared to XRANGE
//
// Command: XREVRANGE.
//
// Time complexity: O(N) with N being the number of elements returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).
func (b Builder) Xrevrange() Xrevrange {
	c := Xrevrange{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("XREVRANGE")
	return c
}

func (c Xrevrange) Key(key string) XrevrangeKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XrevrangeKey(c)
}

type XrevrangeCount Base

// Return Completed Redis command.
func (c XrevrangeCount) Build() Completed {
	return completed(c)
}

type XrevrangeEnd Base

func (c XrevrangeEnd) Start(start string) XrevrangeStart {
	c.command.append(start)
	return XrevrangeStart(c)
}

type XrevrangeKey Base

func (c XrevrangeKey) End(end string) XrevrangeEnd {
	c.command.append(end)
	return XrevrangeEnd(c)
}

type XrevrangeStart Base

func (c XrevrangeStart) Count(count int64) XrevrangeCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return XrevrangeCount(c)
}

// Return Completed Redis command.
func (c XrevrangeStart) Build() Completed {
	return completed(c)
}

// An internal command for replicating stream values.
//
// Time complexity: O(1)
type Xsetid Base

// An internal command for replicating stream values
//
// Command: XSETID.
//
// Time complexity: O(1)
func (b Builder) Xsetid() Xsetid {
	c := Xsetid{command: emptyCommand(), cslot: b.slot}
	c.command.append("XSETID")
	return c
}

func (c Xsetid) Key(key string) XsetidKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XsetidKey(c)
}

type XsetidEntriesadded Base

func (c XsetidEntriesadded) Maxdeletedid(maxDeletedEntryId string) XsetidMaxdeletedid {
	c.command.append("MAXDELETEDID", maxDeletedEntryId)
	return XsetidMaxdeletedid(c)
}

// Return Completed Redis command.
func (c XsetidEntriesadded) Build() Completed {
	return completed(c)
}

type XsetidKey Base

func (c XsetidKey) LastId(lastId string) XsetidLastId {
	c.command.append(lastId)
	return XsetidLastId(c)
}

type XsetidLastId Base

func (c XsetidLastId) Entriesadded(entriesAdded int64) XsetidEntriesadded {
	c.command.append("ENTRIESADDED", strconv.FormatInt(entriesAdded, 10))
	return XsetidEntriesadded(c)
}

func (c XsetidLastId) Maxdeletedid(maxDeletedEntryId string) XsetidMaxdeletedid {
	c.command.append("MAXDELETEDID", maxDeletedEntryId)
	return XsetidMaxdeletedid(c)
}

// Return Completed Redis command.
func (c XsetidLastId) Build() Completed {
	return completed(c)
}

type XsetidMaxdeletedid Base

// Return Completed Redis command.
func (c XsetidMaxdeletedid) Build() Completed {
	return completed(c)
}

// Trims the stream to (approximately if '~' is passed) a certain size.
//
// Time complexity: O(N), with N being the number of evicted entries. Constant times are very small however, since entries are organized in macro nodes containing multiple entries that can be released with a single deallocation.
type Xtrim Base

// Trims the stream to (approximately if '~' is passed) a certain size
//
// Command: XTRIM.
//
// Time complexity: O(N), with N being the number of evicted entries. Constant times are very small however, since entries are organized in macro nodes containing multiple entries that can be released with a single deallocation.
func (b Builder) Xtrim() Xtrim {
	c := Xtrim{command: emptyCommand(), cslot: b.slot}
	c.command.append("XTRIM")
	return c
}

func (c Xtrim) Key(key string) XtrimKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return XtrimKey(c)
}

type XtrimKey Base

func (c XtrimKey) Maxlen() XtrimTrimStrategyMaxlen {
	c.command.append("MAXLEN")
	return XtrimTrimStrategyMaxlen(c)
}

func (c XtrimKey) Minid() XtrimTrimStrategyMinid {
	c.command.append("MINID")
	return XtrimTrimStrategyMinid(c)
}

type XtrimTrimLimit Base

// Return Completed Redis command.
func (c XtrimTrimLimit) Build() Completed {
	return completed(c)
}

type XtrimTrimOperatorAlmost Base

func (c XtrimTrimOperatorAlmost) Threshold(threshold string) XtrimTrimThreshold {
	c.command.append(threshold)
	return XtrimTrimThreshold(c)
}

type XtrimTrimOperatorExact Base

func (c XtrimTrimOperatorExact) Threshold(threshold string) XtrimTrimThreshold {
	c.command.append(threshold)
	return XtrimTrimThreshold(c)
}

type XtrimTrimStrategyMaxlen Base

func (c XtrimTrimStrategyMaxlen) Exact() XtrimTrimOperatorExact {
	c.command.append("=")
	return XtrimTrimOperatorExact(c)
}

func (c XtrimTrimStrategyMaxlen) Almost() XtrimTrimOperatorAlmost {
	c.command.append("~")
	return XtrimTrimOperatorAlmost(c)
}

func (c XtrimTrimStrategyMaxlen) Threshold(threshold string) XtrimTrimThreshold {
	c.command.append(threshold)
	return XtrimTrimThreshold(c)
}

type XtrimTrimStrategyMinid Base

func (c XtrimTrimStrategyMinid) Exact() XtrimTrimOperatorExact {
	c.command.append("=")
	return XtrimTrimOperatorExact(c)
}

func (c XtrimTrimStrategyMinid) Almost() XtrimTrimOperatorAlmost {
	c.command.append("~")
	return XtrimTrimOperatorAlmost(c)
}

func (c XtrimTrimStrategyMinid) Threshold(threshold string) XtrimTrimThreshold {
	c.command.append(threshold)
	return XtrimTrimThreshold(c)
}

type XtrimTrimThreshold Base

func (c XtrimTrimThreshold) Limit(count int64) XtrimTrimLimit {
	c.command.append("LIMIT", strconv.FormatInt(count, 10))
	return XtrimTrimLimit(c)
}

// Return Completed Redis command.
func (c XtrimTrimThreshold) Build() Completed {
	return completed(c)
}

// Add one or more members to a sorted set, or update its score if it already exists.
//
// Time complexity: O(log(N)) for each item added, where N is the number of elements in the sorted set.
type Zadd Base

// Add one or more members to a sorted set, or update its score if it already exists
//
// Command: ZADD.
//
// Time complexity: O(log(N)) for each item added, where N is the number of elements in the sorted set.
func (b Builder) Zadd() Zadd {
	c := Zadd{command: emptyCommand(), cslot: b.slot}
	c.command.append("ZADD")
	return c
}

func (c Zadd) Key(key string) ZaddKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZaddKey(c)
}

type ZaddChangeCh Base

func (c ZaddChangeCh) Incr() ZaddIncrementIncr {
	c.command.append("INCR")
	return ZaddIncrementIncr(c)
}

func (c ZaddChangeCh) ScoreMember() ZaddScoreMember {
	return ZaddScoreMember(c)
}

type ZaddComparisonGt Base

func (c ZaddComparisonGt) Ch() ZaddChangeCh {
	c.command.append("CH")
	return ZaddChangeCh(c)
}

func (c ZaddComparisonGt) Incr() ZaddIncrementIncr {
	c.command.append("INCR")
	return ZaddIncrementIncr(c)
}

func (c ZaddComparisonGt) ScoreMember() ZaddScoreMember {
	return ZaddScoreMember(c)
}

type ZaddComparisonLt Base

func (c ZaddComparisonLt) Ch() ZaddChangeCh {
	c.command.append("CH")
	return ZaddChangeCh(c)
}

func (c ZaddComparisonLt) Incr() ZaddIncrementIncr {
	c.command.append("INCR")
	return ZaddIncrementIncr(c)
}

func (c ZaddComparisonLt) ScoreMember() ZaddScoreMember {
	return ZaddScoreMember(c)
}

type ZaddConditionNx Base

func (c ZaddConditionNx) Gt() ZaddComparisonGt {
	c.command.append("GT")
	return ZaddComparisonGt(c)
}

func (c ZaddConditionNx) Lt() ZaddComparisonLt {
	c.command.append("LT")
	return ZaddComparisonLt(c)
}

func (c ZaddConditionNx) Ch() ZaddChangeCh {
	c.command.append("CH")
	return ZaddChangeCh(c)
}

func (c ZaddConditionNx) Incr() ZaddIncrementIncr {
	c.command.append("INCR")
	return ZaddIncrementIncr(c)
}

func (c ZaddConditionNx) ScoreMember() ZaddScoreMember {
	return ZaddScoreMember(c)
}

type ZaddConditionXx Base

func (c ZaddConditionXx) Gt() ZaddComparisonGt {
	c.command.append("GT")
	return ZaddComparisonGt(c)
}

func (c ZaddConditionXx) Lt() ZaddComparisonLt {
	c.command.append("LT")
	return ZaddComparisonLt(c)
}

func (c ZaddConditionXx) Ch() ZaddChangeCh {
	c.command.append("CH")
	return ZaddChangeCh(c)
}

func (c ZaddConditionXx) Incr() ZaddIncrementIncr {
	c.command.append("INCR")
	return ZaddIncrementIncr(c)
}

func (c ZaddConditionXx) ScoreMember() ZaddScoreMember {
	return ZaddScoreMember(c)
}

type ZaddIncrementIncr Base

func (c ZaddIncrementIncr) ScoreMember() ZaddScoreMember {
	return ZaddScoreMember(c)
}

type ZaddKey Base

func (c ZaddKey) Nx() ZaddConditionNx {
	c.command.append("NX")
	return ZaddConditionNx(c)
}

func (c ZaddKey) Xx() ZaddConditionXx {
	c.command.append("XX")
	return ZaddConditionXx(c)
}

func (c ZaddKey) Gt() ZaddComparisonGt {
	c.command.append("GT")
	return ZaddComparisonGt(c)
}

func (c ZaddKey) Lt() ZaddComparisonLt {
	c.command.append("LT")
	return ZaddComparisonLt(c)
}

func (c ZaddKey) Ch() ZaddChangeCh {
	c.command.append("CH")
	return ZaddChangeCh(c)
}

func (c ZaddKey) Incr() ZaddIncrementIncr {
	c.command.append("INCR")
	return ZaddIncrementIncr(c)
}

func (c ZaddKey) ScoreMember() ZaddScoreMember {
	return ZaddScoreMember(c)
}

type ZaddScoreMember Base

func (c ZaddScoreMember) ScoreMember(score float64, member string) ZaddScoreMember {
	c.command.append(strconv.FormatFloat(score, 'f', -1, 64), member)
	return c
}

// Return Completed Redis command.
func (c ZaddScoreMember) Build() Completed {
	return completed(c)
}

// Get the number of members in a sorted set.
//
// Time complexity: O(1)
type Zcard Base

// Get the number of members in a sorted set
//
// Command: ZCARD.
//
// Time complexity: O(1)
func (b Builder) Zcard() Zcard {
	c := Zcard{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZCARD")
	return c
}

func (c Zcard) Key(key string) ZcardKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZcardKey(c)
}

type ZcardKey Base

// Return Completed Redis command.
func (c ZcardKey) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZcardKey) Cache() Cacheable {
	return cacheable(c)
}

// Count the members in a sorted set with scores within the given values.
//
// Time complexity: O(log(N)) with N being the number of elements in the sorted set.
type Zcount Base

// Count the members in a sorted set with scores within the given values
//
// Command: ZCOUNT.
//
// Time complexity: O(log(N)) with N being the number of elements in the sorted set.
func (b Builder) Zcount() Zcount {
	c := Zcount{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZCOUNT")
	return c
}

func (c Zcount) Key(key string) ZcountKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZcountKey(c)
}

type ZcountKey Base

func (c ZcountKey) Min(min string) ZcountMin {
	c.command.append(min)
	return ZcountMin(c)
}

type ZcountMax Base

// Return Completed Redis command.
func (c ZcountMax) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZcountMax) Cache() Cacheable {
	return cacheable(c)
}

type ZcountMin Base

func (c ZcountMin) Max(max string) ZcountMax {
	c.command.append(max)
	return ZcountMax(c)
}

// Subtract multiple sorted sets.
//
// Time complexity: O(L + (N-K)log(N)) worst case where L is the total number of elements in all the sets, N is the size of the first set, and K is the size of the result set.
type Zdiff Base

// Subtract multiple sorted sets
//
// Command: ZDIFF.
//
// Time complexity: O(L + (N-K)log(N)) worst case where L is the total number of elements in all the sets, N is the size of the first set, and K is the size of the result set.
func (b Builder) Zdiff() Zdiff {
	c := Zdiff{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZDIFF")
	return c
}

func (c Zdiff) Numkeys(numkeys int64) ZdiffNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return ZdiffNumkeys(c)
}

type ZdiffKey Base

func (c ZdiffKey) Key(key ...string) ZdiffKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c ZdiffKey) Withscores() ZdiffWithscores {
	c.command.append("WITHSCORES")
	return ZdiffWithscores(c)
}

// Return Completed Redis command.
func (c ZdiffKey) Build() Completed {
	return completed(c)
}

type ZdiffNumkeys Base

func (c ZdiffNumkeys) Key(key ...string) ZdiffKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return ZdiffKey(c)
}

type ZdiffWithscores Base

// Return Completed Redis command.
func (c ZdiffWithscores) Build() Completed {
	return completed(c)
}

// Subtract multiple sorted sets and store the resulting sorted set in a new key.
//
// Time complexity: O(L + (N-K)log(N)) worst case where L is the total number of elements in all the sets, N is the size of the first set, and K is the size of the result set.
type Zdiffstore Base

// Subtract multiple sorted sets and store the resulting sorted set in a new key
//
// Command: ZDIFFSTORE.
//
// Time complexity: O(L + (N-K)log(N)) worst case where L is the total number of elements in all the sets, N is the size of the first set, and K is the size of the result set.
func (b Builder) Zdiffstore() Zdiffstore {
	c := Zdiffstore{command: emptyCommand(), cslot: b.slot}
	c.command.append("ZDIFFSTORE")
	return c
}

func (c Zdiffstore) Destination(destination string) ZdiffstoreDestination {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append(destination)
	return ZdiffstoreDestination(c)
}

type ZdiffstoreDestination Base

func (c ZdiffstoreDestination) Numkeys(numkeys int64) ZdiffstoreNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return ZdiffstoreNumkeys(c)
}

type ZdiffstoreKey Base

func (c ZdiffstoreKey) Key(key ...string) ZdiffstoreKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

// Return Completed Redis command.
func (c ZdiffstoreKey) Build() Completed {
	return completed(c)
}

type ZdiffstoreNumkeys Base

func (c ZdiffstoreNumkeys) Key(key ...string) ZdiffstoreKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return ZdiffstoreKey(c)
}

// Increment the score of a member in a sorted set.
//
// Time complexity: O(log(N)) where N is the number of elements in the sorted set.
type Zincrby Base

// Increment the score of a member in a sorted set
//
// Command: ZINCRBY.
//
// Time complexity: O(log(N)) where N is the number of elements in the sorted set.
func (b Builder) Zincrby() Zincrby {
	c := Zincrby{command: emptyCommand(), cslot: b.slot}
	c.command.append("ZINCRBY")
	return c
}

func (c Zincrby) Key(key string) ZincrbyKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZincrbyKey(c)
}

type ZincrbyIncrement Base

func (c ZincrbyIncrement) Member(member string) ZincrbyMember {
	c.command.append(member)
	return ZincrbyMember(c)
}

type ZincrbyKey Base

func (c ZincrbyKey) Increment(increment float64) ZincrbyIncrement {
	c.command.append(strconv.FormatFloat(increment, 'f', -1, 64))
	return ZincrbyIncrement(c)
}

type ZincrbyMember Base

// Return Completed Redis command.
func (c ZincrbyMember) Build() Completed {
	return completed(c)
}

// Intersect multiple sorted sets.
//
// Time complexity: O(N*K)+O(M*log(M)) worst case with N being the smallest input sorted set, K being the number of input sorted sets and M being the number of elements in the resulting sorted set.
type Zinter Base

// Intersect multiple sorted sets
//
// Command: ZINTER.
//
// Time complexity: O(N*K)+O(M*log(M)) worst case with N being the smallest input sorted set, K being the number of input sorted sets and M being the number of elements in the resulting sorted set.
func (b Builder) Zinter() Zinter {
	c := Zinter{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZINTER")
	return c
}

func (c Zinter) Numkeys(numkeys int64) ZinterNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return ZinterNumkeys(c)
}

type ZinterAggregateMax Base

func (c ZinterAggregateMax) Withscores() ZinterWithscores {
	c.command.append("WITHSCORES")
	return ZinterWithscores(c)
}

// Return Completed Redis command.
func (c ZinterAggregateMax) Build() Completed {
	return completed(c)
}

type ZinterAggregateMin Base

func (c ZinterAggregateMin) Withscores() ZinterWithscores {
	c.command.append("WITHSCORES")
	return ZinterWithscores(c)
}

// Return Completed Redis command.
func (c ZinterAggregateMin) Build() Completed {
	return completed(c)
}

type ZinterAggregateSum Base

func (c ZinterAggregateSum) Withscores() ZinterWithscores {
	c.command.append("WITHSCORES")
	return ZinterWithscores(c)
}

// Return Completed Redis command.
func (c ZinterAggregateSum) Build() Completed {
	return completed(c)
}

type ZinterKey Base

func (c ZinterKey) Key(key ...string) ZinterKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c ZinterKey) Weights(weight ...int64) ZinterWeights {
	c.command.append("WEIGHTS")
	for _, n := range weight {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return ZinterWeights(c)
}

func (c ZinterKey) AggregateSum() ZinterAggregateSum {
	c.command.append("AGGREGATE", "SUM")
	return ZinterAggregateSum(c)
}

func (c ZinterKey) AggregateMin() ZinterAggregateMin {
	c.command.append("AGGREGATE", "MIN")
	return ZinterAggregateMin(c)
}

func (c ZinterKey) AggregateMax() ZinterAggregateMax {
	c.command.append("AGGREGATE", "MAX")
	return ZinterAggregateMax(c)
}

func (c ZinterKey) Withscores() ZinterWithscores {
	c.command.append("WITHSCORES")
	return ZinterWithscores(c)
}

// Return Completed Redis command.
func (c ZinterKey) Build() Completed {
	return completed(c)
}

type ZinterNumkeys Base

func (c ZinterNumkeys) Key(key ...string) ZinterKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return ZinterKey(c)
}

type ZinterWeights Base

func (c ZinterWeights) Weights(weight ...int64) ZinterWeights {
	c.command.append("WEIGHTS")
	for _, n := range weight {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return c
}

func (c ZinterWeights) AggregateSum() ZinterAggregateSum {
	c.command.append("AGGREGATE", "SUM")
	return ZinterAggregateSum(c)
}

func (c ZinterWeights) AggregateMin() ZinterAggregateMin {
	c.command.append("AGGREGATE", "MIN")
	return ZinterAggregateMin(c)
}

func (c ZinterWeights) AggregateMax() ZinterAggregateMax {
	c.command.append("AGGREGATE", "MAX")
	return ZinterAggregateMax(c)
}

func (c ZinterWeights) Withscores() ZinterWithscores {
	c.command.append("WITHSCORES")
	return ZinterWithscores(c)
}

// Return Completed Redis command.
func (c ZinterWeights) Build() Completed {
	return completed(c)
}

type ZinterWithscores Base

// Return Completed Redis command.
func (c ZinterWithscores) Build() Completed {
	return completed(c)
}

// Intersect multiple sorted sets and return the cardinality of the result.
//
// Time complexity: O(N*K) worst case with N being the smallest input sorted set, K being the number of input sorted sets.
type Zintercard Base

// Intersect multiple sorted sets and return the cardinality of the result
//
// Command: ZINTERCARD.
//
// Time complexity: O(N*K) worst case with N being the smallest input sorted set, K being the number of input sorted sets.
func (b Builder) Zintercard() Zintercard {
	c := Zintercard{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZINTERCARD")
	return c
}

func (c Zintercard) Numkeys(numkeys int64) ZintercardNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return ZintercardNumkeys(c)
}

type ZintercardKey Base

func (c ZintercardKey) Key(key ...string) ZintercardKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c ZintercardKey) Limit(limit int64) ZintercardLimit {
	c.command.append("LIMIT", strconv.FormatInt(limit, 10))
	return ZintercardLimit(c)
}

// Return Completed Redis command.
func (c ZintercardKey) Build() Completed {
	return completed(c)
}

type ZintercardLimit Base

// Return Completed Redis command.
func (c ZintercardLimit) Build() Completed {
	return completed(c)
}

type ZintercardNumkeys Base

func (c ZintercardNumkeys) Key(key ...string) ZintercardKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return ZintercardKey(c)
}

// Intersect multiple sorted sets and store the resulting sorted set in a new key.
//
// Time complexity: O(N*K)+O(M*log(M)) worst case with N being the smallest input sorted set, K being the number of input sorted sets and M being the number of elements in the resulting sorted set.
type Zinterstore Base

// Intersect multiple sorted sets and store the resulting sorted set in a new key
//
// Command: ZINTERSTORE.
//
// Time complexity: O(N*K)+O(M*log(M)) worst case with N being the smallest input sorted set, K being the number of input sorted sets and M being the number of elements in the resulting sorted set.
func (b Builder) Zinterstore() Zinterstore {
	c := Zinterstore{command: emptyCommand(), cslot: b.slot}
	c.command.append("ZINTERSTORE")
	return c
}

func (c Zinterstore) Destination(destination string) ZinterstoreDestination {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append(destination)
	return ZinterstoreDestination(c)
}

type ZinterstoreAggregateMax Base

// Return Completed Redis command.
func (c ZinterstoreAggregateMax) Build() Completed {
	return completed(c)
}

type ZinterstoreAggregateMin Base

// Return Completed Redis command.
func (c ZinterstoreAggregateMin) Build() Completed {
	return completed(c)
}

type ZinterstoreAggregateSum Base

// Return Completed Redis command.
func (c ZinterstoreAggregateSum) Build() Completed {
	return completed(c)
}

type ZinterstoreDestination Base

func (c ZinterstoreDestination) Numkeys(numkeys int64) ZinterstoreNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return ZinterstoreNumkeys(c)
}

type ZinterstoreKey Base

func (c ZinterstoreKey) Key(key ...string) ZinterstoreKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c ZinterstoreKey) Weights(weight ...int64) ZinterstoreWeights {
	c.command.append("WEIGHTS")
	for _, n := range weight {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return ZinterstoreWeights(c)
}

func (c ZinterstoreKey) AggregateSum() ZinterstoreAggregateSum {
	c.command.append("AGGREGATE", "SUM")
	return ZinterstoreAggregateSum(c)
}

func (c ZinterstoreKey) AggregateMin() ZinterstoreAggregateMin {
	c.command.append("AGGREGATE", "MIN")
	return ZinterstoreAggregateMin(c)
}

func (c ZinterstoreKey) AggregateMax() ZinterstoreAggregateMax {
	c.command.append("AGGREGATE", "MAX")
	return ZinterstoreAggregateMax(c)
}

// Return Completed Redis command.
func (c ZinterstoreKey) Build() Completed {
	return completed(c)
}

type ZinterstoreNumkeys Base

func (c ZinterstoreNumkeys) Key(key ...string) ZinterstoreKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return ZinterstoreKey(c)
}

type ZinterstoreWeights Base

func (c ZinterstoreWeights) Weights(weight ...int64) ZinterstoreWeights {
	c.command.append("WEIGHTS")
	for _, n := range weight {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return c
}

func (c ZinterstoreWeights) AggregateSum() ZinterstoreAggregateSum {
	c.command.append("AGGREGATE", "SUM")
	return ZinterstoreAggregateSum(c)
}

func (c ZinterstoreWeights) AggregateMin() ZinterstoreAggregateMin {
	c.command.append("AGGREGATE", "MIN")
	return ZinterstoreAggregateMin(c)
}

func (c ZinterstoreWeights) AggregateMax() ZinterstoreAggregateMax {
	c.command.append("AGGREGATE", "MAX")
	return ZinterstoreAggregateMax(c)
}

// Return Completed Redis command.
func (c ZinterstoreWeights) Build() Completed {
	return completed(c)
}

// Count the number of members in a sorted set between a given lexicographical range.
//
// Time complexity: O(log(N)) with N being the number of elements in the sorted set.
type Zlexcount Base

// Count the number of members in a sorted set between a given lexicographical range
//
// Command: ZLEXCOUNT.
//
// Time complexity: O(log(N)) with N being the number of elements in the sorted set.
func (b Builder) Zlexcount() Zlexcount {
	c := Zlexcount{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZLEXCOUNT")
	return c
}

func (c Zlexcount) Key(key string) ZlexcountKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZlexcountKey(c)
}

type ZlexcountKey Base

func (c ZlexcountKey) Min(min string) ZlexcountMin {
	c.command.append(min)
	return ZlexcountMin(c)
}

type ZlexcountMax Base

// Return Completed Redis command.
func (c ZlexcountMax) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZlexcountMax) Cache() Cacheable {
	return cacheable(c)
}

type ZlexcountMin Base

func (c ZlexcountMin) Max(max string) ZlexcountMax {
	c.command.append(max)
	return ZlexcountMax(c)
}

// Remove and return members with scores in a sorted set.
//
// Time complexity: O(K) + O(N*log(M)) where K is the number of provided keys, N being the number of elements in the sorted set, and M being the number of elements popped.
type Zmpop Base

// Remove and return members with scores in a sorted set
//
// Command: ZMPOP.
//
// Time complexity: O(K) + O(N*log(M)) where K is the number of provided keys, N being the number of elements in the sorted set, and M being the number of elements popped.
func (b Builder) Zmpop() Zmpop {
	c := Zmpop{command: emptyCommand(), cslot: b.slot}
	c.command.append("ZMPOP")
	return c
}

func (c Zmpop) Numkeys(numkeys int64) ZmpopNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return ZmpopNumkeys(c)
}

type ZmpopCount Base

// Return Completed Redis command.
func (c ZmpopCount) Build() Completed {
	return completed(c)
}

type ZmpopKey Base

func (c ZmpopKey) Key(key ...string) ZmpopKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c ZmpopKey) Min() ZmpopWhereMin {
	c.command.append("MIN")
	return ZmpopWhereMin(c)
}

func (c ZmpopKey) Max() ZmpopWhereMax {
	c.command.append("MAX")
	return ZmpopWhereMax(c)
}

type ZmpopNumkeys Base

func (c ZmpopNumkeys) Key(key ...string) ZmpopKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return ZmpopKey(c)
}

type ZmpopWhereMax Base

func (c ZmpopWhereMax) Count(count int64) ZmpopCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return ZmpopCount(c)
}

// Return Completed Redis command.
func (c ZmpopWhereMax) Build() Completed {
	return completed(c)
}

type ZmpopWhereMin Base

func (c ZmpopWhereMin) Count(count int64) ZmpopCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return ZmpopCount(c)
}

// Return Completed Redis command.
func (c ZmpopWhereMin) Build() Completed {
	return completed(c)
}

// Get the score associated with the given members in a sorted set.
//
// Time complexity: O(N) where N is the number of members being requested.
type Zmscore Base

// Get the score associated with the given members in a sorted set
//
// Command: ZMSCORE.
//
// Time complexity: O(N) where N is the number of members being requested.
func (b Builder) Zmscore() Zmscore {
	c := Zmscore{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZMSCORE")
	return c
}

func (c Zmscore) Key(key string) ZmscoreKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZmscoreKey(c)
}

type ZmscoreKey Base

func (c ZmscoreKey) Member(member ...string) ZmscoreMember {
	c.command.append(member...)
	return ZmscoreMember(c)
}

type ZmscoreMember Base

func (c ZmscoreMember) Member(member ...string) ZmscoreMember {
	c.command.append(member...)
	return c
}

// Return Completed Redis command.
func (c ZmscoreMember) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZmscoreMember) Cache() Cacheable {
	return cacheable(c)
}

// Remove and return members with the highest scores in a sorted set.
//
// Time complexity: O(log(N)*M) with N being the number of elements in the sorted set, and M being the number of elements popped.
type Zpopmax Base

// Remove and return members with the highest scores in a sorted set
//
// Command: ZPOPMAX.
//
// Time complexity: O(log(N)*M) with N being the number of elements in the sorted set, and M being the number of elements popped.
func (b Builder) Zpopmax() Zpopmax {
	c := Zpopmax{command: emptyCommand(), cslot: b.slot}
	c.command.append("ZPOPMAX")
	return c
}

func (c Zpopmax) Key(key string) ZpopmaxKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZpopmaxKey(c)
}

type ZpopmaxCount Base

// Return Completed Redis command.
func (c ZpopmaxCount) Build() Completed {
	return completed(c)
}

type ZpopmaxKey Base

func (c ZpopmaxKey) Count(count int64) ZpopmaxCount {
	c.command.append(strconv.FormatInt(count, 10))
	return ZpopmaxCount(c)
}

// Return Completed Redis command.
func (c ZpopmaxKey) Build() Completed {
	return completed(c)
}

// Remove and return members with the lowest scores in a sorted set.
//
// Time complexity: O(log(N)*M) with N being the number of elements in the sorted set, and M being the number of elements popped.
type Zpopmin Base

// Remove and return members with the lowest scores in a sorted set
//
// Command: ZPOPMIN.
//
// Time complexity: O(log(N)*M) with N being the number of elements in the sorted set, and M being the number of elements popped.
func (b Builder) Zpopmin() Zpopmin {
	c := Zpopmin{command: emptyCommand(), cslot: b.slot}
	c.command.append("ZPOPMIN")
	return c
}

func (c Zpopmin) Key(key string) ZpopminKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZpopminKey(c)
}

type ZpopminCount Base

// Return Completed Redis command.
func (c ZpopminCount) Build() Completed {
	return completed(c)
}

type ZpopminKey Base

func (c ZpopminKey) Count(count int64) ZpopminCount {
	c.command.append(strconv.FormatInt(count, 10))
	return ZpopminCount(c)
}

// Return Completed Redis command.
func (c ZpopminKey) Build() Completed {
	return completed(c)
}

// Get one or multiple random elements from a sorted set.
//
// Time complexity: O(N) where N is the number of elements returned
type Zrandmember Base

// Get one or multiple random elements from a sorted set
//
// Command: ZRANDMEMBER.
//
// Time complexity: O(N) where N is the number of elements returned
func (b Builder) Zrandmember() Zrandmember {
	c := Zrandmember{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZRANDMEMBER")
	return c
}

func (c Zrandmember) Key(key string) ZrandmemberKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZrandmemberKey(c)
}

type ZrandmemberKey Base

func (c ZrandmemberKey) Count(count int64) ZrandmemberOptionsCount {
	c.command.append(strconv.FormatInt(count, 10))
	return ZrandmemberOptionsCount(c)
}

// Return Completed Redis command.
func (c ZrandmemberKey) Build() Completed {
	return completed(c)
}

type ZrandmemberOptionsCount Base

func (c ZrandmemberOptionsCount) Withscores() ZrandmemberOptionsWithscores {
	c.command.append("WITHSCORES")
	return ZrandmemberOptionsWithscores(c)
}

// Return Completed Redis command.
func (c ZrandmemberOptionsCount) Build() Completed {
	return completed(c)
}

type ZrandmemberOptionsWithscores Base

// Return Completed Redis command.
func (c ZrandmemberOptionsWithscores) Build() Completed {
	return completed(c)
}

// Return a range of members in a sorted set.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements returned.
type Zrange Base

// Return a range of members in a sorted set
//
// Command: ZRANGE.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements returned.
func (b Builder) Zrange() Zrange {
	c := Zrange{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZRANGE")
	return c
}

func (c Zrange) Key(key string) ZrangeKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZrangeKey(c)
}

type ZrangeKey Base

func (c ZrangeKey) Min(min string) ZrangeMin {
	c.command.append(min)
	return ZrangeMin(c)
}

type ZrangeLimit Base

func (c ZrangeLimit) Withscores() ZrangeWithscores {
	c.command.append("WITHSCORES")
	return ZrangeWithscores(c)
}

// Return Completed Redis command.
func (c ZrangeLimit) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrangeLimit) Cache() Cacheable {
	return cacheable(c)
}

type ZrangeMax Base

func (c ZrangeMax) Byscore() ZrangeSortbyByscore {
	c.command.append("BYSCORE")
	return ZrangeSortbyByscore(c)
}

func (c ZrangeMax) Bylex() ZrangeSortbyBylex {
	c.command.append("BYLEX")
	return ZrangeSortbyBylex(c)
}

func (c ZrangeMax) Rev() ZrangeRev {
	c.command.append("REV")
	return ZrangeRev(c)
}

func (c ZrangeMax) Limit(offset int64, count int64) ZrangeLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return ZrangeLimit(c)
}

func (c ZrangeMax) Withscores() ZrangeWithscores {
	c.command.append("WITHSCORES")
	return ZrangeWithscores(c)
}

// Return Completed Redis command.
func (c ZrangeMax) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrangeMax) Cache() Cacheable {
	return cacheable(c)
}

type ZrangeMin Base

func (c ZrangeMin) Max(max string) ZrangeMax {
	c.command.append(max)
	return ZrangeMax(c)
}

type ZrangeRev Base

func (c ZrangeRev) Limit(offset int64, count int64) ZrangeLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return ZrangeLimit(c)
}

func (c ZrangeRev) Withscores() ZrangeWithscores {
	c.command.append("WITHSCORES")
	return ZrangeWithscores(c)
}

// Return Completed Redis command.
func (c ZrangeRev) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrangeRev) Cache() Cacheable {
	return cacheable(c)
}

type ZrangeSortbyBylex Base

func (c ZrangeSortbyBylex) Rev() ZrangeRev {
	c.command.append("REV")
	return ZrangeRev(c)
}

func (c ZrangeSortbyBylex) Limit(offset int64, count int64) ZrangeLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return ZrangeLimit(c)
}

func (c ZrangeSortbyBylex) Withscores() ZrangeWithscores {
	c.command.append("WITHSCORES")
	return ZrangeWithscores(c)
}

// Return Completed Redis command.
func (c ZrangeSortbyBylex) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrangeSortbyBylex) Cache() Cacheable {
	return cacheable(c)
}

type ZrangeSortbyByscore Base

func (c ZrangeSortbyByscore) Rev() ZrangeRev {
	c.command.append("REV")
	return ZrangeRev(c)
}

func (c ZrangeSortbyByscore) Limit(offset int64, count int64) ZrangeLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return ZrangeLimit(c)
}

func (c ZrangeSortbyByscore) Withscores() ZrangeWithscores {
	c.command.append("WITHSCORES")
	return ZrangeWithscores(c)
}

// Return Completed Redis command.
func (c ZrangeSortbyByscore) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrangeSortbyByscore) Cache() Cacheable {
	return cacheable(c)
}

type ZrangeWithscores Base

// Return Completed Redis command.
func (c ZrangeWithscores) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrangeWithscores) Cache() Cacheable {
	return cacheable(c)
}

// Return a range of members in a sorted set, by lexicographical range.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).
type Zrangebylex Base

// Return a range of members in a sorted set, by lexicographical range
//
// Command: ZRANGEBYLEX.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).
func (b Builder) Zrangebylex() Zrangebylex {
	c := Zrangebylex{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZRANGEBYLEX")
	return c
}

func (c Zrangebylex) Key(key string) ZrangebylexKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZrangebylexKey(c)
}

type ZrangebylexKey Base

func (c ZrangebylexKey) Min(min string) ZrangebylexMin {
	c.command.append(min)
	return ZrangebylexMin(c)
}

type ZrangebylexLimit Base

// Return Completed Redis command.
func (c ZrangebylexLimit) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrangebylexLimit) Cache() Cacheable {
	return cacheable(c)
}

type ZrangebylexMax Base

func (c ZrangebylexMax) Limit(offset int64, count int64) ZrangebylexLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return ZrangebylexLimit(c)
}

// Return Completed Redis command.
func (c ZrangebylexMax) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrangebylexMax) Cache() Cacheable {
	return cacheable(c)
}

type ZrangebylexMin Base

func (c ZrangebylexMin) Max(max string) ZrangebylexMax {
	c.command.append(max)
	return ZrangebylexMax(c)
}

// Return a range of members in a sorted set, by score.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).
type Zrangebyscore Base

// Return a range of members in a sorted set, by score
//
// Command: ZRANGEBYSCORE.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).
func (b Builder) Zrangebyscore() Zrangebyscore {
	c := Zrangebyscore{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZRANGEBYSCORE")
	return c
}

func (c Zrangebyscore) Key(key string) ZrangebyscoreKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZrangebyscoreKey(c)
}

type ZrangebyscoreKey Base

func (c ZrangebyscoreKey) Min(min string) ZrangebyscoreMin {
	c.command.append(min)
	return ZrangebyscoreMin(c)
}

type ZrangebyscoreLimit Base

// Return Completed Redis command.
func (c ZrangebyscoreLimit) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrangebyscoreLimit) Cache() Cacheable {
	return cacheable(c)
}

type ZrangebyscoreMax Base

func (c ZrangebyscoreMax) Withscores() ZrangebyscoreWithscores {
	c.command.append("WITHSCORES")
	return ZrangebyscoreWithscores(c)
}

func (c ZrangebyscoreMax) Limit(offset int64, count int64) ZrangebyscoreLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return ZrangebyscoreLimit(c)
}

// Return Completed Redis command.
func (c ZrangebyscoreMax) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrangebyscoreMax) Cache() Cacheable {
	return cacheable(c)
}

type ZrangebyscoreMin Base

func (c ZrangebyscoreMin) Max(max string) ZrangebyscoreMax {
	c.command.append(max)
	return ZrangebyscoreMax(c)
}

type ZrangebyscoreWithscores Base

func (c ZrangebyscoreWithscores) Limit(offset int64, count int64) ZrangebyscoreLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return ZrangebyscoreLimit(c)
}

// Return Completed Redis command.
func (c ZrangebyscoreWithscores) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrangebyscoreWithscores) Cache() Cacheable {
	return cacheable(c)
}

// Store a range of members from sorted set into another key.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements stored into the destination key.
type Zrangestore Base

// Store a range of members from sorted set into another key
//
// Command: ZRANGESTORE.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements stored into the destination key.
func (b Builder) Zrangestore() Zrangestore {
	c := Zrangestore{command: emptyCommand(), cslot: b.slot}
	c.command.append("ZRANGESTORE")
	return c
}

func (c Zrangestore) Dst(dst string) ZrangestoreDst {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(dst)
	} else {
		c.cslot.set(getSlot(dst))
	}
	c.command.append(dst)
	return ZrangestoreDst(c)
}

type ZrangestoreDst Base

func (c ZrangestoreDst) Src(src string) ZrangestoreSrc {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(src)
	} else {
		c.cslot.set(getSlot(src))
	}
	c.command.append(src)
	return ZrangestoreSrc(c)
}

type ZrangestoreLimit Base

// Return Completed Redis command.
func (c ZrangestoreLimit) Build() Completed {
	return completed(c)
}

type ZrangestoreMax Base

func (c ZrangestoreMax) Byscore() ZrangestoreSortbyByscore {
	c.command.append("BYSCORE")
	return ZrangestoreSortbyByscore(c)
}

func (c ZrangestoreMax) Bylex() ZrangestoreSortbyBylex {
	c.command.append("BYLEX")
	return ZrangestoreSortbyBylex(c)
}

func (c ZrangestoreMax) Rev() ZrangestoreRev {
	c.command.append("REV")
	return ZrangestoreRev(c)
}

func (c ZrangestoreMax) Limit(offset int64, count int64) ZrangestoreLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return ZrangestoreLimit(c)
}

// Return Completed Redis command.
func (c ZrangestoreMax) Build() Completed {
	return completed(c)
}

type ZrangestoreMin Base

func (c ZrangestoreMin) Max(max string) ZrangestoreMax {
	c.command.append(max)
	return ZrangestoreMax(c)
}

type ZrangestoreRev Base

func (c ZrangestoreRev) Limit(offset int64, count int64) ZrangestoreLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return ZrangestoreLimit(c)
}

// Return Completed Redis command.
func (c ZrangestoreRev) Build() Completed {
	return completed(c)
}

type ZrangestoreSortbyBylex Base

func (c ZrangestoreSortbyBylex) Rev() ZrangestoreRev {
	c.command.append("REV")
	return ZrangestoreRev(c)
}

func (c ZrangestoreSortbyBylex) Limit(offset int64, count int64) ZrangestoreLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return ZrangestoreLimit(c)
}

// Return Completed Redis command.
func (c ZrangestoreSortbyBylex) Build() Completed {
	return completed(c)
}

type ZrangestoreSortbyByscore Base

func (c ZrangestoreSortbyByscore) Rev() ZrangestoreRev {
	c.command.append("REV")
	return ZrangestoreRev(c)
}

func (c ZrangestoreSortbyByscore) Limit(offset int64, count int64) ZrangestoreLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return ZrangestoreLimit(c)
}

// Return Completed Redis command.
func (c ZrangestoreSortbyByscore) Build() Completed {
	return completed(c)
}

type ZrangestoreSrc Base

func (c ZrangestoreSrc) Min(min string) ZrangestoreMin {
	c.command.append(min)
	return ZrangestoreMin(c)
}

// Determine the index of a member in a sorted set.
//
// Time complexity: O(log(N))
type Zrank Base

// Determine the index of a member in a sorted set
//
// Command: ZRANK.
//
// Time complexity: O(log(N))
func (b Builder) Zrank() Zrank {
	c := Zrank{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZRANK")
	return c
}

func (c Zrank) Key(key string) ZrankKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZrankKey(c)
}

type ZrankKey Base

func (c ZrankKey) Member(member string) ZrankMember {
	c.command.append(member)
	return ZrankMember(c)
}

type ZrankMember Base

// Return Completed Redis command.
func (c ZrankMember) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrankMember) Cache() Cacheable {
	return cacheable(c)
}

// Remove one or more members from a sorted set.
//
// Time complexity: O(M*log(N)) with N being the number of elements in the sorted set and M the number of elements to be removed.
type Zrem Base

// Remove one or more members from a sorted set
//
// Command: ZREM.
//
// Time complexity: O(M*log(N)) with N being the number of elements in the sorted set and M the number of elements to be removed.
func (b Builder) Zrem() Zrem {
	c := Zrem{command: emptyCommand(), cslot: b.slot}
	c.command.append("ZREM")
	return c
}

func (c Zrem) Key(key string) ZremKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZremKey(c)
}

type ZremKey Base

func (c ZremKey) Member(member ...string) ZremMember {
	c.command.append(member...)
	return ZremMember(c)
}

type ZremMember Base

func (c ZremMember) Member(member ...string) ZremMember {
	c.command.append(member...)
	return c
}

// Return Completed Redis command.
func (c ZremMember) Build() Completed {
	return completed(c)
}

// Remove all members in a sorted set between the given lexicographical range.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation.
type Zremrangebylex Base

// Remove all members in a sorted set between the given lexicographical range
//
// Command: ZREMRANGEBYLEX.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation.
func (b Builder) Zremrangebylex() Zremrangebylex {
	c := Zremrangebylex{command: emptyCommand(), cslot: b.slot}
	c.command.append("ZREMRANGEBYLEX")
	return c
}

func (c Zremrangebylex) Key(key string) ZremrangebylexKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZremrangebylexKey(c)
}

type ZremrangebylexKey Base

func (c ZremrangebylexKey) Min(min string) ZremrangebylexMin {
	c.command.append(min)
	return ZremrangebylexMin(c)
}

type ZremrangebylexMax Base

// Return Completed Redis command.
func (c ZremrangebylexMax) Build() Completed {
	return completed(c)
}

type ZremrangebylexMin Base

func (c ZremrangebylexMin) Max(max string) ZremrangebylexMax {
	c.command.append(max)
	return ZremrangebylexMax(c)
}

// Remove all members in a sorted set within the given indexes.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation.
type Zremrangebyrank Base

// Remove all members in a sorted set within the given indexes
//
// Command: ZREMRANGEBYRANK.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation.
func (b Builder) Zremrangebyrank() Zremrangebyrank {
	c := Zremrangebyrank{command: emptyCommand(), cslot: b.slot}
	c.command.append("ZREMRANGEBYRANK")
	return c
}

func (c Zremrangebyrank) Key(key string) ZremrangebyrankKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZremrangebyrankKey(c)
}

type ZremrangebyrankKey Base

func (c ZremrangebyrankKey) Start(start int64) ZremrangebyrankStart {
	c.command.append(strconv.FormatInt(start, 10))
	return ZremrangebyrankStart(c)
}

type ZremrangebyrankStart Base

func (c ZremrangebyrankStart) Stop(stop int64) ZremrangebyrankStop {
	c.command.append(strconv.FormatInt(stop, 10))
	return ZremrangebyrankStop(c)
}

type ZremrangebyrankStop Base

// Return Completed Redis command.
func (c ZremrangebyrankStop) Build() Completed {
	return completed(c)
}

// Remove all members in a sorted set within the given scores.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation.
type Zremrangebyscore Base

// Remove all members in a sorted set within the given scores
//
// Command: ZREMRANGEBYSCORE.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation.
func (b Builder) Zremrangebyscore() Zremrangebyscore {
	c := Zremrangebyscore{command: emptyCommand(), cslot: b.slot}
	c.command.append("ZREMRANGEBYSCORE")
	return c
}

func (c Zremrangebyscore) Key(key string) ZremrangebyscoreKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZremrangebyscoreKey(c)
}

type ZremrangebyscoreKey Base

func (c ZremrangebyscoreKey) Min(min string) ZremrangebyscoreMin {
	c.command.append(min)
	return ZremrangebyscoreMin(c)
}

type ZremrangebyscoreMax Base

// Return Completed Redis command.
func (c ZremrangebyscoreMax) Build() Completed {
	return completed(c)
}

type ZremrangebyscoreMin Base

func (c ZremrangebyscoreMin) Max(max string) ZremrangebyscoreMax {
	c.command.append(max)
	return ZremrangebyscoreMax(c)
}

// Return a range of members in a sorted set, by index, with scores ordered from high to low.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements returned.
type Zrevrange Base

// Return a range of members in a sorted set, by index, with scores ordered from high to low
//
// Command: ZREVRANGE.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements returned.
func (b Builder) Zrevrange() Zrevrange {
	c := Zrevrange{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZREVRANGE")
	return c
}

func (c Zrevrange) Key(key string) ZrevrangeKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZrevrangeKey(c)
}

type ZrevrangeKey Base

func (c ZrevrangeKey) Start(start int64) ZrevrangeStart {
	c.command.append(strconv.FormatInt(start, 10))
	return ZrevrangeStart(c)
}

type ZrevrangeStart Base

func (c ZrevrangeStart) Stop(stop int64) ZrevrangeStop {
	c.command.append(strconv.FormatInt(stop, 10))
	return ZrevrangeStop(c)
}

type ZrevrangeStop Base

func (c ZrevrangeStop) Withscores() ZrevrangeWithscores {
	c.command.append("WITHSCORES")
	return ZrevrangeWithscores(c)
}

// Return Completed Redis command.
func (c ZrevrangeStop) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrevrangeStop) Cache() Cacheable {
	return cacheable(c)
}

type ZrevrangeWithscores Base

// Return Completed Redis command.
func (c ZrevrangeWithscores) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrevrangeWithscores) Cache() Cacheable {
	return cacheable(c)
}

// Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings..
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).
type Zrevrangebylex Base

// Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.
//
// Command: ZREVRANGEBYLEX.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).
func (b Builder) Zrevrangebylex() Zrevrangebylex {
	c := Zrevrangebylex{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZREVRANGEBYLEX")
	return c
}

func (c Zrevrangebylex) Key(key string) ZrevrangebylexKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZrevrangebylexKey(c)
}

type ZrevrangebylexKey Base

func (c ZrevrangebylexKey) Max(max string) ZrevrangebylexMax {
	c.command.append(max)
	return ZrevrangebylexMax(c)
}

type ZrevrangebylexLimit Base

// Return Completed Redis command.
func (c ZrevrangebylexLimit) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrevrangebylexLimit) Cache() Cacheable {
	return cacheable(c)
}

type ZrevrangebylexMax Base

func (c ZrevrangebylexMax) Min(min string) ZrevrangebylexMin {
	c.command.append(min)
	return ZrevrangebylexMin(c)
}

type ZrevrangebylexMin Base

func (c ZrevrangebylexMin) Limit(offset int64, count int64) ZrevrangebylexLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return ZrevrangebylexLimit(c)
}

// Return Completed Redis command.
func (c ZrevrangebylexMin) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrevrangebylexMin) Cache() Cacheable {
	return cacheable(c)
}

// Return a range of members in a sorted set, by score, with scores ordered from high to low.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).
type Zrevrangebyscore Base

// Return a range of members in a sorted set, by score, with scores ordered from high to low
//
// Command: ZREVRANGEBYSCORE.
//
// Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).
func (b Builder) Zrevrangebyscore() Zrevrangebyscore {
	c := Zrevrangebyscore{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZREVRANGEBYSCORE")
	return c
}

func (c Zrevrangebyscore) Key(key string) ZrevrangebyscoreKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZrevrangebyscoreKey(c)
}

type ZrevrangebyscoreKey Base

func (c ZrevrangebyscoreKey) Max(max string) ZrevrangebyscoreMax {
	c.command.append(max)
	return ZrevrangebyscoreMax(c)
}

type ZrevrangebyscoreLimit Base

// Return Completed Redis command.
func (c ZrevrangebyscoreLimit) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrevrangebyscoreLimit) Cache() Cacheable {
	return cacheable(c)
}

type ZrevrangebyscoreMax Base

func (c ZrevrangebyscoreMax) Min(min string) ZrevrangebyscoreMin {
	c.command.append(min)
	return ZrevrangebyscoreMin(c)
}

type ZrevrangebyscoreMin Base

func (c ZrevrangebyscoreMin) Withscores() ZrevrangebyscoreWithscores {
	c.command.append("WITHSCORES")
	return ZrevrangebyscoreWithscores(c)
}

func (c ZrevrangebyscoreMin) Limit(offset int64, count int64) ZrevrangebyscoreLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return ZrevrangebyscoreLimit(c)
}

// Return Completed Redis command.
func (c ZrevrangebyscoreMin) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrevrangebyscoreMin) Cache() Cacheable {
	return cacheable(c)
}

type ZrevrangebyscoreWithscores Base

func (c ZrevrangebyscoreWithscores) Limit(offset int64, count int64) ZrevrangebyscoreLimit {
	c.command.append("LIMIT", strconv.FormatInt(offset, 10), strconv.FormatInt(count, 10))
	return ZrevrangebyscoreLimit(c)
}

// Return Completed Redis command.
func (c ZrevrangebyscoreWithscores) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrevrangebyscoreWithscores) Cache() Cacheable {
	return cacheable(c)
}

// Determine the index of a member in a sorted set, with scores ordered from high to low.
//
// Time complexity: O(log(N))
type Zrevrank Base

// Determine the index of a member in a sorted set, with scores ordered from high to low
//
// Command: ZREVRANK.
//
// Time complexity: O(log(N))
func (b Builder) Zrevrank() Zrevrank {
	c := Zrevrank{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZREVRANK")
	return c
}

func (c Zrevrank) Key(key string) ZrevrankKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZrevrankKey(c)
}

type ZrevrankKey Base

func (c ZrevrankKey) Member(member string) ZrevrankMember {
	c.command.append(member)
	return ZrevrankMember(c)
}

type ZrevrankMember Base

// Return Completed Redis command.
func (c ZrevrankMember) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZrevrankMember) Cache() Cacheable {
	return cacheable(c)
}

// Incrementally iterate sorted sets elements and associated scores.
//
// Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..
type Zscan Base

// Incrementally iterate sorted sets elements and associated scores
//
// Command: ZSCAN.
//
// Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..
func (b Builder) Zscan() Zscan {
	c := Zscan{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZSCAN")
	return c
}

func (c Zscan) Key(key string) ZscanKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZscanKey(c)
}

type ZscanCount Base

// Return Completed Redis command.
func (c ZscanCount) Build() Completed {
	return completed(c)
}

type ZscanCursor Base

func (c ZscanCursor) Match(pattern string) ZscanMatch {
	c.command.append("MATCH", pattern)
	return ZscanMatch(c)
}

func (c ZscanCursor) Count(count int64) ZscanCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return ZscanCount(c)
}

// Return Completed Redis command.
func (c ZscanCursor) Build() Completed {
	return completed(c)
}

type ZscanKey Base

func (c ZscanKey) Cursor(cursor int64) ZscanCursor {
	c.command.append(strconv.FormatInt(cursor, 10))
	return ZscanCursor(c)
}

type ZscanMatch Base

func (c ZscanMatch) Count(count int64) ZscanCount {
	c.command.append("COUNT", strconv.FormatInt(count, 10))
	return ZscanCount(c)
}

// Return Completed Redis command.
func (c ZscanMatch) Build() Completed {
	return completed(c)
}

// Get the score associated with the given member in a sorted set.
//
// Time complexity: O(1)
type Zscore Base

// Get the score associated with the given member in a sorted set
//
// Command: ZSCORE.
//
// Time complexity: O(1)
func (b Builder) Zscore() Zscore {
	c := Zscore{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZSCORE")
	return c
}

func (c Zscore) Key(key string) ZscoreKey {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(key)
	} else {
		c.cslot.set(getSlot(key))
	}
	c.command.append(key)
	return ZscoreKey(c)
}

type ZscoreKey Base

func (c ZscoreKey) Member(member string) ZscoreMember {
	c.command.append(member)
	return ZscoreMember(c)
}

type ZscoreMember Base

// Return Completed Redis command.
func (c ZscoreMember) Build() Completed {
	return completed(c)
}

// Return Completed Cacheable Redis command.
func (c ZscoreMember) Cache() Cacheable {
	return cacheable(c)
}

// Add multiple sorted sets.
//
// Time complexity: O(N)+O(M*log(M)) with N being the sum of the sizes of the input sorted sets, and M being the number of elements in the resulting sorted set.
type Zunion Base

// Add multiple sorted sets
//
// Command: ZUNION.
//
// Time complexity: O(N)+O(M*log(M)) with N being the sum of the sizes of the input sorted sets, and M being the number of elements in the resulting sorted set.
func (b Builder) Zunion() Zunion {
	c := Zunion{command: emptyCommand(), cslot: b.slot, ctags: ctagReadOnly}
	c.command.append("ZUNION")
	return c
}

func (c Zunion) Numkeys(numkeys int64) ZunionNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return ZunionNumkeys(c)
}

type ZunionAggregateMax Base

func (c ZunionAggregateMax) Withscores() ZunionWithscores {
	c.command.append("WITHSCORES")
	return ZunionWithscores(c)
}

// Return Completed Redis command.
func (c ZunionAggregateMax) Build() Completed {
	return completed(c)
}

type ZunionAggregateMin Base

func (c ZunionAggregateMin) Withscores() ZunionWithscores {
	c.command.append("WITHSCORES")
	return ZunionWithscores(c)
}

// Return Completed Redis command.
func (c ZunionAggregateMin) Build() Completed {
	return completed(c)
}

type ZunionAggregateSum Base

func (c ZunionAggregateSum) Withscores() ZunionWithscores {
	c.command.append("WITHSCORES")
	return ZunionWithscores(c)
}

// Return Completed Redis command.
func (c ZunionAggregateSum) Build() Completed {
	return completed(c)
}

type ZunionKey Base

func (c ZunionKey) Key(key ...string) ZunionKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c ZunionKey) Weights(weight ...int64) ZunionWeights {
	c.command.append("WEIGHTS")
	for _, n := range weight {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return ZunionWeights(c)
}

func (c ZunionKey) AggregateSum() ZunionAggregateSum {
	c.command.append("AGGREGATE", "SUM")
	return ZunionAggregateSum(c)
}

func (c ZunionKey) AggregateMin() ZunionAggregateMin {
	c.command.append("AGGREGATE", "MIN")
	return ZunionAggregateMin(c)
}

func (c ZunionKey) AggregateMax() ZunionAggregateMax {
	c.command.append("AGGREGATE", "MAX")
	return ZunionAggregateMax(c)
}

func (c ZunionKey) Withscores() ZunionWithscores {
	c.command.append("WITHSCORES")
	return ZunionWithscores(c)
}

// Return Completed Redis command.
func (c ZunionKey) Build() Completed {
	return completed(c)
}

type ZunionNumkeys Base

func (c ZunionNumkeys) Key(key ...string) ZunionKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return ZunionKey(c)
}

type ZunionWeights Base

func (c ZunionWeights) Weights(weight ...int64) ZunionWeights {
	c.command.append("WEIGHTS")
	for _, n := range weight {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return c
}

func (c ZunionWeights) AggregateSum() ZunionAggregateSum {
	c.command.append("AGGREGATE", "SUM")
	return ZunionAggregateSum(c)
}

func (c ZunionWeights) AggregateMin() ZunionAggregateMin {
	c.command.append("AGGREGATE", "MIN")
	return ZunionAggregateMin(c)
}

func (c ZunionWeights) AggregateMax() ZunionAggregateMax {
	c.command.append("AGGREGATE", "MAX")
	return ZunionAggregateMax(c)
}

func (c ZunionWeights) Withscores() ZunionWithscores {
	c.command.append("WITHSCORES")
	return ZunionWithscores(c)
}

// Return Completed Redis command.
func (c ZunionWeights) Build() Completed {
	return completed(c)
}

type ZunionWithscores Base

// Return Completed Redis command.
func (c ZunionWithscores) Build() Completed {
	return completed(c)
}

// Add multiple sorted sets and store the resulting sorted set in a new key.
//
// Time complexity: O(N)+O(M log(M)) with N being the sum of the sizes of the input sorted sets, and M being the number of elements in the resulting sorted set.
type Zunionstore Base

// Add multiple sorted sets and store the resulting sorted set in a new key
//
// Command: ZUNIONSTORE.
//
// Time complexity: O(N)+O(M log(M)) with N being the sum of the sizes of the input sorted sets, and M being the number of elements in the resulting sorted set.
func (b Builder) Zunionstore() Zunionstore {
	c := Zunionstore{command: emptyCommand(), cslot: b.slot}
	c.command.append("ZUNIONSTORE")
	return c
}

func (c Zunionstore) Destination(destination string) ZunionstoreDestination {
	if c.cslot&cslotNo == cslotNo {
		c.cslot = cslotNo | getSlot(destination)
	} else {
		c.cslot.set(getSlot(destination))
	}
	c.command.append(destination)
	return ZunionstoreDestination(c)
}

type ZunionstoreAggregateMax Base

// Return Completed Redis command.
func (c ZunionstoreAggregateMax) Build() Completed {
	return completed(c)
}

type ZunionstoreAggregateMin Base

// Return Completed Redis command.
func (c ZunionstoreAggregateMin) Build() Completed {
	return completed(c)
}

type ZunionstoreAggregateSum Base

// Return Completed Redis command.
func (c ZunionstoreAggregateSum) Build() Completed {
	return completed(c)
}

type ZunionstoreDestination Base

func (c ZunionstoreDestination) Numkeys(numkeys int64) ZunionstoreNumkeys {
	c.command.append(strconv.FormatInt(numkeys, 10))
	return ZunionstoreNumkeys(c)
}

type ZunionstoreKey Base

func (c ZunionstoreKey) Key(key ...string) ZunionstoreKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return c
}

func (c ZunionstoreKey) Weights(weight ...int64) ZunionstoreWeights {
	c.command.append("WEIGHTS")
	for _, n := range weight {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return ZunionstoreWeights(c)
}

func (c ZunionstoreKey) AggregateSum() ZunionstoreAggregateSum {
	c.command.append("AGGREGATE", "SUM")
	return ZunionstoreAggregateSum(c)
}

func (c ZunionstoreKey) AggregateMin() ZunionstoreAggregateMin {
	c.command.append("AGGREGATE", "MIN")
	return ZunionstoreAggregateMin(c)
}

func (c ZunionstoreKey) AggregateMax() ZunionstoreAggregateMax {
	c.command.append("AGGREGATE", "MAX")
	return ZunionstoreAggregateMax(c)
}

// Return Completed Redis command.
func (c ZunionstoreKey) Build() Completed {
	return completed(c)
}

type ZunionstoreNumkeys Base

func (c ZunionstoreNumkeys) Key(key ...string) ZunionstoreKey {
	if c.cslot&cslotNo == cslotNo {
		for _, k := range key {
			c.cslot = cslotNo | getSlot(k)
			break
		}
	} else {
		for _, k := range key {
			c.cslot.set(getSlot(k))
		}
	}
	c.command.append(key...)
	return ZunionstoreKey(c)
}

type ZunionstoreWeights Base

func (c ZunionstoreWeights) Weights(weight ...int64) ZunionstoreWeights {
	c.command.append("WEIGHTS")
	for _, n := range weight {
		c.command.append(strconv.FormatInt(n, 10))
	}
	return c
}

func (c ZunionstoreWeights) AggregateSum() ZunionstoreAggregateSum {
	c.command.append("AGGREGATE", "SUM")
	return ZunionstoreAggregateSum(c)
}

func (c ZunionstoreWeights) AggregateMin() ZunionstoreAggregateMin {
	c.command.append("AGGREGATE", "MIN")
	return ZunionstoreAggregateMin(c)
}

func (c ZunionstoreWeights) AggregateMax() ZunionstoreAggregateMax {
	c.command.append("AGGREGATE", "MAX")
	return ZunionstoreAggregateMax(c)
}

// Return Completed Redis command.
func (c ZunionstoreWeights) Build() Completed {
	return completed(c)
}
